{"ast":null,"code":"/**\r\n * DevExtreme (viz/series/points/range_symbol_point.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar each = require(\"../../../core/utils/iterator\").each;\n\nvar extend = require(\"../../../core/utils/extend\").extend;\n\nvar noop = require(\"../../../core/utils/common\").noop;\n\nvar labelModule = require(\"./label\");\n\nvar symbolPoint = require(\"./symbol_point\");\n\nvar _extend = extend;\n\nvar _isDefined = require(\"../../../core/utils/type\").isDefined;\n\nvar _math = Math;\nvar _abs = _math.abs;\nvar _min = _math.min;\nvar _max = _math.max;\nvar _round = _math.round;\nvar DEFAULT_IMAGE_WIDTH = 20;\nvar DEFAULT_IMAGE_HEIGHT = 20;\nmodule.exports = _extend({}, symbolPoint, {\n  deleteLabel: function () {\n    var that = this;\n\n    that._topLabel.dispose();\n\n    that._topLabel = null;\n\n    that._bottomLabel.dispose();\n\n    that._bottomLabel = null;\n  },\n  hideMarker: function (type) {\n    var graphic = this.graphic;\n    var marker = graphic && graphic[type + \"Marker\"];\n    var label = this[\"_\" + type + \"Label\"];\n\n    if (marker && \"hidden\" !== marker.attr(\"visibility\")) {\n      marker.attr({\n        visibility: \"hidden\"\n      });\n    }\n\n    label.draw(false);\n  },\n  setInvisibility: function () {\n    this.hideMarker(\"top\");\n    this.hideMarker(\"bottom\");\n  },\n  clearVisibility: function () {\n    var that = this;\n    var graphic = that.graphic;\n    var topMarker = graphic && graphic.topMarker;\n    var bottomMarker = graphic && graphic.bottomMarker;\n\n    if (topMarker && topMarker.attr(\"visibility\")) {\n      topMarker.attr({\n        visibility: null\n      });\n    }\n\n    if (bottomMarker && bottomMarker.attr(\"visibility\")) {\n      bottomMarker.attr({\n        visibility: null\n      });\n    }\n  },\n  clearMarker: function () {\n    var that = this;\n    var graphic = that.graphic;\n    var topMarker = graphic && graphic.topMarker;\n    var bottomMarker = graphic && graphic.bottomMarker;\n    var emptySettings = that._emptySettings;\n    topMarker && topMarker.attr(emptySettings);\n    bottomMarker && bottomMarker.attr(emptySettings);\n  },\n  _getLabelPosition: function (markerType) {\n    var position;\n    var labelsInside = \"inside\" === this._options.label.position;\n\n    if (!this._options.rotated) {\n      position = \"top\" === markerType ^ labelsInside ? \"top\" : \"bottom\";\n    } else {\n      position = \"top\" === markerType ^ labelsInside ? \"right\" : \"left\";\n    }\n\n    return position;\n  },\n  _getLabelMinFormatObject: function () {\n    var that = this;\n    return {\n      index: 0,\n      argument: that.initialArgument,\n      value: that.initialMinValue,\n      seriesName: that.series.name,\n      originalValue: that.originalMinValue,\n      originalArgument: that.originalArgument,\n      point: that\n    };\n  },\n  _updateLabelData: function () {\n    var maxFormatObject = this._getLabelFormatObject();\n\n    maxFormatObject.index = 1;\n\n    this._topLabel.setData(maxFormatObject);\n\n    this._bottomLabel.setData(this._getLabelMinFormatObject());\n  },\n  _updateLabelOptions: function () {\n    var that = this;\n    var options = this._options.label;\n    (!that._topLabel || !that._bottomLabel) && that._createLabel();\n\n    that._topLabel.setOptions(options);\n\n    that._bottomLabel.setOptions(options);\n  },\n  _createLabel: function () {\n    var options = {\n      renderer: this.series._renderer,\n      labelsGroup: this.series._labelsGroup,\n      point: this\n    };\n    this._topLabel = new labelModule.Label(options);\n    this._bottomLabel = new labelModule.Label(options);\n  },\n  _getGraphicBBox: function (location) {\n    var options = this._options;\n\n    var images = this._getImage(options.image);\n\n    var image = \"top\" === location ? this._checkImage(images.top) : this._checkImage(images.bottom);\n    var bBox;\n\n    var coord = this._getPositionFromLocation(location);\n\n    if (options.visible) {\n      bBox = image ? this._getImageBBox(coord.x, coord.y) : this._getSymbolBBox(coord.x, coord.y, options.styles.normal.r);\n    } else {\n      bBox = {\n        x: coord.x,\n        y: coord.y,\n        width: 0,\n        height: 0\n      };\n    }\n\n    return bBox;\n  },\n  _getPositionFromLocation: function (location) {\n    var x;\n    var y;\n    var isTop = \"top\" === location;\n\n    if (!this._options.rotated) {\n      x = this.x;\n      y = isTop ? _min(this.y, this.minY) : _max(this.y, this.minY);\n    } else {\n      x = isTop ? _max(this.x, this.minX) : _min(this.x, this.minX);\n      y = this.y;\n    }\n\n    return {\n      x: x,\n      y: y\n    };\n  },\n  _checkOverlay: function (bottomCoord, topCoord, topValue) {\n    return bottomCoord < topCoord + topValue;\n  },\n  _getOverlayCorrections: function (topCoords, bottomCoords) {\n    var rotated = this._options.rotated;\n    var coordSelector = !rotated ? \"y\" : \"x\";\n    var valueSelector = !rotated ? \"height\" : \"width\";\n    var visibleArea = this.series.getValueAxis().getVisibleArea();\n    var minBound = visibleArea[0];\n    var maxBound = visibleArea[1];\n\n    var delta = _round((topCoords[coordSelector] + topCoords[valueSelector] - bottomCoords[coordSelector]) / 2);\n\n    var coord1 = topCoords[coordSelector] - delta;\n    var coord2 = bottomCoords[coordSelector] + delta;\n\n    if (coord1 < minBound) {\n      delta = minBound - topCoords[coordSelector];\n      coord1 += delta;\n      coord2 += delta;\n    } else {\n      if (coord2 + bottomCoords[valueSelector] > maxBound) {\n        delta = -(bottomCoords[coordSelector] + bottomCoords[valueSelector] - maxBound);\n        coord1 += delta;\n        coord2 += delta;\n      }\n    }\n\n    return {\n      coord1: coord1,\n      coord2: coord2\n    };\n  },\n  _checkLabelsOverlay: function (topLocation) {\n    var that = this;\n\n    var topCoords = that._topLabel.getBoundingRect();\n\n    var bottomCoords = that._bottomLabel.getBoundingRect();\n\n    var corrections = {};\n\n    if (!that._options.rotated) {\n      if (\"top\" === topLocation) {\n        if (this._checkOverlay(bottomCoords.y, topCoords.y, topCoords.height)) {\n          corrections = this._getOverlayCorrections(topCoords, bottomCoords);\n\n          that._topLabel.shift(topCoords.x, corrections.coord1);\n\n          that._bottomLabel.shift(bottomCoords.x, corrections.coord2);\n        }\n      } else {\n        if (this._checkOverlay(topCoords.y, bottomCoords.y, bottomCoords.height)) {\n          corrections = this._getOverlayCorrections(bottomCoords, topCoords);\n\n          that._topLabel.shift(topCoords.x, corrections.coord2);\n\n          that._bottomLabel.shift(bottomCoords.x, corrections.coord1);\n        }\n      }\n    } else {\n      if (\"top\" === topLocation) {\n        if (this._checkOverlay(topCoords.x, bottomCoords.x, bottomCoords.width)) {\n          corrections = this._getOverlayCorrections(bottomCoords, topCoords);\n\n          that._topLabel.shift(corrections.coord2, topCoords.y);\n\n          that._bottomLabel.shift(corrections.coord1, bottomCoords.y);\n        }\n      } else {\n        if (this._checkOverlay(bottomCoords.x, topCoords.x, topCoords.width)) {\n          corrections = this._getOverlayCorrections(topCoords, bottomCoords);\n\n          that._topLabel.shift(corrections.coord1, topCoords.y);\n\n          that._bottomLabel.shift(corrections.coord2, bottomCoords.y);\n        }\n      }\n    }\n  },\n  _drawLabel: function () {\n    var that = this;\n    var labels = [];\n    var notInverted = that._options.rotated ? that.x >= that.minX : that.y < that.minY;\n\n    var customVisibility = that._getCustomLabelVisibility();\n\n    var topLabel = that._topLabel;\n    var bottomLabel = that._bottomLabel;\n    topLabel.pointPosition = notInverted ? \"top\" : \"bottom\";\n    bottomLabel.pointPosition = notInverted ? \"bottom\" : \"top\";\n\n    if ((that.series.getLabelVisibility() || customVisibility) && that.hasValue() && false !== customVisibility) {\n      false !== that.visibleTopMarker && labels.push(topLabel);\n      false !== that.visibleBottomMarker && labels.push(bottomLabel);\n      each(labels, function (_, label) {\n        label.draw(true);\n      });\n\n      that._checkLabelsOverlay(that._topLabel.pointPosition);\n    } else {\n      topLabel.draw(false);\n      bottomLabel.draw(false);\n    }\n  },\n  _getImage: function (imageOption) {\n    var image = {};\n\n    if (_isDefined(imageOption)) {\n      if (\"string\" === typeof imageOption) {\n        image.top = image.bottom = imageOption;\n      } else {\n        image.top = {\n          url: \"string\" === typeof imageOption.url ? imageOption.url : imageOption.url && imageOption.url.rangeMaxPoint,\n          width: \"number\" === typeof imageOption.width ? imageOption.width : imageOption.width && imageOption.width.rangeMaxPoint,\n          height: \"number\" === typeof imageOption.height ? imageOption.height : imageOption.height && imageOption.height.rangeMaxPoint\n        };\n        image.bottom = {\n          url: \"string\" === typeof imageOption.url ? imageOption.url : imageOption.url && imageOption.url.rangeMinPoint,\n          width: \"number\" === typeof imageOption.width ? imageOption.width : imageOption.width && imageOption.width.rangeMinPoint,\n          height: \"number\" === typeof imageOption.height ? imageOption.height : imageOption.height && imageOption.height.rangeMinPoint\n        };\n      }\n    }\n\n    return image;\n  },\n  _checkSymbol: function (oldOptions, newOptions) {\n    var that = this;\n    var oldSymbol = oldOptions.symbol;\n    var newSymbol = newOptions.symbol;\n    var symbolChanged = \"circle\" === oldSymbol && \"circle\" !== newSymbol || \"circle\" !== oldSymbol && \"circle\" === newSymbol;\n\n    var oldImages = that._getImage(oldOptions.image);\n\n    var newImages = that._getImage(newOptions.image);\n\n    var topImageChanged = that._checkImage(oldImages.top) !== that._checkImage(newImages.top);\n\n    var bottomImageChanged = that._checkImage(oldImages.bottom) !== that._checkImage(newImages.bottom);\n\n    return symbolChanged || topImageChanged || bottomImageChanged;\n  },\n  _getSettingsForTwoMarkers: function (style) {\n    var that = this;\n    var options = that._options;\n    var settings = {};\n    var x = options.rotated ? _min(that.x, that.minX) : that.x;\n    var y = options.rotated ? that.y : _min(that.y, that.minY);\n    var radius = style.r;\n\n    var points = that._populatePointShape(options.symbol, radius);\n\n    settings.top = _extend({\n      translateX: x + that.width,\n      translateY: y,\n      r: radius\n    }, style);\n    settings.bottom = _extend({\n      translateX: x,\n      translateY: y + that.height,\n      r: radius\n    }, style);\n\n    if (points) {\n      settings.top.points = settings.bottom.points = points;\n    }\n\n    return settings;\n  },\n  _hasGraphic: function () {\n    return this.graphic && this.graphic.topMarker && this.graphic.bottomMarker;\n  },\n  _drawOneMarker: function (renderer, markerType, imageSettings, settings) {\n    var that = this;\n    var graphic = that.graphic;\n\n    if (graphic[markerType]) {\n      that._updateOneMarker(markerType, settings);\n    } else {\n      graphic[markerType] = that._createMarker(renderer, graphic, imageSettings, settings);\n    }\n  },\n  _drawMarker: function (renderer, group, animationEnabled, firstDrawing, style) {\n    var that = this;\n\n    var settings = that._getSettingsForTwoMarkers(style || that._getStyle());\n\n    var image = that._getImage(that._options.image);\n\n    if (that._checkImage(image.top)) {\n      settings.top = that._getImageSettings(settings.top, image.top);\n    }\n\n    if (that._checkImage(image.bottom)) {\n      settings.bottom = that._getImageSettings(settings.bottom, image.bottom);\n    }\n\n    that.graphic = that.graphic || renderer.g().append(group);\n    that.visibleTopMarker && that._drawOneMarker(renderer, \"topMarker\", image.top, settings.top);\n    that.visibleBottomMarker && that._drawOneMarker(renderer, \"bottomMarker\", image.bottom, settings.bottom);\n  },\n  _getSettingsForTracker: function (radius) {\n    var that = this;\n    var rotated = that._options.rotated;\n    return {\n      translateX: rotated ? _min(that.x, that.minX) - radius : that.x - radius,\n      translateY: rotated ? that.y - radius : _min(that.y, that.minY) - radius,\n      width: that.width + 2 * radius,\n      height: that.height + 2 * radius\n    };\n  },\n  isInVisibleArea: function () {\n    var that = this;\n    var rotated = that._options.rotated;\n    var argument = !rotated ? that.x : that.y;\n    var maxValue = !rotated ? _max(that.minY, that.y) : _max(that.minX, that.x);\n    var minValue = !rotated ? _min(that.minY, that.y) : _min(that.minX, that.x);\n    var notVisibleByArg;\n    var notVisibleByVal;\n    var tmp;\n    var visibleTopMarker = true;\n    var visibleBottomMarker = true;\n    var visibleRangeArea = true;\n    var visibleArgArea;\n    var visibleValArea;\n    visibleArgArea = that.series.getArgumentAxis().getVisibleArea();\n    visibleValArea = that.series.getValueAxis().getVisibleArea();\n    notVisibleByArg = visibleArgArea[1] < argument || visibleArgArea[0] > argument;\n    notVisibleByVal = visibleValArea[0] > minValue && visibleValArea[0] > maxValue || visibleValArea[1] < minValue && visibleValArea[1] < maxValue;\n\n    if (notVisibleByArg || notVisibleByVal) {\n      visibleTopMarker = visibleBottomMarker = visibleRangeArea = false;\n    } else {\n      visibleTopMarker = visibleValArea[0] <= minValue && visibleValArea[1] > minValue;\n      visibleBottomMarker = visibleValArea[0] < maxValue && visibleValArea[1] >= maxValue;\n\n      if (rotated) {\n        tmp = visibleTopMarker;\n        visibleTopMarker = visibleBottomMarker;\n        visibleBottomMarker = tmp;\n      }\n    }\n\n    that.visibleTopMarker = visibleTopMarker;\n    that.visibleBottomMarker = visibleBottomMarker;\n    return visibleRangeArea;\n  },\n  getTooltipParams: function () {\n    var that = this;\n    var x;\n    var y;\n    var rotated = that._options.rotated;\n    var minValue = !rotated ? _min(that.y, that.minY) : _min(that.x, that.minX);\n    var side = !rotated ? \"height\" : \"width\";\n\n    var visibleArea = that._getVisibleArea();\n\n    var minVisible = rotated ? visibleArea.minX : visibleArea.minY;\n    var maxVisible = rotated ? visibleArea.maxX : visibleArea.maxY;\n\n    var min = _max(minVisible, minValue);\n\n    var max = _min(maxVisible, minValue + that[side]);\n\n    if (!rotated) {\n      x = that.x;\n      y = min + (max - min) / 2;\n    } else {\n      y = that.y;\n      x = min + (max - min) / 2;\n    }\n\n    return {\n      x: x,\n      y: y,\n      offset: 0\n    };\n  },\n  _translate: function () {\n    var that = this;\n    var rotated = that._options.rotated;\n\n    symbolPoint._translate.call(that);\n\n    that.height = rotated ? 0 : _abs(that.minY - that.y);\n    that.width = rotated ? _abs(that.x - that.minX) : 0;\n  },\n  hasCoords: function () {\n    return symbolPoint.hasCoords.call(this) && !(null === this.minX || null === this.minY);\n  },\n  _updateData: function (data) {\n    var that = this;\n\n    symbolPoint._updateData.call(that, data);\n\n    that.minValue = that.initialMinValue = that.originalMinValue = data.minValue;\n  },\n  _getImageSettings: function (settings, image) {\n    return {\n      href: image.url || image.toString(),\n      width: image.width || DEFAULT_IMAGE_WIDTH,\n      height: image.height || DEFAULT_IMAGE_HEIGHT,\n      translateX: settings.translateX,\n      translateY: settings.translateY\n    };\n  },\n  getCrosshairData: function (x, y) {\n    var that = this;\n    var rotated = that._options.rotated;\n    var minX = that.minX;\n    var minY = that.minY;\n    var vx = that.vx;\n    var vy = that.vy;\n    var value = that.value;\n    var minValue = that.minValue;\n    var argument = that.argument;\n    var coords = {\n      axis: that.series.axis,\n      x: vx,\n      y: vy,\n      yValue: value,\n      xValue: argument\n    };\n\n    if (rotated) {\n      coords.yValue = argument;\n\n      if (_abs(vx - x) < _abs(minX - x)) {\n        coords.xValue = value;\n      } else {\n        coords.x = minX;\n        coords.xValue = minValue;\n      }\n    } else {\n      if (_abs(vy - y) >= _abs(minY - y)) {\n        coords.y = minY;\n        coords.yValue = minValue;\n      }\n    }\n\n    return coords;\n  },\n  _updateOneMarker: function (markerType, settings) {\n    this.graphic && this.graphic[markerType] && this.graphic[markerType].attr(settings);\n  },\n  _updateMarker: function (animationEnabled, style) {\n    this._drawMarker(void 0, void 0, false, false, style);\n  },\n  _getFormatObject: function (tooltip) {\n    var that = this;\n    var initialMinValue = that.initialMinValue;\n    var initialValue = that.initialValue;\n    var initialArgument = that.initialArgument;\n    var minValue = tooltip.formatValue(initialMinValue);\n    var value = tooltip.formatValue(initialValue);\n    return {\n      argument: initialArgument,\n      argumentText: tooltip.formatValue(initialArgument, \"argument\"),\n      valueText: minValue + \" - \" + value,\n      rangeValue1Text: minValue,\n      rangeValue2Text: value,\n      rangeValue1: initialMinValue,\n      rangeValue2: initialValue,\n      seriesName: that.series.name,\n      point: that,\n      originalMinValue: that.originalMinValue,\n      originalValue: that.originalValue,\n      originalArgument: that.originalArgument\n    };\n  },\n  getLabel: function () {\n    return [this._topLabel, this._bottomLabel];\n  },\n  getLabels: function () {\n    return [this._topLabel, this._bottomLabel];\n  },\n  getBoundingRect: noop,\n  coordsIn: function (x, y) {\n    var trackerRadius = this._storeTrackerR();\n\n    var xCond = x >= this.x - trackerRadius && x <= this.x + trackerRadius;\n    var yCond = y >= this.y - trackerRadius && y <= this.y + trackerRadius;\n\n    if (this._options.rotated) {\n      return yCond && (xCond || x >= this.minX - trackerRadius && x <= this.minX + trackerRadius);\n    } else {\n      return xCond && (yCond || y >= this.minY - trackerRadius && y <= this.minY + trackerRadius);\n    }\n  },\n  getMaxValue: function () {\n    if (\"discrete\" !== this.series.valueAxisType) {\n      return this.minValue > this.value ? this.minValue : this.value;\n    }\n\n    return this.value;\n  },\n  getMinValue: function () {\n    if (\"discrete\" !== this.series.valueAxisType) {\n      return this.minValue < this.value ? this.minValue : this.value;\n    }\n\n    return this.minValue;\n  }\n});","map":null,"metadata":{},"sourceType":"script"}