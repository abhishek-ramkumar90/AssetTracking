{"ast":null,"code":"/**\r\n * DevExtreme (viz/series/bar_series.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar extend = require(\"../../core/utils/extend\").extend;\n\nvar each = require(\"../../core/utils/iterator\").each;\n\nvar scatterSeries = require(\"./scatter_series\");\n\nvar areaSeries = require(\"./area_series\").chart.area;\n\nvar chartSeries = scatterSeries.chart;\nvar polarSeries = scatterSeries.polar;\nvar _extend = extend;\nvar _each = each;\nexports.chart = {};\nexports.polar = {};\nvar baseBarSeriesMethods = {\n  _createLegendState: function (styleOptions, defaultColor) {\n    return {\n      fill: styleOptions.color || defaultColor,\n      hatching: styleOptions.hatching\n    };\n  },\n  _parsePointStyle: function (style, defaultColor, defaultBorderColor) {\n    var color = style.color || defaultColor;\n\n    var base = chartSeries._parsePointStyle.call(this, style, color, defaultBorderColor);\n\n    base.fill = color;\n    base.hatching = style.hatching;\n    base.dashStyle = style.border && style.border.dashStyle || \"solid\";\n    delete base.r;\n    return base;\n  },\n  _applyMarkerClipRect: function (settings) {\n    settings[\"clip-path\"] = null;\n  },\n  _setGroupsSettings: function (animationEnabled, firstDrawing) {\n    var that = this;\n    var settings = {};\n\n    chartSeries._setGroupsSettings.apply(that, arguments);\n\n    if (animationEnabled && firstDrawing) {\n      settings = this._getAffineCoordOptions();\n    } else {\n      if (!animationEnabled) {\n        settings = {\n          scaleX: 1,\n          scaleY: 1,\n          translateX: 0,\n          translateY: 0\n        };\n      }\n    }\n\n    that._markersGroup.attr(settings);\n  },\n  _drawPoint: function (options) {\n    options.hasAnimation = options.hasAnimation && !options.firstDrawing;\n    options.firstDrawing = false;\n\n    chartSeries._drawPoint.call(this, options);\n  },\n  _getMainColor: function () {\n    return this._options.mainSeriesColor;\n  },\n  _createPointStyles: function (pointOptions) {\n    var that = this;\n\n    var mainColor = pointOptions.color || that._getMainColor();\n\n    return {\n      normal: that._parsePointStyle(pointOptions, mainColor, mainColor),\n      hover: that._parsePointStyle(pointOptions.hoverStyle || {}, mainColor, mainColor),\n      selection: that._parsePointStyle(pointOptions.selectionStyle || {}, mainColor, mainColor)\n    };\n  },\n  _updatePointsVisibility: function () {\n    var visibility = this._options.visible;\n    each(this._points, function (_, point) {\n      point._options.visible = visibility;\n    });\n  },\n  _getOptionsForPoint: function () {\n    return this._options;\n  },\n  _animate: function (firstDrawing) {\n    var that = this;\n\n    var complete = function () {\n      that._animateComplete();\n    };\n\n    var animateFunc = function (drawnPoints, complete) {\n      var lastPointIndex = drawnPoints.length - 1;\n\n      _each(drawnPoints || [], function (i, point) {\n        point.animate(i === lastPointIndex ? complete : void 0, point.getMarkerCoords());\n      });\n    };\n\n    that._animatePoints(firstDrawing, complete, animateFunc);\n  },\n  getValueRangeInitialValue: areaSeries.getValueRangeInitialValue,\n  _patchMarginOptions: function (options) {\n    options.checkInterval = true;\n    return options;\n  },\n  _defaultAggregator: \"sum\",\n  _defineDrawingState: function () {},\n  usePointsToDefineAutoHiding: function () {\n    return false;\n  }\n};\nexports.chart.bar = _extend({}, chartSeries, baseBarSeriesMethods, {\n  _getAffineCoordOptions: function () {\n    var rotated = this._options.rotated;\n    var direction = rotated ? \"X\" : \"Y\";\n    var settings = {\n      scaleX: rotated ? .001 : 1,\n      scaleY: rotated ? 1 : .001\n    };\n    settings[\"translate\" + direction] = this.getValueAxis().getTranslator().translate(\"canvas_position_default\");\n    return settings;\n  },\n  _animatePoints: function (firstDrawing, complete, animateFunc) {\n    var that = this;\n\n    that._markersGroup.animate({\n      scaleX: 1,\n      scaleY: 1,\n      translateY: 0,\n      translateX: 0\n    }, void 0, complete);\n\n    if (!firstDrawing) {\n      animateFunc(that._drawnPoints, complete);\n    }\n  },\n  checkSeriesViewportCoord: function (axis, coord) {\n    if (0 === this._points.length) {\n      return false;\n    }\n\n    if (axis.isArgumentAxis) {\n      return true;\n    }\n\n    var translator = axis.getTranslator();\n    var range = this.getViewport();\n    var min = translator.translate(range.categories ? range.categories[0] : range.min);\n    var max = translator.translate(range.categories ? range.categories[range.categories.length - 1] : range.max);\n    var rotated = this.getOptions().rotated;\n    var inverted = axis.getOptions().inverted;\n    return rotated && !inverted || !rotated && inverted ? coord >= min && coord <= max : coord >= max && coord <= min;\n  },\n  getSeriesPairCoord: function (coord, isArgument) {\n    var oppositeCoord = null;\n    var rotated = this._options.rotated;\n    var isOpposite = !isArgument && !rotated || isArgument && rotated;\n    var coordName = isOpposite ? \"vy\" : \"vx\";\n    var oppositeCoordName = isOpposite ? \"vx\" : \"vy\";\n    var points = this.getPoints();\n\n    for (var i = 0; i < points.length; i++) {\n      var p = points[i];\n      var tmpCoord = void 0;\n\n      if (isArgument) {\n        tmpCoord = p.getCenterCoord()[coordName[1]] === coord ? p[oppositeCoordName] : void 0;\n      } else {\n        tmpCoord = p[coordName] === coord ? p[oppositeCoordName] : void 0;\n      }\n\n      if (this.checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\n        oppositeCoord = tmpCoord;\n        break;\n      }\n    }\n\n    return oppositeCoord;\n  }\n});\nexports.polar.bar = _extend({}, polarSeries, baseBarSeriesMethods, {\n  _animatePoints: function (firstDrawing, complete, animateFunc) {\n    animateFunc(this._drawnPoints, complete);\n  },\n  _setGroupsSettings: chartSeries._setGroupsSettings,\n  _drawPoint: function (point, groups, animationEnabled) {\n    chartSeries._drawPoint.call(this, point, groups, animationEnabled);\n  },\n  _parsePointStyle: function (style) {\n    var base = baseBarSeriesMethods._parsePointStyle.apply(this, arguments);\n\n    base.opacity = style.opacity;\n    return base;\n  },\n  _createGroups: chartSeries._createGroups,\n  _setMarkerGroupSettings: function () {\n    var that = this;\n\n    var markersSettings = that._createPointStyles(that._getMarkerGroupOptions()).normal;\n\n    var groupSettings;\n    markersSettings.class = \"dxc-markers\";\n\n    that._applyMarkerClipRect(markersSettings);\n\n    groupSettings = _extend({}, markersSettings);\n    delete groupSettings.opacity;\n\n    that._markersGroup.attr(groupSettings);\n  },\n  _createLegendState: areaSeries._createLegendState\n});","map":null,"metadata":{},"sourceType":"script"}