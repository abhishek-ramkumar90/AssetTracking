{"ast":null,"code":"/**\r\n * DevExtreme (viz/core/plaque.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Plaque = void 0;\n\nvar _extend = require(\"../../core/utils/extend\");\n\nvar _type = require(\"../../core/utils/type\");\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n\n    if (\"value\" in descriptor) {\n      descriptor.writable = true;\n    }\n\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) {\n    _defineProperties(Constructor.prototype, protoProps);\n  }\n\n  if (staticProps) {\n    _defineProperties(Constructor, staticProps);\n  }\n\n  return Constructor;\n}\n\nvar math = Math;\nvar round = math.round;\nvar max = math.max;\nvar min = math.min;\nvar sin = math.sin;\nvar cos = math.cos;\nvar asin = math.asin;\nvar PI = math.PI;\n\nvar buildPath = function () {\n  for (var _len = arguments.length, points = new Array(_len), _key = 0; _key < _len; _key++) {\n    points[_key] = arguments[_key];\n  }\n\n  return points.join(\"\");\n};\n\nfunction getArc(cornerRadius, xDirection, yDirection) {\n  return \"a \".concat(cornerRadius, \" \").concat(cornerRadius, \" 0 0 1 \").concat(xDirection * cornerRadius, \" \").concat(yDirection * cornerRadius);\n}\n\nfunction getAbsoluteArc(cornerRadius, x, y) {\n  return \"A \".concat(cornerRadius, \" \").concat(cornerRadius, \" 0 0 1 \").concat(x, \" \").concat(y);\n}\n\nfunction rotateX(x, y, angle, x0, y0) {\n  return (x - x0) * round(cos(angle)) + (y - y0) * round(sin(angle)) + x0;\n}\n\nfunction rotateY(x, y, angle, x0, y0) {\n  return -(x - x0) * round(sin(angle)) + (y - y0) * round(cos(angle)) + y0;\n}\n\nfunction rotateSize(options, angle) {\n  if (angle % 90 === 0 && angle % 180 !== 0) {\n    return {\n      width: options.height,\n      height: options.width\n    };\n  }\n\n  return options;\n}\n\nfunction getCloudAngle(_ref, x, y, anchorX, anchorY) {\n  var width = _ref.width,\n      height = _ref.height;\n  var halfWidth = width / 2;\n  var halfHeight = height / 2;\n  var xr = Math.ceil(x + halfWidth);\n  var xl = Math.floor(x - halfWidth);\n  var yt = Math.floor(y - halfHeight);\n  var yb = Math.ceil(y + halfHeight);\n\n  if (anchorX < xl && anchorY < yt || anchorX >= xl && anchorX <= xr && anchorY < yt) {\n    return 270;\n  }\n\n  if (anchorX > xr && anchorY > yb || anchorX >= xl && anchorX <= xr && anchorY > yb) {\n    return 90;\n  } else {\n    if (anchorX < xl && anchorY > yb || anchorX < xl && anchorY >= yt && anchorY <= yb) {\n      return 180;\n    }\n  }\n\n  return 0;\n}\n\nfunction getCloudPoints(_ref2, x, y, anchorX, anchorY, _ref3, bounded) {\n  var width = _ref2.width,\n      height = _ref2.height;\n  var arrowWidth = _ref3.arrowWidth,\n      _ref3$cornerRadius = _ref3.cornerRadius,\n      cornerRadius = void 0 === _ref3$cornerRadius ? 0 : _ref3$cornerRadius;\n  var halfArrowWidth = arrowWidth / 2;\n  var halfWidth = width / 2;\n  var halfHeight = height / 2;\n  var xr = Math.ceil(x + halfWidth);\n  var xl = Math.floor(x - halfWidth);\n  var yt = Math.floor(y - halfHeight);\n  var yb = Math.ceil(y + halfHeight);\n  var leftTopCorner = [xl, yt];\n  var rightTopCorner = [xr, yt];\n  var rightBottomCorner = [xr, yb];\n  var leftBottomCorner = [xl, yb];\n  var arrowX = anchorX <= xl ? xl : xr <= anchorX ? xr : anchorX;\n  var arrowY = anchorY <= yt ? yt : yb <= anchorY ? yb : anchorY;\n  var arrowBaseBottom = min(arrowY + halfArrowWidth, yb);\n  var arrowBaseTop = max(arrowY - halfArrowWidth, yt);\n  var arrowBaseLeft = max(arrowX - halfArrowWidth, xl);\n  cornerRadius = Math.min(width / 2, height / 2, cornerRadius);\n  var points;\n  leftTopCorner[1] += cornerRadius;\n  rightTopCorner[0] -= cornerRadius;\n  rightBottomCorner[1] -= cornerRadius;\n  leftBottomCorner[0] += cornerRadius;\n\n  if (!bounded || xl <= anchorX && anchorX <= xr && yt <= anchorY && anchorY <= yb) {\n    points = buildPath(leftTopCorner, getArc(cornerRadius, 1, -1), \"L\", rightTopCorner, getArc(cornerRadius, 1, 1), \"L\", rightBottomCorner, getArc(cornerRadius, -1, 1), \"L\", leftBottomCorner, getArc(cornerRadius, -1, -1));\n  } else {\n    if (anchorX > xr && anchorY < yt) {\n      var arrowAngle = arrowWidth / cornerRadius || 0;\n      var angle = PI / 4 + arrowAngle / 2;\n      var endAngle = PI / 4 - arrowAngle / 2;\n      var arrowEndPointX = rightTopCorner[0] + cos(endAngle) * cornerRadius;\n      var arrowEndPointY = rightTopCorner[1] + (1 - sin(endAngle)) * cornerRadius;\n      var arrowArc = buildPath(\"L\", rightTopCorner, getArc(cornerRadius, cos(angle), 1 - sin(angle)), \"L\", [anchorX, anchorY, arrowEndPointX, arrowEndPointY], getAbsoluteArc(cornerRadius, rightTopCorner[0] + cornerRadius, rightTopCorner[1] + cornerRadius));\n\n      if (Math.abs(angle) > PI / 2) {\n        arrowArc = buildPath(\"L\", [arrowBaseLeft, yt, anchorX, anchorY, xr, arrowBaseBottom]);\n      }\n\n      points = buildPath(leftTopCorner, getArc(cornerRadius, 1, -1), arrowArc, \"L\", rightBottomCorner, getArc(cornerRadius, -1, 1), \"L\", leftBottomCorner, getArc(cornerRadius, -1, -1));\n    } else {\n      if (anchorX > xr && anchorY >= yt && anchorY <= yb) {\n        var _arrowArc;\n\n        if (arrowBaseTop >= rightTopCorner[1] + cornerRadius && arrowBaseBottom <= rightBottomCorner[1]) {\n          _arrowArc = buildPath(getArc(cornerRadius, 1, 1), \"L\", [xr, arrowBaseTop, anchorX, anchorY, xr, arrowBaseBottom], \"L\", rightBottomCorner, getArc(cornerRadius, -1, 1));\n        } else {\n          if (arrowBaseTop < rightTopCorner[1] + cornerRadius && arrowBaseBottom >= rightTopCorner[1] + cornerRadius && arrowBaseBottom <= rightBottomCorner[1]) {\n            var arrowWidthRest = rightTopCorner[1] + cornerRadius - arrowBaseTop;\n\n            var _angle = arrowWidthRest / cornerRadius;\n\n            var arrowBaseTopX = rightTopCorner[0] + cos(_angle) * cornerRadius;\n            var arrowBaseTopY = rightTopCorner[1] + (1 - sin(_angle)) * cornerRadius;\n            _arrowArc = buildPath(getArc(cornerRadius, cos(_angle), 1 - sin(_angle)), \"L\", [arrowBaseTopX, arrowBaseTopY, anchorX, anchorY, xr, arrowBaseBottom], \"L\", rightBottomCorner, getArc(cornerRadius, -1, 1));\n          } else {\n            if (arrowBaseTop < rightTopCorner[1] + cornerRadius && arrowBaseBottom < rightTopCorner[1] + cornerRadius) {\n              var _arrowWidthRest = rightTopCorner[1] + cornerRadius - arrowBaseTop;\n\n              var _arrowAngle = _arrowWidthRest / cornerRadius;\n\n              var _angle2 = _arrowAngle;\n\n              var _arrowBaseTopX = rightTopCorner[0] + cos(_angle2) * cornerRadius;\n\n              var _arrowBaseTopY = rightTopCorner[1] + (1 - sin(_angle2)) * cornerRadius;\n\n              var bottomAngle = Math.sin((rightTopCorner[1] + cornerRadius - arrowBaseBottom) / cornerRadius);\n              var arrowBaseBottomX = rightTopCorner[0] + cornerRadius * cos(bottomAngle);\n              var arrowBaseBottomY = rightTopCorner[1] + cornerRadius * (1 - sin(bottomAngle));\n              _arrowArc = buildPath(getArc(cornerRadius, cos(_angle2), 1 - sin(_angle2)), \"L\", [_arrowBaseTopX, _arrowBaseTopY, anchorX, anchorY, arrowBaseBottomX, arrowBaseBottomY], getAbsoluteArc(cornerRadius, rightTopCorner[0] + cornerRadius, rightTopCorner[1] + cornerRadius), \"L\", rightBottomCorner, getArc(cornerRadius, -1, 1));\n            } else {\n              if (arrowBaseTop <= rightTopCorner[1] + cornerRadius && arrowBaseBottom >= rightBottomCorner[1]) {\n                var topAngle = asin((rightTopCorner[1] + cornerRadius - arrowBaseTop) / cornerRadius);\n\n                var _arrowBaseTopX2 = rightTopCorner[0] + cornerRadius * cos(topAngle);\n\n                var _arrowBaseTopY2 = rightTopCorner[1] + cornerRadius * (1 - sin(topAngle));\n\n                var _bottomAngle = asin((arrowBaseBottom - rightBottomCorner[1]) / cornerRadius);\n\n                var _arrowBaseBottomX = rightBottomCorner[0] + cornerRadius * (cos(_bottomAngle) - 1);\n\n                var _arrowBaseBottomY = rightBottomCorner[1] + cornerRadius * sin(_bottomAngle);\n\n                _arrowArc = buildPath(getArc(cornerRadius, cos(topAngle), 1 - sin(topAngle)), \"L\", [_arrowBaseTopX2, _arrowBaseTopY2, anchorX, anchorY, _arrowBaseBottomX, _arrowBaseBottomY], getAbsoluteArc(cornerRadius, rightBottomCorner[0] - cornerRadius, rightBottomCorner[1] + cornerRadius));\n              } else {\n                if (arrowBaseTop > rightTopCorner[1] + cornerRadius && arrowBaseTop <= rightBottomCorner[1] && arrowBaseBottom > rightBottomCorner[1]) {\n                  var _bottomAngle2 = asin((arrowBaseBottom - rightBottomCorner[1]) / cornerRadius);\n\n                  var _arrowBaseBottomX2 = rightBottomCorner[0] + cornerRadius * (cos(_bottomAngle2) - 1);\n\n                  var _arrowBaseBottomY2 = rightBottomCorner[1] + cornerRadius * sin(_bottomAngle2);\n\n                  _arrowArc = buildPath(getArc(cornerRadius, 1, 1), \"L\", [xr, arrowBaseTop, anchorX, anchorY, _arrowBaseBottomX2, _arrowBaseBottomY2], getAbsoluteArc(cornerRadius, rightBottomCorner[0] - cornerRadius, rightBottomCorner[1] + cornerRadius));\n                } else {\n                  if (arrowBaseTop > rightTopCorner[1] + cornerRadius && arrowBaseBottom > rightBottomCorner[1]) {\n                    var _bottomAngle3 = asin((arrowBaseBottom - rightBottomCorner[1]) / cornerRadius);\n\n                    var _arrowBaseBottomX3 = rightBottomCorner[0] + cornerRadius * (cos(_bottomAngle3) - 1);\n\n                    var _arrowBaseBottomY3 = rightBottomCorner[1] + cornerRadius * sin(_bottomAngle3);\n\n                    var _topAngle = asin((arrowBaseTop - rightBottomCorner[1]) / cornerRadius);\n\n                    var _arrowBaseTopX3 = rightBottomCorner[0] + cornerRadius * (cos(_topAngle) - 1);\n\n                    var _arrowBaseTopY3 = rightBottomCorner[1] + cornerRadius * sin(_topAngle);\n\n                    _arrowArc = buildPath(getArc(cornerRadius, 1, 1), \"L\", rightBottomCorner, getArc(cornerRadius, cos(_topAngle) - 1, sin(_topAngle)), \"L\", [_arrowBaseTopX3, _arrowBaseTopY3, anchorX, anchorY, _arrowBaseBottomX3, _arrowBaseBottomY3], getAbsoluteArc(cornerRadius, rightBottomCorner[0] - cornerRadius, rightBottomCorner[1] + cornerRadius));\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        points = buildPath(leftTopCorner, getArc(cornerRadius, 1, -1), \"L\", rightTopCorner, _arrowArc, \"L\", leftBottomCorner, getArc(cornerRadius, -1, -1));\n      }\n    }\n  }\n\n  return buildPath(\"M\", points, \"Z\");\n}\n\nvar Plaque = exports.Plaque = function () {\n  function Plaque(options, widget, root, contentTemplate) {\n    var bounded = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : true;\n    var measureContent = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : function (_, g) {\n      return g.getBBox();\n    };\n    var moveContentGroup = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : function (_, g, x, y) {\n      return g.move(x, y);\n    };\n\n    _classCallCheck(this, Plaque);\n\n    this.widget = widget;\n    this.options = options;\n    this.root = root;\n    this.contentTemplate = contentTemplate;\n    this.bonded = bounded;\n    this.measureContent = measureContent;\n    this.moveContentGroup = moveContentGroup;\n  }\n\n  _createClass(Plaque, [{\n    key: \"draw\",\n    value: function (_ref4) {\n      var _this = this;\n\n      var anchorX = _ref4.x,\n          anchorY = _ref4.y,\n          _ref4$canvas = _ref4.canvas,\n          canvas = void 0 === _ref4$canvas ? {} : _ref4$canvas,\n          offsetX = _ref4.offsetX,\n          offsetY = _ref4.offsetY,\n          _ref4$offset = _ref4.offset,\n          offset = void 0 === _ref4$offset ? 0 : _ref4$offset;\n      var options = this.options;\n      var x = options.x,\n          y = options.y;\n      var bounds = {\n        xl: canvas.left,\n        xr: canvas.width - canvas.right,\n        width: canvas.width - canvas.right - canvas.left,\n        yt: canvas.top,\n        yb: canvas.height - canvas.bottom,\n        height: canvas.height - canvas.bottom - canvas.top\n      };\n\n      if (!((0, _type.isDefined)(anchorX) && (0, _type.isDefined)(anchorY)) && !((0, _type.isDefined)(x) && (0, _type.isDefined)(y))) {\n        return;\n      }\n\n      if ((0, _type.isDefined)(anchorX) && (anchorX < bounds.xl || bounds.xr < anchorX || anchorY < bounds.yt || bounds.yb < anchorY)) {\n        return;\n      }\n\n      if (!this._root) {\n        this._draw();\n      }\n\n      var shadowSettings = (0, _extend.extend)({\n        x: \"-50%\",\n        y: \"-50%\",\n        width: \"200%\",\n        height: \"200%\"\n      }, options.shadow);\n      var contentWidth = options.width > 0 ? options.width : null;\n      var contentHeight = options.height > 0 ? options.height : null;\n\n      var onRender = function () {\n        var bBox = _this._contentBBox = _this.measureContent(_this.widget, _this._contentGroup);\n\n        var size = _this._size = {\n          width: max(contentWidth, bBox.width) + 2 * options.paddingLeftRight,\n          height: max(contentHeight, bBox.height) + 2 * options.paddingTopBottom,\n          offset: offset\n        };\n        var xOff = shadowSettings.offsetX;\n        var yOff = shadowSettings.offsetY;\n        var blur = 2 * shadowSettings.blur + 1;\n        var lm = max(blur - xOff, 0);\n        var rm = max(blur + xOff, 0);\n        var tm = max(blur - yOff, 0);\n        var bm = max(blur + yOff, 0);\n        _this.margins = {\n          lm: lm,\n          rm: rm,\n          tm: tm,\n          bm: bm\n        };\n\n        if (!(0, _type.isDefined)(x)) {\n          if ((0, _type.isDefined)(offsetX)) {\n            x = anchorX + offsetX;\n          } else {\n            if (bounds.width < size.width) {\n              x = round(bounds.xl + bounds.width / 2);\n            } else {\n              x = min(max(anchorX, Math.ceil(bounds.xl + size.width / 2 + lm)), Math.floor(bounds.xr - size.width / 2 - rm));\n            }\n          }\n        } else {\n          x += offsetX || 0;\n\n          if (!(0, _type.isDefined)(anchorX)) {\n            anchorX = x;\n          }\n        }\n\n        if (!(0, _type.isDefined)(y)) {\n          if ((0, _type.isDefined)(offsetY)) {\n            y = anchorY + offsetY;\n          } else {\n            var y_top = anchorY - options.arrowLength - size.height / 2 - offset;\n            var y_bottom = anchorY + options.arrowLength + size.height / 2 + offset;\n\n            if (bounds.height < size.height + options.arrowLength) {\n              y = round(bounds.yt + size.height / 2);\n            } else {\n              if (y_top - size.height / 2 - tm < bounds.yt) {\n                if (y_bottom + size.height / 2 + bm < bounds.yb) {\n                  y = y_bottom;\n                  anchorY += offset;\n                } else {\n                  y = round(bounds.yt + size.height / 2);\n                }\n              } else {\n                y = y_top;\n                anchorY -= offset;\n              }\n            }\n          }\n        } else {\n          y += offsetY || 0;\n\n          if (!(0, _type.isDefined)(anchorY)) {\n            anchorY = y + size.height / 2;\n          }\n        }\n\n        _this.anchorX = anchorX;\n        _this.anchorY = anchorY;\n\n        _this.move(x, y);\n      };\n\n      if (this.contentTemplate.render) {\n        this.contentTemplate.render({\n          model: options,\n          container: this._contentGroup.element,\n          onRendered: onRender\n        });\n      } else {\n        this.contentTemplate(this.widget, this._contentGroup);\n        onRender();\n      }\n    }\n  }, {\n    key: \"_draw\",\n    value: function () {\n      var renderer = this.widget._renderer;\n      var options = this.options;\n      var cloudSettings = {\n        opacity: options.opacity,\n        \"stroke-width\": 0,\n        fill: options.color\n      };\n      var borderOptions = options.border || {};\n\n      if (borderOptions.visible) {\n        (0, _extend.extend)(cloudSettings, {\n          \"stroke-width\": borderOptions.width,\n          stroke: borderOptions.color,\n          \"stroke-opacity\": borderOptions.opacity,\n          dashStyle: borderOptions.dashStyle\n        });\n      }\n\n      var shadowSettings = (0, _extend.extend)({\n        x: \"-50%\",\n        y: \"-50%\",\n        width: \"200%\",\n        height: \"200%\"\n      }, options.shadow);\n      var shadow = this._shadow = renderer.shadowFilter().attr(shadowSettings);\n      var group = this._root = renderer.g().append(this.root);\n\n      if (options.type) {\n        group.attr({\n          \"class\": \"dxc-\".concat(options.type, \"-annotation\")\n        });\n      }\n\n      var cloudGroup = renderer.g().attr({\n        filter: shadow.id\n      }).append(group);\n      this._cloud = renderer.path([], \"area\").attr(cloudSettings).sharp().append(cloudGroup);\n      this._contentGroup = renderer.g().append(group);\n    }\n  }, {\n    key: \"getBBox\",\n    value: function () {\n      var size = this._size || {};\n      var margins = this.margins || {};\n      var rotationAngle = getCloudAngle(size, this.x, this.y, this.anchorX, this.anchorY);\n      return {\n        x: Math.floor(this.x - size.width / 2 - margins.lm),\n        y: Math.floor(this.y - size.height / 2 - margins.tm - (270 === rotationAngle ? this.options.arrowLength : 0)),\n        width: size.width + margins.lm + margins.rm,\n        height: size.height + margins.tm + margins.bm + (90 === rotationAngle || 270 === rotationAngle ? this.options.arrowLength : 0)\n      };\n    }\n  }, {\n    key: \"clear\",\n    value: function () {\n      if (this._root) {\n        this._root.remove();\n\n        this._shadow.remove();\n\n        this._root = null;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"customizeCloud\",\n    value: function (attr) {\n      if (this._cloud) {\n        this._cloud.attr(attr);\n      }\n    }\n  }, {\n    key: \"moveRoot\",\n    value: function (x, y) {\n      if (this._root) {\n        this._root.move(x, y);\n      }\n    }\n  }, {\n    key: \"move\",\n    value: function (x, y) {\n      x = round(x);\n      y = round(y);\n      this.x = x;\n      this.y = y;\n      var rotationAngle = getCloudAngle(this._size, x, y, this.anchorX, this.anchorY);\n      var radRotationAngle = rotationAngle * PI / 180;\n\n      this._cloud.attr({\n        d: getCloudPoints(rotateSize(this._size, rotationAngle), x, y, rotateX(this.anchorX, this.anchorY, radRotationAngle, x, y), rotateY(this.anchorX, this.anchorY, radRotationAngle, x, y), this.options, this.bonded)\n      }).rotate(rotationAngle, x, y);\n\n      this.moveContentGroup(this.widget, this._contentGroup, x - this._contentBBox.x - this._contentBBox.width / 2, y - this._contentBBox.y - this._contentBBox.height / 2);\n    }\n  }, {\n    key: \"hitTest\",\n    value: function (x, y) {\n      var _ref5 = this._size || {},\n          width = _ref5.width,\n          height = _ref5.height;\n\n      return Math.abs(x - this.x) <= width / 2 && Math.abs(y - this.y) <= height / 2;\n    }\n  }]);\n\n  return Plaque;\n}();","map":null,"metadata":{},"sourceType":"script"}