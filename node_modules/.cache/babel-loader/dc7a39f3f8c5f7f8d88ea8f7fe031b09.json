{"ast":null,"code":"/**\r\n * DevExtreme (core/utils/array.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar isDefined = require(\"./type\").isDefined;\n\nvar each = require(\"./iterator\").each;\n\nvar objectUtils = require(\"./object\");\n\nvar config = require(\"../config\");\n\nvar isEmpty = function (entity) {\n  return Array.isArray(entity) && !entity.length;\n};\n\nvar wrapToArray = function (entity) {\n  return Array.isArray(entity) ? entity : [entity];\n};\n\nvar intersection = function (a, b) {\n  if (!Array.isArray(a) || 0 === a.length || !Array.isArray(b) || 0 === b.length) {\n    return [];\n  }\n\n  var result = [];\n  each(a, function (_, value) {\n    var index = inArray(value, b);\n\n    if (index !== -1) {\n      result.push(value);\n    }\n  });\n  return result;\n};\n\nvar removeDuplicates = function (from, what) {\n  if (!Array.isArray(from) || 0 === from.length) {\n    return [];\n  }\n\n  if (!Array.isArray(what) || 0 === what.length) {\n    return from.slice();\n  }\n\n  var result = [];\n  each(from, function (_, value) {\n    var index = inArray(value, what);\n\n    if (index === -1) {\n      result.push(value);\n    }\n  });\n  return result;\n};\n\nvar normalizeIndexes = function (items, indexParameterName, currentItem, needIndexCallback) {\n  var indexedItems = {};\n  var parameterIndex = 0;\n  var useLegacyVisibleIndex = config().useLegacyVisibleIndex;\n  each(items, function (index, item) {\n    index = item[indexParameterName];\n\n    if (index >= 0) {\n      indexedItems[index] = indexedItems[index] || [];\n\n      if (item === currentItem) {\n        indexedItems[index].unshift(item);\n      } else {\n        indexedItems[index].push(item);\n      }\n    } else {\n      item[indexParameterName] = void 0;\n    }\n  });\n\n  if (!useLegacyVisibleIndex) {\n    each(items, function () {\n      if (!isDefined(this[indexParameterName]) && (!needIndexCallback || needIndexCallback(this))) {\n        while (indexedItems[parameterIndex]) {\n          parameterIndex++;\n        }\n\n        indexedItems[parameterIndex] = [this];\n        parameterIndex++;\n      }\n    });\n  }\n\n  parameterIndex = 0;\n  objectUtils.orderEach(indexedItems, function (index, items) {\n    each(items, function () {\n      if (index >= 0) {\n        this[indexParameterName] = parameterIndex++;\n      }\n    });\n  });\n\n  if (useLegacyVisibleIndex) {\n    each(items, function () {\n      if (!isDefined(this[indexParameterName]) && (!needIndexCallback || needIndexCallback(this))) {\n        this[indexParameterName] = parameterIndex++;\n      }\n    });\n  }\n\n  return parameterIndex;\n};\n\nvar inArray = function (value, object) {\n  if (!object) {\n    return -1;\n  }\n\n  var array = Array.isArray(object) ? object : object.toArray();\n  return array.indexOf(value);\n};\n\nvar merge = function (array1, array2) {\n  for (var i = 0; i < array2.length; i++) {\n    array1[array1.length] = array2[i];\n  }\n\n  return array1;\n};\n\nvar find = function (array, condition) {\n  for (var i = 0; i < array.length; i++) {\n    if (condition(array[i])) {\n      return array[i];\n    }\n  }\n};\n\nexports.isEmpty = isEmpty;\nexports.wrapToArray = wrapToArray;\nexports.intersection = intersection;\nexports.removeDuplicates = removeDuplicates;\nexports.normalizeIndexes = normalizeIndexes;\nexports.inArray = inArray;\nexports.merge = merge;\nexports.find = find;","map":null,"metadata":{},"sourceType":"script"}