{"ast":null,"code":"/**\r\n * DevExtreme (localization/ldml/date.formatter.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nfunction leftPad(text, length) {\n  while (text.length < length) {\n    text = \"0\" + text;\n  }\n\n  return text;\n}\n\nvar FORMAT_TYPES = {\n  3: \"abbreviated\",\n  4: \"wide\",\n  5: \"narrow\"\n};\nvar LDML_FORMATTERS = {\n  y: function (date, count, useUtc) {\n    var year = date[useUtc ? \"getUTCFullYear\" : \"getFullYear\"]();\n\n    if (2 === count) {\n      year %= 100;\n    }\n\n    return leftPad(year.toString(), count);\n  },\n  M: function (date, count, useUtc, dateParts) {\n    var month = date[useUtc ? \"getUTCMonth\" : \"getMonth\"]();\n    var formatType = FORMAT_TYPES[count];\n\n    if (formatType) {\n      return dateParts.getMonthNames(formatType, \"format\")[month];\n    }\n\n    return leftPad((month + 1).toString(), Math.min(count, 2));\n  },\n  L: function (date, count, useUtc, dateParts) {\n    var month = date[useUtc ? \"getUTCMonth\" : \"getMonth\"]();\n    var formatType = FORMAT_TYPES[count];\n\n    if (formatType) {\n      return dateParts.getMonthNames(formatType, \"standalone\")[month];\n    }\n\n    return leftPad((month + 1).toString(), Math.min(count, 2));\n  },\n  Q: function (date, count, useUtc, dateParts) {\n    var month = date[useUtc ? \"getUTCMonth\" : \"getMonth\"]();\n    var quarter = Math.floor(month / 3);\n    var formatType = FORMAT_TYPES[count];\n\n    if (formatType) {\n      return dateParts.getQuarterNames(formatType)[quarter];\n    }\n\n    return leftPad((quarter + 1).toString(), Math.min(count, 2));\n  },\n  E: function (date, count, useUtc, dateParts) {\n    var day = date[useUtc ? \"getUTCDay\" : \"getDay\"]();\n    var formatType = FORMAT_TYPES[count < 3 ? 3 : count];\n    return dateParts.getDayNames(formatType)[day];\n  },\n  a: function (date, count, useUtc, dateParts) {\n    var hours = date[useUtc ? \"getUTCHours\" : \"getHours\"]();\n    var period = hours < 12 ? 0 : 1;\n    var formatType = FORMAT_TYPES[count];\n    return dateParts.getPeriodNames(formatType)[period];\n  },\n  d: function (date, count, useUtc) {\n    return leftPad(date[useUtc ? \"getUTCDate\" : \"getDate\"]().toString(), Math.min(count, 2));\n  },\n  H: function (date, count, useUtc) {\n    return leftPad(date[useUtc ? \"getUTCHours\" : \"getHours\"]().toString(), Math.min(count, 2));\n  },\n  h: function (date, count, useUtc) {\n    var hours = date[useUtc ? \"getUTCHours\" : \"getHours\"]();\n    return leftPad((hours % 12 || 12).toString(), Math.min(count, 2));\n  },\n  m: function (date, count, useUtc) {\n    return leftPad(date[useUtc ? \"getUTCMinutes\" : \"getMinutes\"]().toString(), Math.min(count, 2));\n  },\n  s: function (date, count, useUtc) {\n    return leftPad(date[useUtc ? \"getUTCSeconds\" : \"getSeconds\"]().toString(), Math.min(count, 2));\n  },\n  S: function (date, count, useUtc) {\n    return leftPad(date[useUtc ? \"getUTCMilliseconds\" : \"getMilliseconds\"]().toString(), 3).substr(0, count);\n  },\n  x: function (date, count, useUtc) {\n    var timezoneOffset = useUtc ? 0 : date.getTimezoneOffset();\n    var signPart = timezoneOffset > 0 ? \"-\" : \"+\";\n    var timezoneOffsetAbs = Math.abs(timezoneOffset);\n    var hours = Math.floor(timezoneOffsetAbs / 60);\n    var minutes = timezoneOffsetAbs % 60;\n    var hoursPart = leftPad(hours.toString(), 2);\n    var minutesPart = leftPad(minutes.toString(), 2);\n    return signPart + hoursPart + (count >= 3 ? \":\" : \"\") + (count > 1 || minutes ? minutesPart : \"\");\n  },\n  X: function (date, count, useUtc) {\n    if (useUtc || !date.getTimezoneOffset()) {\n      return \"Z\";\n    }\n\n    return LDML_FORMATTERS.x(date, count, useUtc);\n  },\n  Z: function (date, count, useUtc) {\n    return LDML_FORMATTERS.X(date, count >= 5 ? 3 : 2, useUtc);\n  }\n};\n\nvar getFormatter = function (format, dateParts) {\n  return function (date) {\n    var charIndex;\n    var formatter;\n    var char;\n    var charCount = 0;\n    var separator = \"'\";\n    var isEscaping = false;\n    var isCurrentCharEqualsNext;\n    var result = \"\";\n\n    if (!date) {\n      return null;\n    }\n\n    if (!format) {\n      return date;\n    }\n\n    var useUtc = \"Z\" === format[format.length - 1] || \"'Z'\" === format.slice(-3);\n\n    for (charIndex = 0; charIndex < format.length; charIndex++) {\n      char = format[charIndex];\n      formatter = LDML_FORMATTERS[char];\n      isCurrentCharEqualsNext = char === format[charIndex + 1];\n      charCount++;\n\n      if (!isCurrentCharEqualsNext) {\n        if (formatter && !isEscaping) {\n          result += formatter(date, charCount, useUtc, dateParts);\n        }\n\n        charCount = 0;\n      }\n\n      if (char === separator && !isCurrentCharEqualsNext) {\n        isEscaping = !isEscaping;\n      } else {\n        if (isEscaping || !formatter) {\n          result += char;\n        }\n      }\n\n      if (char === separator && isCurrentCharEqualsNext) {\n        charIndex++;\n      }\n    }\n\n    return result;\n  };\n};\n\nmodule.exports.getFormatter = getFormatter;","map":null,"metadata":{},"sourceType":"script"}