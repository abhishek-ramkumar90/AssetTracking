{"ast":null,"code":"/**\r\n * DevExtreme (viz/series/line_series.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar series = require(\"./scatter_series\");\n\nvar chartScatterSeries = series.chart;\nvar polarScatterSeries = series.polar;\n\nvar objectUtils = require(\"../../core/utils/object\");\n\nvar extend = require(\"../../core/utils/extend\").extend;\n\nvar each = require(\"../../core/utils/iterator\").each;\n\nvar vizUtils = require(\"../core/utils\");\n\nvar mathUtils = require(\"../../core/utils/math\");\n\nvar normalizeAngle = vizUtils.normalizeAngle;\nvar DISCRETE = \"discrete\";\nvar _map = vizUtils.map;\nvar _extend = extend;\nvar _each = each;\nexports.chart = {};\nexports.polar = {};\n\nfunction clonePoint(point, newX, newY, newAngle) {\n  var p = objectUtils.clone(point);\n  p.x = newX;\n  p.y = newY;\n  p.angle = newAngle;\n  return p;\n}\n\nfunction getTangentPoint(point, prevPoint, centerPoint, tan, nextStepAngle) {\n  var correctAngle = point.angle + nextStepAngle;\n  var cosSin = vizUtils.getCosAndSin(correctAngle);\n  var x = centerPoint.x + (point.radius + tan * nextStepAngle) * cosSin.cos;\n  var y = centerPoint.y - (point.radius + tan * nextStepAngle) * cosSin.sin;\n  return clonePoint(prevPoint, x, y, correctAngle);\n}\n\nfunction obtainCubicBezierTCoef(p, p0, p1, p2, p3) {\n  var d = p0 - p;\n  var c = 3 * p1 - 3 * p0;\n  var b = 3 * p2 - 6 * p1 + 3 * p0;\n  var a = p3 - 3 * p2 + 3 * p1 - p0;\n  return mathUtils.solveCubicEquation(a, b, c, d);\n}\n\nvar lineMethods = {\n  autoHidePointMarkersEnabled: function () {\n    return true;\n  },\n  _applyGroupSettings: function (style, settings, group) {\n    var that = this;\n    settings = _extend(settings, style);\n\n    that._applyElementsClipRect(settings);\n\n    group.attr(settings);\n  },\n  _setGroupsSettings: function (animationEnabled) {\n    var that = this;\n    var style = that._styles.normal;\n\n    that._applyGroupSettings(style.elements, {\n      \"class\": \"dxc-elements\"\n    }, that._elementsGroup);\n\n    that._bordersGroup && that._applyGroupSettings(style.border, {\n      \"class\": \"dxc-borders\"\n    }, that._bordersGroup);\n\n    chartScatterSeries._setGroupsSettings.call(that, animationEnabled);\n\n    animationEnabled && that._markersGroup && that._markersGroup.attr({\n      opacity: .001\n    });\n  },\n  _createGroups: function () {\n    var that = this;\n\n    that._createGroup(\"_elementsGroup\", that, that._group);\n\n    that._areBordersVisible() && that._createGroup(\"_bordersGroup\", that, that._group);\n\n    chartScatterSeries._createGroups.call(that);\n  },\n  _areBordersVisible: function () {\n    return false;\n  },\n  _getDefaultSegment: function (segment) {\n    return {\n      line: _map(segment.line || [], function (pt) {\n        return pt.getDefaultCoords();\n      })\n    };\n  },\n  _prepareSegment: function (points) {\n    return {\n      line: points\n    };\n  },\n  _parseLineOptions: function (options, defaultColor) {\n    return {\n      stroke: options.color || defaultColor,\n      \"stroke-width\": options.width,\n      dashStyle: options.dashStyle || \"solid\"\n    };\n  },\n  _parseStyle: function (options, defaultColor) {\n    return {\n      elements: this._parseLineOptions(options, defaultColor)\n    };\n  },\n  _applyStyle: function (style) {\n    var that = this;\n    that._elementsGroup && that._elementsGroup.attr(style.elements);\n\n    _each(that._graphics || [], function (_, graphic) {\n      graphic.line && graphic.line.attr({\n        \"stroke-width\": style.elements[\"stroke-width\"]\n      }).sharp();\n    });\n  },\n  _drawElement: function (segment, group) {\n    return {\n      line: this._createMainElement(segment.line, {\n        \"stroke-width\": this._styles.normal.elements[\"stroke-width\"]\n      }).append(group)\n    };\n  },\n  _removeElement: function (element) {\n    element.line.remove();\n  },\n  _updateElement: function (element, segment, animate, animationComplete) {\n    var params = {\n      points: segment.line\n    };\n    var lineElement = element.line;\n    animate ? lineElement.animate(params, {}, animationComplete) : lineElement.attr(params);\n  },\n  _animateComplete: function () {\n    var that = this;\n\n    chartScatterSeries._animateComplete.call(that);\n\n    that._markersGroup && that._markersGroup.animate({\n      opacity: 1\n    }, {\n      duration: that._defaultDuration\n    });\n  },\n  _animate: function () {\n    var that = this;\n    var lastIndex = that._graphics.length - 1;\n\n    _each(that._graphics || [], function (i, elem) {\n      var complete;\n\n      if (i === lastIndex) {\n        complete = function () {\n          that._animateComplete();\n        };\n      }\n\n      that._updateElement(elem, that._segments[i], true, complete);\n    });\n  },\n  _drawPoint: function (options) {\n    chartScatterSeries._drawPoint.call(this, {\n      point: options.point,\n      groups: options.groups\n    });\n  },\n  _createMainElement: function (points, settings) {\n    return this._renderer.path(points, \"line\").attr(settings);\n  },\n  _sortPoints: function (points, rotated) {\n    return rotated ? points.sort(function (p1, p2) {\n      return p2.y - p1.y;\n    }) : points.sort(function (p1, p2) {\n      return p1.x - p2.x;\n    });\n  },\n  _drawSegment: function (points, animationEnabled, segmentCount, lastSegment) {\n    var that = this;\n    var rotated = that._options.rotated;\n    var forceDefaultSegment = false;\n\n    var segment = that._prepareSegment(points, rotated, lastSegment);\n\n    that._segments.push(segment);\n\n    if (!that._graphics[segmentCount]) {\n      that._graphics[segmentCount] = that._drawElement(animationEnabled ? that._getDefaultSegment(segment) : segment, that._elementsGroup);\n    } else {\n      if (!animationEnabled) {\n        that._updateElement(that._graphics[segmentCount], segment);\n      } else {\n        if (forceDefaultSegment) {\n          that._updateElement(that._graphics[segmentCount], that._getDefaultSegment(segment));\n        }\n      }\n    }\n  },\n  _getTrackerSettings: function () {\n    var that = this;\n    var defaultTrackerWidth = that._defaultTrackerWidth;\n    var strokeWidthFromElements = that._styles.normal.elements[\"stroke-width\"];\n    return {\n      \"stroke-width\": strokeWidthFromElements > defaultTrackerWidth ? strokeWidthFromElements : defaultTrackerWidth,\n      fill: \"none\"\n    };\n  },\n  _getMainPointsFromSegment: function (segment) {\n    return segment.line;\n  },\n  _drawTrackerElement: function (segment) {\n    return this._createMainElement(this._getMainPointsFromSegment(segment), this._getTrackerSettings(segment));\n  },\n  _updateTrackerElement: function (segment, element) {\n    var settings = this._getTrackerSettings(segment);\n\n    settings.points = this._getMainPointsFromSegment(segment);\n    element.attr(settings);\n  },\n  checkSeriesViewportCoord: function (axis, coord) {\n    if (0 === this._points.length) {\n      return false;\n    }\n\n    var range = axis.isArgumentAxis ? this.getArgumentRange() : this.getViewport();\n    var min = axis.getTranslator().translate(range.categories ? range.categories[0] : range.min);\n    var max = axis.getTranslator().translate(range.categories ? range.categories[range.categories.length - 1] : range.max);\n    var rotated = this.getOptions().rotated;\n    var inverted = axis.getOptions().inverted;\n    return axis.isArgumentAxis && (!rotated && !inverted || rotated && inverted) || !axis.isArgumentAxis && (rotated && !inverted || !rotated && inverted) ? coord >= min && coord <= max : coord >= max && coord <= min;\n  },\n  getSeriesPairCoord: function (coord, isArgument) {\n    var that = this;\n    var oppositeCoord = null;\n    var nearestPoints = this.getNearestPointsByCoord(coord, isArgument);\n    var needValueCoord = isArgument && !that._options.rotated || !isArgument && that._options.rotated;\n\n    for (var i = 0; i < nearestPoints.length; i++) {\n      var p = nearestPoints[i];\n      var k = (p[1].vy - p[0].vy) / (p[1].vx - p[0].vx);\n      var b = p[0].vy - p[0].vx * k;\n      var tmpCoord = void 0;\n\n      if (p[1].vx - p[0].vx === 0) {\n        tmpCoord = needValueCoord ? p[0].vy : p[0].vx;\n      } else {\n        tmpCoord = needValueCoord ? k * coord + b : (coord - b) / k;\n      }\n\n      if (this.checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\n        oppositeCoord = tmpCoord;\n        break;\n      }\n    }\n\n    return oppositeCoord;\n  }\n};\n\nvar lineSeries = exports.chart.line = _extend({}, chartScatterSeries, lineMethods, {\n  getPointCenterByArg: function (arg) {\n    var value = this.getArgumentAxis().getTranslator().translate(arg);\n    return {\n      x: value,\n      y: value\n    };\n  }\n});\n\nexports.chart.stepline = _extend({}, lineSeries, {\n  _calculateStepLinePoints: function (points) {\n    var segment = [];\n    var coordName = this._options.rotated ? \"x\" : \"y\";\n\n    _each(points, function (i, pt) {\n      var point;\n\n      if (!i) {\n        segment.push(pt);\n        return;\n      }\n\n      var step = segment[segment.length - 1][coordName];\n\n      if (step !== pt[coordName]) {\n        point = objectUtils.clone(pt);\n        point[coordName] = step;\n        segment.push(point);\n      }\n\n      segment.push(pt);\n    });\n\n    return segment;\n  },\n  _prepareSegment: function (points) {\n    return lineSeries._prepareSegment(this._calculateStepLinePoints(points));\n  },\n  getSeriesPairCoord: function (coord, isArgument) {\n    var oppositeCoord;\n    var rotated = this._options.rotated;\n    var isOpposite = !isArgument && !rotated || isArgument && rotated;\n    var coordName = !isOpposite ? \"vx\" : \"vy\";\n    var oppositeCoordName = !isOpposite ? \"vy\" : \"vx\";\n    var nearestPoints = this.getNearestPointsByCoord(coord, isArgument);\n\n    for (var i = 0; i < nearestPoints.length; i++) {\n      var p = nearestPoints[i];\n      var tmpCoord = void 0;\n\n      if (isArgument) {\n        tmpCoord = coord !== p[1][coordName] ? p[0][oppositeCoordName] : p[1][oppositeCoordName];\n      } else {\n        tmpCoord = coord === p[0][coordName] ? p[0][oppositeCoordName] : p[1][oppositeCoordName];\n      }\n\n      if (this.checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\n        oppositeCoord = tmpCoord;\n        break;\n      }\n    }\n\n    return oppositeCoord;\n  }\n});\nexports.chart.spline = _extend({}, lineSeries, {\n  _calculateBezierPoints: function (src, rotated) {\n    var bezierPoints = [];\n    var pointsCopy = src;\n\n    var checkExtremum = function (otherPointCoord, pointCoord, controlCoord) {\n      return otherPointCoord > pointCoord && controlCoord > otherPointCoord || otherPointCoord < pointCoord && controlCoord < otherPointCoord ? otherPointCoord : controlCoord;\n    };\n\n    if (1 !== pointsCopy.length) {\n      pointsCopy.forEach(function (curPoint, i) {\n        var leftControlX;\n        var leftControlY;\n        var rightControlX;\n        var rightControlY;\n        var prevPoint = pointsCopy[i - 1];\n        var nextPoint = pointsCopy[i + 1];\n        var xCur;\n        var yCur;\n        var x1;\n        var x2;\n        var y1;\n        var y2;\n        var lambda = .5;\n        var curIsExtremum;\n        var leftPoint;\n        var rightPoint;\n        var a;\n        var b;\n        var c;\n        var xc;\n        var yc;\n        var shift;\n\n        if (!i || i === pointsCopy.length - 1) {\n          bezierPoints.push(curPoint, curPoint);\n          return;\n        }\n\n        xCur = curPoint.x;\n        yCur = curPoint.y;\n        x1 = prevPoint.x;\n        x2 = nextPoint.x;\n        y1 = prevPoint.y;\n        y2 = nextPoint.y;\n        curIsExtremum = !!(!rotated && (yCur <= prevPoint.y && yCur <= nextPoint.y || yCur >= prevPoint.y && yCur >= nextPoint.y) || rotated && (xCur <= prevPoint.x && xCur <= nextPoint.x || xCur >= prevPoint.x && xCur >= nextPoint.x));\n\n        if (curIsExtremum) {\n          if (!rotated) {\n            rightControlY = leftControlY = yCur;\n            rightControlX = (xCur + nextPoint.x) / 2;\n            leftControlX = (xCur + prevPoint.x) / 2;\n          } else {\n            rightControlX = leftControlX = xCur;\n            rightControlY = (yCur + nextPoint.y) / 2;\n            leftControlY = (yCur + prevPoint.y) / 2;\n          }\n        } else {\n          a = y2 - y1;\n          b = x1 - x2;\n          c = y1 * x2 - x1 * y2;\n\n          if (!rotated) {\n            if (!b) {\n              bezierPoints.push(curPoint, curPoint, curPoint);\n              return;\n            }\n\n            xc = xCur;\n            yc = -1 * (a * xc + c) / b;\n            shift = yc - yCur;\n            y1 -= shift;\n            y2 -= shift;\n          } else {\n            if (!a) {\n              bezierPoints.push(curPoint, curPoint, curPoint);\n              return;\n            }\n\n            yc = yCur;\n            xc = -1 * (b * yc + c) / a;\n            shift = xc - xCur;\n            x1 -= shift;\n            x2 -= shift;\n          }\n\n          rightControlX = (xCur + lambda * x2) / (1 + lambda);\n          rightControlY = (yCur + lambda * y2) / (1 + lambda);\n          leftControlX = (xCur + lambda * x1) / (1 + lambda);\n          leftControlY = (yCur + lambda * y1) / (1 + lambda);\n        }\n\n        if (!rotated) {\n          leftControlY = checkExtremum(prevPoint.y, yCur, leftControlY);\n          rightControlY = checkExtremum(nextPoint.y, yCur, rightControlY);\n        } else {\n          leftControlX = checkExtremum(prevPoint.x, xCur, leftControlX);\n          rightControlX = checkExtremum(nextPoint.x, xCur, rightControlX);\n        }\n\n        leftPoint = clonePoint(curPoint, leftControlX, leftControlY);\n        rightPoint = clonePoint(curPoint, rightControlX, rightControlY);\n        bezierPoints.push(leftPoint, curPoint, rightPoint);\n      });\n    } else {\n      bezierPoints.push(pointsCopy[0]);\n    }\n\n    return bezierPoints;\n  },\n  _prepareSegment: function (points, rotated) {\n    return lineSeries._prepareSegment(this._calculateBezierPoints(points, rotated));\n  },\n  _createMainElement: function (points, settings) {\n    return this._renderer.path(points, \"bezier\").attr(settings);\n  },\n  getSeriesPairCoord: function (coord, isArgument) {\n    var that = this;\n    var oppositeCoord = null;\n    var isOpposite = !isArgument && !this._options.rotated || isArgument && this._options.rotated;\n    var coordName = !isOpposite ? \"vx\" : \"vy\";\n    var bezierCoordName = !isOpposite ? \"x\" : \"y\";\n    var oppositeCoordName = !isOpposite ? \"vy\" : \"vx\";\n    var bezierOppositeCoordName = !isOpposite ? \"y\" : \"x\";\n    var axis = !isArgument ? that.getArgumentAxis() : that.getValueAxis();\n    var visibleArea = axis.getVisibleArea();\n    var nearestPoints = this.getNearestPointsByCoord(coord, isArgument);\n\n    var _loop = function (i) {\n      var p = nearestPoints[i];\n\n      if (1 === p.length) {\n        visibleArea[0] <= p[0][oppositeCoordName] && visibleArea[1] >= p[0][oppositeCoordName] && (oppositeCoord = p[0][oppositeCoordName]);\n      } else {\n        var ts = obtainCubicBezierTCoef(coord, p[0][coordName], p[1][bezierCoordName], p[2][bezierCoordName], p[3][coordName]);\n        ts.forEach(function (t) {\n          if (t >= 0 && t <= 1) {\n            var tmpCoord = Math.pow(1 - t, 3) * p[0][oppositeCoordName] + 3 * Math.pow(1 - t, 2) * t * p[1][bezierOppositeCoordName] + 3 * (1 - t) * t * t * p[2][bezierOppositeCoordName] + t * t * t * p[3][oppositeCoordName];\n\n            if (visibleArea[0] <= tmpCoord && visibleArea[1] >= tmpCoord) {\n              oppositeCoord = tmpCoord;\n            }\n          }\n        });\n      }\n\n      if (null !== oppositeCoord) {\n        return \"break\";\n      }\n    };\n\n    for (var i = 0; i < nearestPoints.length; i++) {\n      var _ret = _loop(i);\n\n      if (\"break\" === _ret) {\n        break;\n      }\n    }\n\n    return oppositeCoord;\n  },\n  getNearestPointsByCoord: function (coord, isArgument) {\n    var that = this;\n    var rotated = that.getOptions().rotated;\n    var isOpposite = !isArgument && !rotated || isArgument && rotated;\n    var coordName = isOpposite ? \"vy\" : \"vx\";\n    var points = that.getVisiblePoints();\n    var allPoints = that.getPoints();\n    var bezierPoints = that._segments.length > 0 ? that._segments.reduce(function (a, seg) {\n      return a.concat(seg.line);\n    }, []) : [];\n    var nearestPoints = [];\n\n    if (that.isVisible() && allPoints.length > 0) {\n      if (allPoints.length > 1) {\n        that.findNeighborPointsByCoord(coord, coordName, points.slice(0), allPoints, function (point, nextPoint) {\n          var index = bezierPoints.indexOf(point);\n          nearestPoints.push([point, bezierPoints[index + 1], bezierPoints[index + 2], nextPoint]);\n        });\n      } else {\n        if (allPoints[0][coordName] === coord) {\n          nearestPoints.push([allPoints[0]]);\n        }\n      }\n    }\n\n    return nearestPoints;\n  }\n});\nexports.polar.line = _extend({}, polarScatterSeries, lineMethods, {\n  _sortPoints: function (points) {\n    return points;\n  },\n  _prepareSegment: function (points, rotated, lastSegment) {\n    var preparedPoints = [];\n    var centerPoint = this.getValueAxis().getCenter();\n    var i;\n    lastSegment && this._closeSegment(points);\n\n    if (this.argumentAxisType !== DISCRETE && this.valueAxisType !== DISCRETE) {\n      for (i = 1; i < points.length; i++) {\n        preparedPoints = preparedPoints.concat(this._getTangentPoints(points[i], points[i - 1], centerPoint));\n      }\n\n      if (!preparedPoints.length) {\n        preparedPoints = points;\n      }\n    } else {\n      return lineSeries._prepareSegment.call(this, points);\n    }\n\n    return {\n      line: preparedPoints\n    };\n  },\n  _getRemainingAngle: function (angle) {\n    var normAngle = normalizeAngle(angle);\n    return angle >= 0 ? 360 - normAngle : -normAngle;\n  },\n  _closeSegment: function (points) {\n    var point;\n    var differenceAngle;\n\n    if (this._segments.length) {\n      point = this._segments[0].line[0];\n    } else {\n      point = clonePoint(points[0], points[0].x, points[0].y, points[0].angle);\n    }\n\n    if (points[points.length - 1].angle !== point.angle) {\n      if (normalizeAngle(Math.round(points[points.length - 1].angle)) === normalizeAngle(Math.round(point.angle))) {\n        point.angle = points[points.length - 1].angle;\n      } else {\n        differenceAngle = points[points.length - 1].angle - point.angle;\n        point.angle = points[points.length - 1].angle + this._getRemainingAngle(differenceAngle);\n      }\n\n      points.push(point);\n    }\n  },\n  _getTangentPoints: function (point, prevPoint, centerPoint) {\n    var tangentPoints = [];\n    var betweenAngle = Math.round(prevPoint.angle - point.angle);\n    var tan = (prevPoint.radius - point.radius) / betweenAngle;\n    var i;\n\n    if (0 === betweenAngle) {\n      tangentPoints = [prevPoint, point];\n    } else {\n      if (betweenAngle > 0) {\n        for (i = betweenAngle; i >= 0; i--) {\n          tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, i));\n        }\n      } else {\n        for (i = 0; i >= betweenAngle; i--) {\n          tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, betweenAngle - i));\n        }\n      }\n    }\n\n    return tangentPoints;\n  }\n});","map":null,"metadata":{},"sourceType":"script"}