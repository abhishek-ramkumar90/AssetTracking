{"ast":null,"code":"/**\r\n * DevExtreme (data/array_query.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar Class = require(\"../core/class\");\n\nvar typeUtils = require(\"../core/utils/type\");\n\nvar iteratorUtils = require(\"../core/utils/iterator\");\n\nvar compileGetter = require(\"../core/utils/data\").compileGetter;\n\nvar toComparable = require(\"../core/utils/data\").toComparable;\n\nvar Deferred = require(\"../core/utils/deferred\").Deferred;\n\nvar errorsModule = require(\"./errors\");\n\nvar dataUtils = require(\"./utils\");\n\nvar Iterator = Class.inherit({\n  toArray: function () {\n    var result = [];\n    this.reset();\n\n    while (this.next()) {\n      result.push(this.current());\n    }\n\n    return result;\n  },\n  countable: function () {\n    return false;\n  }\n});\nvar ArrayIterator = Iterator.inherit({\n  ctor: function (array) {\n    this.array = array;\n    this.index = -1;\n  },\n  next: function () {\n    if (this.index + 1 < this.array.length) {\n      this.index++;\n      return true;\n    }\n\n    return false;\n  },\n  current: function () {\n    return this.array[this.index];\n  },\n  reset: function () {\n    this.index = -1;\n  },\n  toArray: function () {\n    return this.array.slice(0);\n  },\n  countable: function () {\n    return true;\n  },\n  count: function () {\n    return this.array.length;\n  }\n});\nvar WrappedIterator = Iterator.inherit({\n  ctor: function (iter) {\n    this.iter = iter;\n  },\n  next: function () {\n    return this.iter.next();\n  },\n  current: function () {\n    return this.iter.current();\n  },\n  reset: function () {\n    return this.iter.reset();\n  }\n});\nvar MapIterator = WrappedIterator.inherit({\n  ctor: function (iter, mapper) {\n    this.callBase(iter);\n    this.index = -1;\n    this.mapper = mapper;\n  },\n  current: function () {\n    return this.mapper(this.callBase(), this.index);\n  },\n  next: function () {\n    var hasNext = this.callBase();\n\n    if (hasNext) {\n      this.index++;\n    }\n\n    return hasNext;\n  }\n});\n\nvar defaultCompare = function (xValue, yValue) {\n  xValue = toComparable(xValue);\n  yValue = toComparable(yValue);\n\n  if (null === xValue && null !== yValue) {\n    return -1;\n  }\n\n  if (null !== xValue && null === yValue) {\n    return 1;\n  }\n\n  if (void 0 === xValue && void 0 !== yValue) {\n    return 1;\n  }\n\n  if (void 0 !== xValue && void 0 === yValue) {\n    return -1;\n  }\n\n  if (xValue < yValue) {\n    return -1;\n  }\n\n  if (xValue > yValue) {\n    return 1;\n  }\n\n  return 0;\n};\n\nvar SortIterator = Iterator.inherit({\n  ctor: function (iter, getter, desc, compare) {\n    if (!(iter instanceof MapIterator)) {\n      iter = new MapIterator(iter, this._wrap);\n    }\n\n    this.iter = iter;\n    this.rules = [{\n      getter: getter,\n      desc: desc,\n      compare: compare\n    }];\n  },\n  thenBy: function (getter, desc, compare) {\n    var result = new SortIterator(this.sortedIter || this.iter, getter, desc, compare);\n\n    if (!this.sortedIter) {\n      result.rules = this.rules.concat(result.rules);\n    }\n\n    return result;\n  },\n  next: function () {\n    this._ensureSorted();\n\n    return this.sortedIter.next();\n  },\n  current: function () {\n    this._ensureSorted();\n\n    return this.sortedIter.current();\n  },\n  reset: function () {\n    delete this.sortedIter;\n  },\n  countable: function () {\n    return this.sortedIter || this.iter.countable();\n  },\n  count: function () {\n    if (this.sortedIter) {\n      return this.sortedIter.count();\n    }\n\n    return this.iter.count();\n  },\n  _ensureSorted: function () {\n    var that = this;\n\n    if (that.sortedIter) {\n      return;\n    }\n\n    iteratorUtils.each(that.rules, function () {\n      this.getter = compileGetter(this.getter);\n    });\n    that.sortedIter = new MapIterator(new ArrayIterator(this.iter.toArray().sort(function (x, y) {\n      return that._compare(x, y);\n    })), that._unwrap);\n  },\n  _wrap: function (record, index) {\n    return {\n      index: index,\n      value: record\n    };\n  },\n  _unwrap: function (wrappedItem) {\n    return wrappedItem.value;\n  },\n  _compare: function (x, y) {\n    var xIndex = x.index;\n    var yIndex = y.index;\n    x = x.value;\n    y = y.value;\n\n    if (x === y) {\n      return xIndex - yIndex;\n    }\n\n    for (var i = 0, rulesCount = this.rules.length; i < rulesCount; i++) {\n      var rule = this.rules[i];\n      var xValue = rule.getter(x);\n      var yValue = rule.getter(y);\n      var compare = rule.compare || defaultCompare;\n      var compareResult = compare(xValue, yValue);\n\n      if (compareResult) {\n        return rule.desc ? -compareResult : compareResult;\n      }\n    }\n\n    return xIndex - yIndex;\n  }\n});\n\nvar compileCriteria = function () {\n  var compileGroup = function (crit) {\n    var ops = [];\n    var isConjunctiveOperator = false;\n    var isConjunctiveNextOperator = false;\n    iteratorUtils.each(crit, function () {\n      if (Array.isArray(this) || typeUtils.isFunction(this)) {\n        if (ops.length > 1 && isConjunctiveOperator !== isConjunctiveNextOperator) {\n          throw new errorsModule.errors.Error(\"E4019\");\n        }\n\n        ops.push(compileCriteria(this));\n        isConjunctiveOperator = isConjunctiveNextOperator;\n        isConjunctiveNextOperator = true;\n      } else {\n        isConjunctiveNextOperator = dataUtils.isConjunctiveOperator(this);\n      }\n    });\n    return function (d) {\n      var result = isConjunctiveOperator;\n\n      for (var i = 0; i < ops.length; i++) {\n        if (ops[i](d) !== isConjunctiveOperator) {\n          result = !isConjunctiveOperator;\n          break;\n        }\n      }\n\n      return result;\n    };\n  };\n\n  var toString = function (value) {\n    return typeUtils.isDefined(value) ? value.toString() : \"\";\n  };\n\n  var compileBinary = function (crit) {\n    crit = dataUtils.normalizeBinaryCriterion(crit);\n    var getter = compileGetter(crit[0]);\n    var op = crit[1];\n    var value = crit[2];\n    value = toComparable(value);\n\n    switch (op.toLowerCase()) {\n      case \"=\":\n        return compileEquals(getter, value);\n\n      case \"<>\":\n        return compileEquals(getter, value, true);\n\n      case \">\":\n        return function (obj) {\n          return toComparable(getter(obj)) > value;\n        };\n\n      case \"<\":\n        return function (obj) {\n          return toComparable(getter(obj)) < value;\n        };\n\n      case \">=\":\n        return function (obj) {\n          return toComparable(getter(obj)) >= value;\n        };\n\n      case \"<=\":\n        return function (obj) {\n          return toComparable(getter(obj)) <= value;\n        };\n\n      case \"startswith\":\n        return function (obj) {\n          return 0 === toComparable(toString(getter(obj))).indexOf(value);\n        };\n\n      case \"endswith\":\n        return function (obj) {\n          var getterValue = toComparable(toString(getter(obj)));\n          var searchValue = toString(value);\n\n          if (getterValue.length < searchValue.length) {\n            return false;\n          }\n\n          return getterValue.lastIndexOf(value) === getterValue.length - value.length;\n        };\n\n      case \"contains\":\n        return function (obj) {\n          return toComparable(toString(getter(obj))).indexOf(value) > -1;\n        };\n\n      case \"notcontains\":\n        return function (obj) {\n          return toComparable(toString(getter(obj))).indexOf(value) === -1;\n        };\n    }\n\n    throw errorsModule.errors.Error(\"E4003\", op);\n  };\n\n  function compileEquals(getter, value, negate) {\n    return function (obj) {\n      obj = toComparable(getter(obj));\n      var result = useStrictComparison(value) ? obj === value : obj == value;\n\n      if (negate) {\n        result = !result;\n      }\n\n      return result;\n    };\n  }\n\n  function useStrictComparison(value) {\n    return \"\" === value || 0 === value || false === value;\n  }\n\n  function compileUnary(crit) {\n    var op = crit[0];\n    var criteria = compileCriteria(crit[1]);\n\n    if (\"!\" === op) {\n      return function (obj) {\n        return !criteria(obj);\n      };\n    }\n\n    throw errorsModule.errors.Error(\"E4003\", op);\n  }\n\n  return function (crit) {\n    if (typeUtils.isFunction(crit)) {\n      return crit;\n    }\n\n    if (dataUtils.isGroupCriterion(crit)) {\n      return compileGroup(crit);\n    }\n\n    if (dataUtils.isUnaryOperation(crit)) {\n      return compileUnary(crit);\n    }\n\n    return compileBinary(crit);\n  };\n}();\n\nvar FilterIterator = WrappedIterator.inherit({\n  ctor: function (iter, criteria) {\n    this.callBase(iter);\n    this.criteria = compileCriteria(criteria);\n  },\n  next: function () {\n    while (this.iter.next()) {\n      if (this.criteria(this.current())) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n});\nvar GroupIterator = Iterator.inherit({\n  ctor: function (iter, getter) {\n    this.iter = iter;\n    this.getter = getter;\n  },\n  next: function () {\n    this._ensureGrouped();\n\n    return this.groupedIter.next();\n  },\n  current: function () {\n    this._ensureGrouped();\n\n    return this.groupedIter.current();\n  },\n  reset: function () {\n    delete this.groupedIter;\n  },\n  countable: function () {\n    return !!this.groupedIter;\n  },\n  count: function () {\n    return this.groupedIter.count();\n  },\n  _ensureGrouped: function () {\n    if (this.groupedIter) {\n      return;\n    }\n\n    var hash = {};\n    var keys = [];\n    var iter = this.iter;\n    var getter = compileGetter(this.getter);\n    iter.reset();\n\n    while (iter.next()) {\n      var current = iter.current();\n      var key = getter(current);\n\n      if (key in hash) {\n        hash[key].push(current);\n      } else {\n        hash[key] = [current];\n        keys.push(key);\n      }\n    }\n\n    this.groupedIter = new ArrayIterator(iteratorUtils.map(keys, function (key) {\n      return {\n        key: key,\n        items: hash[key]\n      };\n    }));\n  }\n});\nvar SelectIterator = WrappedIterator.inherit({\n  ctor: function (iter, getter) {\n    this.callBase(iter);\n    this.getter = compileGetter(getter);\n  },\n  current: function () {\n    return this.getter(this.callBase());\n  },\n  countable: function () {\n    return this.iter.countable();\n  },\n  count: function () {\n    return this.iter.count();\n  }\n});\nvar SliceIterator = WrappedIterator.inherit({\n  ctor: function (iter, skip, take) {\n    this.callBase(iter);\n    this.skip = Math.max(0, skip);\n    this.take = Math.max(0, take);\n    this.pos = 0;\n  },\n  next: function () {\n    if (this.pos >= this.skip + this.take) {\n      return false;\n    }\n\n    while (this.pos < this.skip && this.iter.next()) {\n      this.pos++;\n    }\n\n    this.pos++;\n    return this.iter.next();\n  },\n  reset: function () {\n    this.callBase();\n    this.pos = 0;\n  },\n  countable: function () {\n    return this.iter.countable();\n  },\n  count: function () {\n    return Math.min(this.iter.count() - this.skip, this.take);\n  }\n});\n\nvar arrayQueryImpl = function arrayQueryImpl(iter, queryOptions) {\n  queryOptions = queryOptions || {};\n\n  if (!(iter instanceof Iterator)) {\n    iter = new ArrayIterator(iter);\n  }\n\n  var handleError = function (error) {\n    var handler = queryOptions.errorHandler;\n\n    if (handler) {\n      handler(error);\n    }\n\n    errorsModule._errorHandler(error);\n  };\n\n  var aggregateCore = function (aggregator) {\n    var d = new Deferred().fail(handleError);\n    var seed;\n    var step = aggregator.step;\n    var finalize = aggregator.finalize;\n\n    try {\n      iter.reset();\n\n      if (\"seed\" in aggregator) {\n        seed = aggregator.seed;\n      } else {\n        seed = iter.next() ? iter.current() : NaN;\n      }\n\n      var accumulator = seed;\n\n      while (iter.next()) {\n        accumulator = step(accumulator, iter.current());\n      }\n\n      d.resolve(finalize ? finalize(accumulator) : accumulator);\n    } catch (x) {\n      d.reject(x);\n    }\n\n    return d.promise();\n  };\n\n  var aggregate = function (seed, step, finalize) {\n    if (arguments.length < 2) {\n      return aggregateCore({\n        step: arguments[0]\n      });\n    }\n\n    return aggregateCore({\n      seed: seed,\n      step: step,\n      finalize: finalize\n    });\n  };\n\n  var standardAggregate = function (name) {\n    return aggregateCore(dataUtils.aggregators[name]);\n  };\n\n  var select = function (getter) {\n    if (!typeUtils.isFunction(getter) && !Array.isArray(getter)) {\n      getter = [].slice.call(arguments);\n    }\n\n    return chainQuery(new SelectIterator(iter, getter));\n  };\n\n  var selectProp = function (name) {\n    return select(compileGetter(name));\n  };\n\n  var chainQuery = function (iter) {\n    return arrayQueryImpl(iter, queryOptions);\n  };\n\n  return {\n    toArray: function () {\n      return iter.toArray();\n    },\n    enumerate: function () {\n      var d = new Deferred().fail(handleError);\n\n      try {\n        d.resolve(iter.toArray());\n      } catch (x) {\n        d.reject(x);\n      }\n\n      return d.promise();\n    },\n    sortBy: function (getter, desc, compare) {\n      return chainQuery(new SortIterator(iter, getter, desc, compare));\n    },\n    thenBy: function (getter, desc, compare) {\n      if (iter instanceof SortIterator) {\n        return chainQuery(iter.thenBy(getter, desc, compare));\n      }\n\n      throw errorsModule.errors.Error(\"E4004\");\n    },\n    filter: function (criteria) {\n      if (!Array.isArray(criteria)) {\n        criteria = [].slice.call(arguments);\n      }\n\n      return chainQuery(new FilterIterator(iter, criteria));\n    },\n    slice: function (skip, take) {\n      if (void 0 === take) {\n        take = Number.MAX_VALUE;\n      }\n\n      return chainQuery(new SliceIterator(iter, skip, take));\n    },\n    select: select,\n    groupBy: function (getter) {\n      return chainQuery(new GroupIterator(iter, getter));\n    },\n    aggregate: aggregate,\n    count: function () {\n      if (iter.countable()) {\n        var d = new Deferred().fail(handleError);\n\n        try {\n          d.resolve(iter.count());\n        } catch (x) {\n          d.reject(x);\n        }\n\n        return d.promise();\n      }\n\n      return standardAggregate(\"count\");\n    },\n    sum: function (getter) {\n      if (getter) {\n        return selectProp(getter).sum();\n      }\n\n      return standardAggregate(\"sum\");\n    },\n    min: function (getter) {\n      if (getter) {\n        return selectProp(getter).min();\n      }\n\n      return standardAggregate(\"min\");\n    },\n    max: function (getter) {\n      if (getter) {\n        return selectProp(getter).max();\n      }\n\n      return standardAggregate(\"max\");\n    },\n    avg: function (getter) {\n      if (getter) {\n        return selectProp(getter).avg();\n      }\n\n      return standardAggregate(\"avg\");\n    }\n  };\n};\n\nmodule.exports = arrayQueryImpl;","map":null,"metadata":{},"sourceType":"script"}