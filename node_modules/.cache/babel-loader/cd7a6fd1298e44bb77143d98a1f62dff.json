{"ast":null,"code":"/**\r\n * DevExtreme (viz/core/utils.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar noop = require(\"../../core/utils/common\").noop;\n\nvar typeUtils = require(\"../../core/utils/type\");\n\nvar extend = require(\"../../core/utils/extend\").extend;\n\nvar each = require(\"../../core/utils/iterator\").each;\n\nvar mathUtils = require(\"../../core/utils/math\");\n\nvar dateToMilliseconds = require(\"../../core/utils/date\").dateToMilliseconds;\n\nvar domAdapter = require(\"../../core/dom_adapter\");\n\nvar Color = require(\"../../color\");\n\nvar isDefined = typeUtils.isDefined;\nvar isNumber = typeUtils.isNumeric;\nvar isExponential = typeUtils.isExponential;\nvar _math = Math;\nvar _round = _math.round;\nvar _sqrt = Math.sqrt;\nvar PI = Math.PI;\nvar MAX_PIXEL_COUNT = 1e10;\nvar PI_DIV_180 = PI / 180;\nvar LN10 = Math.LN10;\nvar cosFunc = Math.cos;\nvar sinFunc = Math.sin;\nvar abs = Math.abs;\nvar log = Math.log;\nvar floor = Math.floor;\nvar ceil = Math.ceil;\nvar max = Math.max;\nvar _isNaN = isNaN;\nvar _Number = Number;\nvar _NaN = NaN;\nvar adjust = mathUtils.adjust,\n    sign = mathUtils.sign;\nvar PANE_PADDING = 10;\n\nvar getLog = function (value, base) {\n  if (!value) {\n    return _NaN;\n  }\n\n  return Math.log(value) / Math.log(base);\n};\n\nvar getAdjustedLog10 = function (value) {\n  return adjust(getLog(value, 10));\n};\n\nvar raiseTo = function (power, base) {\n  return Math.pow(base, power);\n};\n\nvar normalizeAngle = function (angle) {\n  return (angle % 360 + 360) % 360;\n};\n\nvar convertAngleToRendererSpace = function (angle) {\n  return 90 - angle;\n};\n\nvar degreesToRadians = function (value) {\n  return PI * value / 180;\n};\n\nvar getCosAndSin = function (angle) {\n  var angleInRadians = degreesToRadians(angle);\n  return {\n    cos: cosFunc(angleInRadians),\n    sin: sinFunc(angleInRadians)\n  };\n};\n\nvar DECIMAL_ORDER_THRESHOLD = 1e-14;\n\nvar getDistance = function (x1, y1, x2, y2) {\n  var diffX = x2 - x1;\n  var diffY = y2 - y1;\n  return Math.sqrt(diffY * diffY + diffX * diffX);\n};\n\nvar getDecimalOrder = function (number) {\n  var n = abs(number);\n  var cn;\n\n  if (!_isNaN(n)) {\n    if (n > 0) {\n      n = log(n) / LN10;\n      cn = ceil(n);\n      return cn - n < DECIMAL_ORDER_THRESHOLD ? cn : floor(n);\n    }\n\n    return 0;\n  }\n\n  return _NaN;\n};\n\nvar getAppropriateFormat = function (start, end, count) {\n  var order = max(getDecimalOrder(start), getDecimalOrder(end));\n  var precision = -getDecimalOrder(abs(end - start) / count);\n  var format;\n\n  if (!_isNaN(order) && !_isNaN(precision)) {\n    if (abs(order) <= 4) {\n      format = \"fixedPoint\";\n      precision < 0 && (precision = 0);\n      precision > 4 && (precision = 4);\n    } else {\n      format = \"exponential\";\n      precision += order - 1;\n      precision > 3 && (precision = 3);\n    }\n\n    return {\n      type: format,\n      precision: precision\n    };\n  }\n\n  return null;\n};\n\nvar roundValue = function (value, precision) {\n  if (precision > 20) {\n    precision = 20;\n  }\n\n  if (isNumber(value)) {\n    if (isExponential(value)) {\n      return _Number(value.toExponential(precision));\n    } else {\n      return _Number(value.toFixed(precision));\n    }\n  }\n};\n\nvar getPower = function (value) {\n  return value.toExponential().split(\"e\")[1];\n};\n\nfunction map(array, callback) {\n  var i = 0;\n  var len = array.length;\n  var result = [];\n  var value;\n\n  while (i < len) {\n    value = callback(array[i], i);\n\n    if (null !== value) {\n      result.push(value);\n    }\n\n    i++;\n  }\n\n  return result;\n}\n\nfunction selectByKeys(object, keys) {\n  return map(keys, function (key) {\n    return object[key] ? object[key] : null;\n  });\n}\n\nfunction decreaseFields(object, keys, eachDecrease, decrease) {\n  var dec = decrease;\n  each(keys, function (_, key) {\n    if (object[key]) {\n      object[key] -= eachDecrease;\n      dec -= eachDecrease;\n    }\n  });\n  return dec;\n}\n\nfunction normalizeEnum(value) {\n  return String(value).toLowerCase();\n}\n\nfunction setCanvasValues(canvas) {\n  if (canvas) {\n    canvas.originalTop = canvas.top;\n    canvas.originalBottom = canvas.bottom;\n    canvas.originalLeft = canvas.left;\n    canvas.originalRight = canvas.right;\n  }\n\n  return canvas;\n}\n\nfunction normalizeBBoxField(value) {\n  return -MAX_PIXEL_COUNT < value && value < +MAX_PIXEL_COUNT ? value : 0;\n}\n\nfunction normalizeBBox(bBox) {\n  var xl = normalizeBBoxField(floor(bBox.x));\n  var yt = normalizeBBoxField(floor(bBox.y));\n  var xr = normalizeBBoxField(ceil(bBox.width + bBox.x));\n  var yb = normalizeBBoxField(ceil(bBox.height + bBox.y));\n  var result = {\n    x: xl,\n    y: yt,\n    width: xr - xl,\n    height: yb - yt\n  };\n  result.isEmpty = !result.x && !result.y && !result.width && !result.height;\n  return result;\n}\n\nfunction rotateBBox(bBox, center, angle) {\n  var cos = _Number(cosFunc(angle * PI_DIV_180).toFixed(3));\n\n  var sin = _Number(sinFunc(angle * PI_DIV_180).toFixed(3));\n\n  var w2 = bBox.width / 2;\n  var h2 = bBox.height / 2;\n  var centerX = bBox.x + w2;\n  var centerY = bBox.y + h2;\n  var w2_ = abs(w2 * cos) + abs(h2 * sin);\n  var h2_ = abs(w2 * sin) + abs(h2 * cos);\n  var centerX_ = center[0] + (centerX - center[0]) * cos + (centerY - center[1]) * sin;\n  var centerY_ = center[1] - (centerX - center[0]) * sin + (centerY - center[1]) * cos;\n  return normalizeBBox({\n    x: centerX_ - w2_,\n    y: centerY_ - h2_,\n    width: 2 * w2_,\n    height: 2 * h2_\n  });\n}\n\nextend(exports, {\n  decreaseGaps: function (object, keys, decrease) {\n    var arrayGaps;\n\n    do {\n      arrayGaps = selectByKeys(object, keys);\n      arrayGaps.push(_math.ceil(decrease / arrayGaps.length));\n      decrease = decreaseFields(object, keys, _math.min.apply(null, arrayGaps), decrease);\n    } while (decrease > 0 && arrayGaps.length > 1);\n\n    return decrease;\n  },\n  normalizeEnum: normalizeEnum,\n  parseScalar: function (value, defaultValue) {\n    return void 0 !== value ? value : defaultValue;\n  },\n  enumParser: function (values) {\n    var stored = {};\n    var i;\n    var ii;\n\n    for (i = 0, ii = values.length; i < ii; ++i) {\n      stored[normalizeEnum(values[i])] = 1;\n    }\n\n    return function (value, defaultValue) {\n      var _value = normalizeEnum(value);\n\n      return stored[_value] ? _value : defaultValue;\n    };\n  },\n  patchFontOptions: function (options) {\n    var fontOptions = {};\n    each(options || {}, function (key, value) {\n      if (/^(cursor)$/i.test(key)) {} else {\n        if (\"opacity\" === key) {\n          value = null;\n        } else {\n          if (\"color\" === key) {\n            key = \"fill\";\n\n            if (\"opacity\" in options) {\n              var color = new Color(value);\n              value = \"rgba(\".concat(color.r, \",\").concat(color.g, \",\").concat(color.b, \",\").concat(options.opacity, \")\");\n            }\n          } else {\n            key = \"font-\" + key;\n          }\n        }\n      }\n\n      fontOptions[key] = value;\n    });\n    return fontOptions;\n  },\n  checkElementHasPropertyFromStyleSheet: function (element, property) {\n    var slice = Array.prototype.slice;\n    var cssRules = slice.call(domAdapter.getDocument().styleSheets).reduce(function (rules, styleSheet) {\n      return rules.concat(slice.call(styleSheet.cssRules || styleSheet.rules));\n    }, []);\n    var elementRules = cssRules.filter(function (rule) {\n      try {\n        return domAdapter.elementMatches(element, rule.selectorText);\n      } catch (e) {\n        return false;\n      }\n    });\n    return elementRules.some(function (rule) {\n      return !!rule.style[property];\n    });\n  },\n  convertPolarToXY: function (centerCoords, startAngle, angle, radius) {\n    var shiftAngle = 90;\n    var normalizedRadius = radius > 0 ? radius : 0;\n    angle = isDefined(angle) ? angle + startAngle - shiftAngle : 0;\n    var cosSin = getCosAndSin(angle);\n    return {\n      x: _round(centerCoords.x + normalizedRadius * cosSin.cos),\n      y: _round(centerCoords.y + normalizedRadius * cosSin.sin)\n    };\n  },\n  convertXYToPolar: function (centerCoords, x, y) {\n    var radius = getDistance(centerCoords.x, centerCoords.y, x, y);\n\n    var angle = _math.atan2(y - centerCoords.y, x - centerCoords.x);\n\n    return {\n      phi: _round(normalizeAngle(180 * angle / _math.PI)),\n      r: _round(radius)\n    };\n  },\n  processSeriesTemplate: function (seriesTemplate, items) {\n    var customizeSeries = typeUtils.isFunction(seriesTemplate.customizeSeries) ? seriesTemplate.customizeSeries : noop;\n    var nameField = seriesTemplate.nameField;\n    var generatedSeries = {};\n    var seriesOrder = [];\n    var series;\n    var i = 0;\n    var length;\n    var data;\n    items = items || [];\n\n    for (length = items.length; i < length; i++) {\n      data = items[i];\n\n      if (nameField in data) {\n        series = generatedSeries[data[nameField]];\n\n        if (!series) {\n          series = generatedSeries[data[nameField]] = {\n            name: data[nameField],\n            nameFieldValue: data[nameField]\n          };\n          seriesOrder.push(series.name);\n        }\n      }\n    }\n\n    return map(seriesOrder, function (orderedName) {\n      var group = generatedSeries[orderedName];\n      return extend(group, customizeSeries.call(null, group.name));\n    });\n  },\n  getCategoriesInfo: function (categories, startValue, endValue) {\n    if (0 === categories.length) {\n      return {\n        categories: []\n      };\n    }\n\n    startValue = isDefined(startValue) ? startValue : categories[0];\n    endValue = isDefined(endValue) ? endValue : categories[categories.length - 1];\n    var categoriesValue = map(categories, function (category) {\n      return isDefined(category) ? category.valueOf() : null;\n    });\n    var indexStartValue = categoriesValue.indexOf(startValue.valueOf());\n    var indexEndValue = categoriesValue.indexOf(endValue.valueOf());\n    var swapBuf;\n    var inverted = false;\n    indexStartValue < 0 && (indexStartValue = 0);\n    indexEndValue < 0 && (indexEndValue = categories.length - 1);\n\n    if (indexEndValue < indexStartValue) {\n      swapBuf = indexEndValue;\n      indexEndValue = indexStartValue;\n      indexStartValue = swapBuf;\n      inverted = true;\n    }\n\n    var visibleCategories = categories.slice(indexStartValue, indexEndValue + 1);\n    var lastIdx = visibleCategories.length - 1;\n    return {\n      categories: visibleCategories,\n      start: visibleCategories[inverted ? lastIdx : 0],\n      end: visibleCategories[inverted ? 0 : lastIdx],\n      inverted: inverted\n    };\n  },\n  setCanvasValues: setCanvasValues,\n  normalizePanesHeight: function (panes) {\n    panes.forEach(function (pane) {\n      var height = pane.height;\n      var unit = 0;\n      var parsedHeight = parseFloat(height) || void 0;\n\n      if (typeUtils.isString(height) && height.indexOf(\"px\") > -1 || typeUtils.isNumeric(height) && height > 1) {\n        parsedHeight = _round(parsedHeight);\n        unit = 1;\n      }\n\n      if (!unit && parsedHeight) {\n        if (typeUtils.isString(height) && height.indexOf(\"%\") > -1) {\n          parsedHeight /= 100;\n        } else {\n          if (parsedHeight < 0) {\n            parsedHeight = parsedHeight < -1 ? 1 : _math.abs(parsedHeight);\n          }\n        }\n      }\n\n      pane.height = parsedHeight;\n      pane.unit = unit;\n    });\n    var weightSum = panes.filter(function (pane) {\n      return !pane.unit;\n    }).reduce(function (prev, next) {\n      return prev + (next.height || 0);\n    }, 0);\n    var weightHeightCount = panes.filter(function (pane) {\n      return !pane.unit;\n    }).length;\n    var emptyHeightCount = panes.filter(function (pane) {\n      return !pane.unit && !pane.height;\n    }).length;\n\n    if (weightSum < 1 && emptyHeightCount) {\n      panes.filter(function (pane) {\n        return !pane.unit && !pane.height;\n      }).forEach(function (pane) {\n        return pane.height = (1 - weightSum) / emptyHeightCount;\n      });\n    } else {\n      if (weightSum > 1 || weightSum < 1 && !emptyHeightCount || 1 === weightSum && emptyHeightCount) {\n        if (emptyHeightCount) {\n          var weightForEmpty = weightSum / weightHeightCount;\n          var emptyWeightSum = emptyHeightCount * weightForEmpty;\n          panes.filter(function (pane) {\n            return !pane.unit && pane.height;\n          }).forEach(function (pane) {\n            return pane.height *= (weightSum - emptyWeightSum) / weightSum;\n          });\n          panes.filter(function (pane) {\n            return !pane.unit && !pane.height;\n          }).forEach(function (pane) {\n            return pane.height = weightForEmpty;\n          });\n        }\n\n        panes.forEach(function (pane) {\n          return !pane.unit && (pane.height *= 1 / weightSum);\n        });\n      }\n    }\n  },\n  updatePanesCanvases: function (panes, canvas, rotated) {\n    var distributedSpace = 0;\n    var padding = PANE_PADDING;\n    var paneSpace = rotated ? canvas.width - canvas.left - canvas.right : canvas.height - canvas.top - canvas.bottom;\n    var usefulSpace = paneSpace - padding * (panes.length - 1);\n    var startName = rotated ? \"left\" : \"top\";\n    var endName = rotated ? \"right\" : \"bottom\";\n    var totalCustomSpace = panes.reduce(function (prev, cur) {\n      return prev + (cur.unit ? cur.height : 0);\n    }, 0);\n    usefulSpace -= totalCustomSpace;\n    panes.forEach(function (pane) {\n      var calcLength = pane.unit ? pane.height : _round(pane.height * usefulSpace);\n      pane.canvas = pane.canvas || {};\n      extend(pane.canvas, canvas);\n      pane.canvas[startName] = canvas[startName] + distributedSpace;\n      pane.canvas[endName] = canvas[endName] + (paneSpace - calcLength - distributedSpace);\n      distributedSpace = distributedSpace + calcLength + padding;\n      setCanvasValues(pane.canvas);\n    });\n  },\n  unique: function (array) {\n    var values = {};\n    return map(array, function (item) {\n      var result = !values[item] ? item : null;\n      values[item] = true;\n      return result;\n    });\n  },\n  map: map,\n  getVerticallyShiftedAngularCoords: function (bBox, dy, center) {\n    var isPositive = bBox.x + bBox.width / 2 >= center.x;\n    var horizontalOffset1 = (isPositive ? bBox.x : bBox.x + bBox.width) - center.x;\n    var verticalOffset1 = bBox.y - center.y;\n    var verticalOffset2 = verticalOffset1 + dy;\n\n    var horizontalOffset2 = _round(_sqrt(horizontalOffset1 * horizontalOffset1 + verticalOffset1 * verticalOffset1 - verticalOffset2 * verticalOffset2));\n\n    var dx = (isPositive ? +horizontalOffset2 : -horizontalOffset2) || horizontalOffset1;\n    return {\n      x: center.x + (isPositive ? dx : dx - bBox.width),\n      y: bBox.y + dy\n    };\n  },\n  mergeMarginOptions: function (opt1, opt2) {\n    return {\n      checkInterval: opt1.checkInterval || opt2.checkInterval,\n      size: Math.max(opt1.size || 0, opt2.size || 0),\n      percentStick: opt1.percentStick || opt2.percentStick,\n      sizePointNormalState: Math.max(opt1.sizePointNormalState || 0, opt2.sizePointNormalState || 0)\n    };\n  }\n});\n\nfunction getVizRangeObject(value) {\n  if (Array.isArray(value)) {\n    return {\n      startValue: value[0],\n      endValue: value[1]\n    };\n  } else {\n    return value || {};\n  }\n}\n\nfunction convertVisualRangeObject(visualRange, convertToVisualRange) {\n  if (convertToVisualRange) {\n    return visualRange;\n  }\n\n  return [visualRange.startValue, visualRange.endValue];\n}\n\nfunction getAddFunction(range, correctZeroLevel) {\n  if (\"datetime\" === range.dataType) {\n    return function (rangeValue, marginValue) {\n      var sign = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;\n      return new Date(rangeValue.getTime() + sign * marginValue);\n    };\n  }\n\n  if (\"logarithmic\" === range.axisType) {\n    return function (rangeValue, marginValue) {\n      var sign = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;\n      var log = getLogExt(rangeValue, range.base) + sign * marginValue;\n      return raiseToExt(log, range.base);\n    };\n  }\n\n  return function (rangeValue, marginValue) {\n    var sign = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;\n    var newValue = rangeValue + sign * marginValue;\n    return correctZeroLevel && newValue * rangeValue <= 0 ? 0 : newValue;\n  };\n}\n\nfunction adjustVisualRange(options, visualRange, wholeRange, dataRange) {\n  var minDefined = typeUtils.isDefined(visualRange.startValue);\n  var maxDefined = typeUtils.isDefined(visualRange.endValue);\n  var nonDiscrete = \"discrete\" !== options.axisType;\n  dataRange = dataRange || wholeRange;\n  var add = getAddFunction(options, false);\n  var min = minDefined ? visualRange.startValue : dataRange.min;\n  var max = maxDefined ? visualRange.endValue : dataRange.max;\n  var rangeLength = visualRange.length;\n  var categories = dataRange.categories;\n\n  if (nonDiscrete && !typeUtils.isDefined(min) && !typeUtils.isDefined(max)) {\n    return {\n      startValue: min,\n      endValue: max\n    };\n  }\n\n  if (isDefined(rangeLength)) {\n    if (nonDiscrete) {\n      if (\"datetime\" === options.dataType && !isNumber(rangeLength)) {\n        rangeLength = dateToMilliseconds(rangeLength);\n      }\n\n      if (maxDefined && !minDefined || !maxDefined && !minDefined) {\n        isDefined(wholeRange.max) && (max = max > wholeRange.max ? wholeRange.max : max);\n        min = add(max, rangeLength, -1);\n      } else {\n        if (minDefined && !maxDefined) {\n          isDefined(wholeRange.min) && (min = min < wholeRange.min ? wholeRange.min : min);\n          max = add(min, rangeLength);\n        }\n      }\n    } else {\n      rangeLength = parseInt(rangeLength);\n\n      if (!isNaN(rangeLength) && isFinite(rangeLength)) {\n        rangeLength--;\n\n        if (!maxDefined && !minDefined) {\n          max = categories[categories.length - 1];\n          min = categories[categories.length - 1 - rangeLength];\n        } else {\n          if (minDefined && !maxDefined) {\n            var categoriesInfo = exports.getCategoriesInfo(categories, min, void 0);\n            max = categoriesInfo.categories[rangeLength];\n          } else {\n            if (!minDefined && maxDefined) {\n              var _categoriesInfo = exports.getCategoriesInfo(categories, void 0, max);\n\n              min = _categoriesInfo.categories[_categoriesInfo.categories.length - 1 - rangeLength];\n            }\n          }\n        }\n      }\n    }\n  }\n\n  if (nonDiscrete) {\n    if (isDefined(wholeRange.max) && max > wholeRange.max) {\n      max = wholeRange.max;\n    }\n\n    if (isDefined(wholeRange.min) && min < wholeRange.min) {\n      min = wholeRange.min;\n    }\n  }\n\n  return {\n    startValue: min,\n    endValue: max\n  };\n}\n\nfunction getLogExt(value, base) {\n  var allowNegatives = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;\n  var linearThreshold = arguments.length > 3 ? arguments[3] : void 0;\n\n  if (!allowNegatives) {\n    return getLog(value, base);\n  }\n\n  if (0 === value) {\n    return 0;\n  }\n\n  var transformValue = getLog(Math.abs(value), base) - (linearThreshold - 1);\n\n  if (transformValue < 0) {\n    return 0;\n  }\n\n  return adjust(sign(value) * transformValue, Number(Math.pow(base, linearThreshold - 1).toFixed(Math.abs(linearThreshold))));\n}\n\nfunction raiseToExt(value, base) {\n  var allowNegatives = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;\n  var linearThreshold = arguments.length > 3 ? arguments[3] : void 0;\n\n  if (!allowNegatives) {\n    return raiseTo(value, base);\n  }\n\n  if (0 === value) {\n    return 0;\n  }\n\n  var transformValue = raiseTo(Math.abs(value) + (linearThreshold - 1), base);\n\n  if (transformValue < 0) {\n    return 0;\n  }\n\n  return adjust(sign(value) * transformValue, Number(Math.pow(base, linearThreshold).toFixed(Math.abs(linearThreshold))));\n}\n\nfunction rangesAreEqual(range, rangeFromOptions) {\n  if (Array.isArray(rangeFromOptions)) {\n    return range.length === rangeFromOptions.length && range.every(function (item, i) {\n      return valueOf(item) === valueOf(rangeFromOptions[i]);\n    });\n  } else {\n    return valueOf(range.startValue) === valueOf(rangeFromOptions.startValue) && valueOf(range.endValue) === valueOf(rangeFromOptions.endValue);\n  }\n}\n\nfunction valueOf(value) {\n  return value && value.valueOf();\n}\n\nfunction pointInCanvas(canvas, x, y) {\n  return x >= canvas.left && x <= canvas.right && y >= canvas.top && y <= canvas.bottom;\n}\n\nexports.getVizRangeObject = getVizRangeObject;\nexports.convertVisualRangeObject = convertVisualRangeObject;\nexports.adjustVisualRange = adjustVisualRange;\nexports.getAddFunction = getAddFunction;\nexports.getLog = getLog;\nexports.getLogExt = getLogExt;\nexports.getAdjustedLog10 = getAdjustedLog10;\nexports.raiseTo = raiseTo;\nexports.raiseToExt = raiseToExt;\nexports.normalizeAngle = normalizeAngle;\nexports.convertAngleToRendererSpace = convertAngleToRendererSpace;\nexports.degreesToRadians = degreesToRadians;\nexports.getCosAndSin = getCosAndSin;\nexports.getDecimalOrder = getDecimalOrder;\nexports.getAppropriateFormat = getAppropriateFormat;\nexports.getDistance = getDistance;\nexports.roundValue = roundValue;\nexports.getPower = getPower;\nexports.valueOf = valueOf;\nexports.rotateBBox = rotateBBox;\nexports.normalizeBBox = normalizeBBox;\nexports.PANE_PADDING = PANE_PADDING;\nexports.rangesAreEqual = rangesAreEqual;\nexports.pointInCanvas = pointInCanvas;","map":null,"metadata":{},"sourceType":"script"}