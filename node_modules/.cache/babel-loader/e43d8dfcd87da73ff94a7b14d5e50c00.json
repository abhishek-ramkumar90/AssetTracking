{"ast":null,"code":"/**\r\n * DevExtreme (viz/series/points/bar_point.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar extend = require(\"../../../core/utils/extend\").extend;\n\nvar _extend = extend;\nvar _math = Math;\nvar _floor = _math.floor;\nvar _abs = _math.abs;\n\nvar symbolPoint = require(\"./symbol_point\");\n\nvar CANVAS_POSITION_DEFAULT = \"canvas_position_default\";\nvar DEFAULT_BAR_TRACKER_SIZE = 9;\nvar CORRECTING_BAR_TRACKER_VALUE = 4;\nvar RIGHT = \"right\";\nvar LEFT = \"left\";\nvar TOP = \"top\";\nvar BOTTOM = \"bottom\";\n\nfunction getLabelOrientation(point) {\n  var initialValue = point.initialValue;\n\n  var invert = point._getValTranslator().getBusinessRange().invert;\n\n  var isDiscreteValue = \"discrete\" === point.series.valueAxisType;\n  var isFullStacked = point.series.isFullStackedSeries();\n  var notAxisInverted = !isDiscreteValue && (initialValue >= 0 && !invert || initialValue < 0 && invert) || isDiscreteValue && !invert || isFullStacked;\n  return notAxisInverted ? TOP : BOTTOM;\n}\n\nmodule.exports = _extend({}, symbolPoint, {\n  correctCoordinates: function (correctOptions) {\n    var that = this;\n\n    var correction = _floor(correctOptions.offset - correctOptions.width / 2);\n\n    if (that._options.rotated) {\n      that.height = correctOptions.width;\n      that.yCorrection = correction;\n      that.xCorrection = null;\n    } else {\n      that.width = correctOptions.width;\n      that.xCorrection = correction;\n      that.yCorrection = null;\n    }\n  },\n  _getGraphicBBox: function (location) {\n    var bBox = {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height\n    };\n\n    if (location) {\n      var isTop = \"top\" === location;\n\n      if (!this._options.rotated) {\n        bBox.y = isTop ? bBox.y : bBox.y + bBox.height;\n        bBox.height = 0;\n      } else {\n        bBox.x = isTop ? bBox.x + bBox.width : bBox.x;\n        bBox.width = 0;\n      }\n    }\n\n    return bBox;\n  },\n  _getLabelConnector: function (location) {\n    return this._getGraphicBBox(location);\n  },\n  _getLabelPosition: function () {\n    var position = getLabelOrientation(this);\n\n    if (this._options.rotated) {\n      position = position === TOP ? RIGHT : LEFT;\n    }\n\n    return position;\n  },\n  _getLabelCoords: function (label) {\n    var that = this;\n    var coords;\n\n    if (0 === that.initialValue && that.series.isFullStackedSeries()) {\n      if (!this._options.rotated) {\n        coords = that._getLabelCoordOfPosition(label, TOP);\n      } else {\n        coords = that._getLabelCoordOfPosition(label, RIGHT);\n      }\n    } else {\n      if (\"inside\" === label.getLayoutOptions().position) {\n        coords = that._getLabelCoordOfPosition(label, \"inside\");\n      } else {\n        coords = symbolPoint._getLabelCoords.call(this, label);\n      }\n    }\n\n    return coords;\n  },\n  _drawLabel: function () {\n    this._label.pointPosition = \"inside\" !== this._label.getLayoutOptions().position && getLabelOrientation(this);\n\n    symbolPoint._drawLabel.call(this);\n  },\n  hideInsideLabel: function (label, coord) {\n    var graphicBBox = this._getGraphicBBox();\n\n    var labelBBox = label.getBoundingRect();\n\n    if (this._options.resolveLabelsOverlapping) {\n      if ((coord.y <= graphicBBox.y && coord.y + labelBBox.height >= graphicBBox.y + graphicBBox.height || coord.x <= graphicBBox.x && coord.x + labelBBox.width >= graphicBBox.x + graphicBBox.width) && !(coord.y > graphicBBox.y + graphicBBox.height || coord.y + labelBBox.height < graphicBBox.y || coord.x > graphicBBox.x + graphicBBox.width || coord.x + labelBBox.width < graphicBBox.x)) {\n        label.draw(false);\n        return true;\n      }\n    }\n\n    return false;\n  },\n  _showForZeroValues: function () {\n    return this._options.label.showForZeroValues || this.initialValue;\n  },\n  _drawMarker: function (renderer, group, animationEnabled) {\n    var that = this;\n\n    var style = that._getStyle();\n\n    var r = that._options.cornerRadius;\n    var rotated = that._options.rotated;\n\n    var _that$getMarkerCoords = that.getMarkerCoords(),\n        x = _that$getMarkerCoords.x,\n        y = _that$getMarkerCoords.y,\n        width = _that$getMarkerCoords.width,\n        height = _that$getMarkerCoords.height;\n\n    if (animationEnabled) {\n      if (rotated) {\n        width = 0;\n        x = that.defaultX;\n      } else {\n        height = 0;\n        y = that.defaultY;\n      }\n    }\n\n    that.graphic = renderer.rect(x, y, width, height).attr({\n      rx: r,\n      ry: r\n    }).smartAttr(style).data({\n      \"chart-data-point\": that\n    }).append(group);\n  },\n  _getSettingsForTracker: function () {\n    var that = this;\n    var y = that.y;\n    var height = that.height;\n    var x = that.x;\n    var width = that.width;\n\n    if (that._options.rotated) {\n      if (1 === width) {\n        width = DEFAULT_BAR_TRACKER_SIZE;\n        x -= CORRECTING_BAR_TRACKER_VALUE;\n      }\n    } else {\n      if (1 === height) {\n        height = DEFAULT_BAR_TRACKER_SIZE;\n        y -= CORRECTING_BAR_TRACKER_VALUE;\n      }\n    }\n\n    return {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    };\n  },\n  getGraphicSettings: function () {\n    var graphic = this.graphic;\n    return {\n      x: graphic.attr(\"x\"),\n      y: graphic.attr(\"y\"),\n      height: graphic.attr(\"height\"),\n      width: graphic.attr(\"width\")\n    };\n  },\n  _getEdgeTooltipParams: function () {\n    var isPositive = this.value >= 0;\n    var xCoord;\n    var yCoord;\n\n    var invertedBusinessRange = this._getValTranslator().getBusinessRange().invert;\n\n    var x = this.x,\n        y = this.y,\n        width = this.width,\n        height = this.height;\n\n    if (this._options.rotated) {\n      yCoord = y + height / 2;\n\n      if (invertedBusinessRange) {\n        xCoord = isPositive ? x : x + width;\n      } else {\n        xCoord = isPositive ? x + width : x;\n      }\n    } else {\n      xCoord = x + width / 2;\n\n      if (invertedBusinessRange) {\n        yCoord = isPositive ? y + height : y;\n      } else {\n        yCoord = isPositive ? y : y + height;\n      }\n    }\n\n    return {\n      x: xCoord,\n      y: yCoord,\n      offset: 0\n    };\n  },\n  getTooltipParams: function (location) {\n    if (\"edge\" === location) {\n      return this._getEdgeTooltipParams();\n    }\n\n    var center = this.getCenterCoord();\n    center.offset = 0;\n    return center;\n  },\n  getCenterCoord: function () {\n    var width = this.width,\n        height = this.height,\n        x = this.x,\n        y = this.y;\n    return {\n      x: x + width / 2,\n      y: y + height / 2\n    };\n  },\n  _truncateCoord: function (coord, bounds) {\n    if (null === coord) {\n      return coord;\n    }\n\n    if (coord < bounds[0]) {\n      return bounds[0];\n    }\n\n    if (coord > bounds[1]) {\n      return bounds[1];\n    }\n\n    return coord;\n  },\n  _getErrorBarBaseEdgeLength: function () {\n    return this._options.rotated ? this.height : this.width;\n  },\n  _translateErrorBars: function (argVisibleArea) {\n    symbolPoint._translateErrorBars.call(this);\n\n    if (this._errorBarPos < argVisibleArea[0] || this._errorBarPos > argVisibleArea[1]) {\n      this._errorBarPos = void 0;\n    }\n  },\n  _translate: function () {\n    var that = this;\n    var rotated = that._options.rotated;\n    var valAxis = rotated ? \"x\" : \"y\";\n    var argAxis = rotated ? \"y\" : \"x\";\n    var valIntervalName = rotated ? \"width\" : \"height\";\n    var argIntervalName = rotated ? \"height\" : \"width\";\n\n    var argTranslator = that._getArgTranslator();\n\n    var valTranslator = that._getValTranslator();\n\n    var argVisibleArea = that.series.getArgumentAxis().getVisibleArea();\n    var valVisibleArea = that.series.getValueAxis().getVisibleArea();\n    var arg;\n    var val;\n    var minVal;\n    arg = argTranslator.translate(that.argument);\n    that[argAxis] = arg = null === arg ? arg : arg + (that[argAxis + \"Correction\"] || 0);\n    val = valTranslator.translate(that.value, 1);\n    minVal = valTranslator.translate(that.minValue);\n    that[\"v\" + valAxis] = val;\n    that[\"v\" + argAxis] = arg + that[argIntervalName] / 2;\n    val = that._truncateCoord(val, valVisibleArea);\n    minVal = that._truncateCoord(minVal, valVisibleArea);\n    that[valIntervalName] = _abs(val - minVal);\n    val = val < minVal ? val : minVal;\n\n    that._calculateVisibility(rotated ? val : arg, rotated ? arg : val, that.width, that.height);\n\n    that[valAxis] = null === val ? val : val + (that[valAxis + \"Correction\"] || 0);\n    that[\"min\" + valAxis.toUpperCase()] = null === minVal ? minVal : minVal + (that[valAxis + \"Correction\"] || 0);\n    that[\"default\" + valAxis.toUpperCase()] = valTranslator.translate(CANVAS_POSITION_DEFAULT);\n\n    that._translateErrorBars(argVisibleArea);\n\n    if (that.inVisibleArea && null !== that[argAxis]) {\n      if (that[argAxis] < argVisibleArea[0]) {\n        that[argIntervalName] = that[argIntervalName] - (argVisibleArea[0] - that[argAxis]);\n        that[argAxis] = argVisibleArea[0];\n      }\n\n      if (that[argAxis] + that[argIntervalName] > argVisibleArea[1]) {\n        that[argIntervalName] = argVisibleArea[1] - that[argAxis];\n      }\n    }\n  },\n  _updateMarker: function (animationEnabled, style) {\n    this.graphic.smartAttr(_extend({}, style, !animationEnabled ? this.getMarkerCoords() : {}));\n  },\n  getMarkerCoords: function () {\n    var that = this;\n    var x = that.x;\n    var y = that.y;\n    var width = that.width;\n    var height = that.height;\n    var argAxis = that.series.getArgumentAxis();\n    var rotated = that._options.rotated;\n\n    if (argAxis.getAxisPosition) {\n      var axisOptions = argAxis.getOptions();\n      var edgeOffset = Math.round(axisOptions.width / 2);\n      var argAxisPosition = argAxis.getAxisPosition();\n\n      if (axisOptions.visible) {\n        if (!rotated) {\n          height -= that.minY === that.defaultY && that.minY === argAxisPosition - argAxis.getAxisShift() ? edgeOffset : 0;\n          height < 0 && (height = 0);\n        } else {\n          var isStartFromAxis = that.minX === that.defaultX && that.minX === argAxisPosition - argAxis.getAxisShift();\n          x += isStartFromAxis ? edgeOffset : 0;\n          width -= isStartFromAxis ? edgeOffset : 0;\n          width < 0 && (width = 0);\n        }\n      }\n    }\n\n    return {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    };\n  },\n  coordsIn: function (x, y) {\n    var that = this;\n    return x >= that.x && x <= that.x + that.width && y >= that.y && y <= that.y + that.height;\n  }\n});","map":null,"metadata":{},"sourceType":"script"}