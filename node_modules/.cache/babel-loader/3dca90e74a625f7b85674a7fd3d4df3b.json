{"ast":null,"code":"/**\r\n * DevExtreme (viz/series/area_series.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar objectUtils = require(\"../../core/utils/object\");\n\nvar extend = require(\"../../core/utils/extend\").extend;\n\nvar scatterSeries = require(\"./scatter_series\").chart;\n\nvar lineSeries = require(\"./line_series\");\n\nvar chartLineSeries = lineSeries.chart.line;\nvar polarLineSeries = lineSeries.polar.line;\n\nvar _map = require(\"../core/utils\").map;\n\nvar _extend = extend;\nvar calculateBezierPoints = lineSeries.chart.spline._calculateBezierPoints;\nexports.chart = {};\nexports.polar = {};\nvar baseAreaMethods = {\n  _createBorderElement: chartLineSeries._createMainElement,\n  _createLegendState: function (styleOptions, defaultColor) {\n    return {\n      fill: styleOptions.color || defaultColor,\n      opacity: styleOptions.opacity,\n      hatching: styleOptions.hatching\n    };\n  },\n  getValueRangeInitialValue: function () {\n    if (\"logarithmic\" !== this.valueAxisType && \"datetime\" !== this.valueType && false !== this.showZero) {\n      return 0;\n    } else {\n      return scatterSeries.getValueRangeInitialValue.call(this);\n    }\n  },\n  _getDefaultSegment: function (segment) {\n    var defaultSegment = chartLineSeries._getDefaultSegment(segment);\n\n    defaultSegment.area = defaultSegment.line.concat(defaultSegment.line.slice().reverse());\n    return defaultSegment;\n  },\n  _updateElement: function (element, segment, animate, complete) {\n    var lineParams = {\n      points: segment.line\n    };\n    var areaParams = {\n      points: segment.area\n    };\n    var borderElement = element.line;\n\n    if (animate) {\n      borderElement && borderElement.animate(lineParams);\n      element.area.animate(areaParams, {}, complete);\n    } else {\n      borderElement && borderElement.attr(lineParams);\n      element.area.attr(areaParams);\n    }\n  },\n  _removeElement: function (element) {\n    element.line && element.line.remove();\n    element.area.remove();\n  },\n  _drawElement: function (segment) {\n    return {\n      line: this._bordersGroup && this._createBorderElement(segment.line, {\n        \"stroke-width\": this._styles.normal.border[\"stroke-width\"]\n      }).append(this._bordersGroup),\n      area: this._createMainElement(segment.area).append(this._elementsGroup)\n    };\n  },\n  _applyStyle: function (style) {\n    var that = this;\n    that._elementsGroup && that._elementsGroup.smartAttr(style.elements);\n    that._bordersGroup && that._bordersGroup.attr(style.border);\n    (that._graphics || []).forEach(function (graphic) {\n      graphic.line && graphic.line.attr({\n        \"stroke-width\": style.border[\"stroke-width\"]\n      }).sharp();\n    });\n  },\n  _parseStyle: function (options, defaultColor, defaultBorderColor) {\n    var borderOptions = options.border || {};\n\n    var borderStyle = chartLineSeries._parseLineOptions(borderOptions, defaultBorderColor);\n\n    borderStyle.stroke = borderOptions.visible && borderStyle[\"stroke-width\"] ? borderStyle.stroke : \"none\";\n    borderStyle[\"stroke-width\"] = borderStyle[\"stroke-width\"] || 1;\n    return {\n      border: borderStyle,\n      elements: {\n        stroke: \"none\",\n        fill: options.color || defaultColor,\n        hatching: options.hatching,\n        opacity: options.opacity\n      }\n    };\n  },\n  _areBordersVisible: function () {\n    var options = this._options;\n    return options.border.visible || options.hoverStyle.border.visible || options.selectionStyle.border.visible;\n  },\n  _createMainElement: function (points, settings) {\n    return this._renderer.path(points, \"area\").attr(settings);\n  },\n  _getTrackerSettings: function (segment) {\n    return {\n      \"stroke-width\": segment.singlePointSegment ? this._defaultTrackerWidth : 0\n    };\n  },\n  _getMainPointsFromSegment: function (segment) {\n    return segment.area;\n  }\n};\n\nfunction createAreaPoints(points) {\n  return _map(points, function (pt) {\n    return pt.getCoords();\n  }).concat(_map(points.slice().reverse(), function (pt) {\n    return pt.getCoords(true);\n  }));\n}\n\nvar areaSeries = exports.chart.area = _extend({}, chartLineSeries, baseAreaMethods, {\n  _prepareSegment: function (points, rotated) {\n    var that = this;\n\n    var processedPoints = that._processSinglePointsAreaSegment(points, rotated);\n\n    var areaPoints = createAreaPoints(processedPoints);\n    var argAxis = that.getArgumentAxis();\n\n    if (argAxis.getAxisPosition) {\n      var argAxisPosition = argAxis.getAxisPosition();\n      var axisOptions = argAxis.getOptions();\n      var edgeOffset = (!rotated ? -1 : 1) * Math.round(axisOptions.width / 2);\n\n      if (axisOptions.visible) {\n        areaPoints.forEach(function (p, i) {\n          if (p) {\n            var index = 1 === points.length ? 0 : i < points.length ? i : areaPoints.length - 1 - i;\n            rotated && p.x === points[index].defaultX && p.x === argAxisPosition - argAxis.getAxisShift() && (p.x += edgeOffset);\n            !rotated && p.y === points[index].defaultY && p.y === argAxisPosition - argAxis.getAxisShift() && (p.y += edgeOffset);\n          }\n        });\n      }\n    }\n\n    return {\n      line: processedPoints,\n      area: areaPoints,\n      singlePointSegment: processedPoints !== points\n    };\n  },\n  _processSinglePointsAreaSegment: function (points, rotated) {\n    if (points && 1 === points.length) {\n      var p = points[0];\n      var p1 = objectUtils.clone(p);\n      p1[rotated ? \"y\" : \"x\"] += 1;\n      p1.argument = null;\n      return [p, p1];\n    }\n\n    return points;\n  }\n});\n\nexports.polar.area = _extend({}, polarLineSeries, baseAreaMethods, {\n  _prepareSegment: function (points, rotated, lastSegment) {\n    lastSegment && polarLineSeries._closeSegment.call(this, points);\n    return areaSeries._prepareSegment.call(this, points);\n  },\n  _processSinglePointsAreaSegment: function (points) {\n    return lineSeries.polar.line._prepareSegment.call(this, points).line;\n  }\n});\nexports.chart.steparea = _extend({}, areaSeries, {\n  _prepareSegment: function (points, rotated) {\n    var stepLineSeries = lineSeries.chart.stepline;\n    points = areaSeries._processSinglePointsAreaSegment(points, rotated);\n    return areaSeries._prepareSegment.call(this, stepLineSeries._calculateStepLinePoints.call(this, points), rotated);\n  },\n  getSeriesPairCoord: lineSeries.chart.stepline.getSeriesPairCoord\n});\nexports.chart.splinearea = _extend({}, areaSeries, {\n  _areaPointsToSplineAreaPoints: function (areaPoints) {\n    var previousMiddlePoint = areaPoints[areaPoints.length / 2 - 1];\n    var middlePoint = areaPoints[areaPoints.length / 2];\n    areaPoints.splice(areaPoints.length / 2, 0, {\n      x: previousMiddlePoint.x,\n      y: previousMiddlePoint.y\n    }, {\n      x: middlePoint.x,\n      y: middlePoint.y\n    });\n  },\n  _prepareSegment: function (points, rotated) {\n    var processedPoints = areaSeries._processSinglePointsAreaSegment(points, rotated);\n\n    var areaSegment = areaSeries._prepareSegment.call(this, calculateBezierPoints(processedPoints, rotated));\n\n    this._areaPointsToSplineAreaPoints(areaSegment.area);\n\n    areaSegment.singlePointSegment = processedPoints !== points;\n    return areaSegment;\n  },\n  _getDefaultSegment: function (segment) {\n    var areaDefaultSegment = areaSeries._getDefaultSegment(segment);\n\n    this._areaPointsToSplineAreaPoints(areaDefaultSegment.area);\n\n    return areaDefaultSegment;\n  },\n  _createMainElement: function (points, settings) {\n    return this._renderer.path(points, \"bezierarea\").attr(settings);\n  },\n  _createBorderElement: lineSeries.chart.spline._createMainElement,\n  getSeriesPairCoord: lineSeries.chart.spline.getSeriesPairCoord,\n  getNearestPointsByCoord: lineSeries.chart.spline.getNearestPointsByCoord,\n  obtainCubicBezierTCoef: lineSeries.chart.spline.obtainCubicBezierTCoef\n});","map":null,"metadata":{},"sourceType":"script"}