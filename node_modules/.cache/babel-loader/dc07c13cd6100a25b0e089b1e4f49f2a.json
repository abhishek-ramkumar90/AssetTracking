{"ast":null,"code":"/**\r\n * DevExtreme (localization/ldml/date.format.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _number = require(\"../number\");\n\nvar _number2 = _interopRequireDefault(_number);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar ARABIC_COMMA = \"\\u060c\";\nvar FORMAT_SEPARATORS = \" .,:;/\\\\<>()-[]\" + ARABIC_COMMA;\nvar AM_PM_PATTERN = \". m.\";\n\nvar checkDigit = function (char) {\n  var code = char && _number2.default.convertDigits(char, false).charCodeAt(0);\n\n  var zeroCode = _number2.default.convertDigits(\"0\", false).charCodeAt(0);\n\n  return zeroCode <= code && code < zeroCode + 10;\n};\n\nvar checkPatternContinue = function (text, index, isDigit) {\n  var char = text[index];\n  var nextChar = text[index + 1];\n\n  if (!isDigit) {\n    if (\".\" === char || \" \" === char && text.slice(index - 1, index + 3) === AM_PM_PATTERN) {\n      return true;\n    }\n\n    if (\"-\" === char && !checkDigit(nextChar)) {\n      return true;\n    }\n  }\n\n  return FORMAT_SEPARATORS.indexOf(char) < 0 && isDigit === checkDigit(char);\n};\n\nvar getPatternStartIndex = function (defaultPattern, index) {\n  if (!checkDigit(defaultPattern[index])) {\n    while (index > 0 && !checkDigit(defaultPattern[index - 1]) && (\".\" === defaultPattern[index - 1] || FORMAT_SEPARATORS.indexOf(defaultPattern[index - 1]) < 0)) {\n      index--;\n    }\n  }\n\n  return index;\n};\n\nvar getDifference = function (defaultPattern, patterns, processedIndexes, isDigit) {\n  var i = 0;\n  var result = [];\n\n  var patternsFilter = function (pattern) {\n    return defaultPattern[i] !== pattern[i] && (void 0 === isDigit || checkDigit(defaultPattern[i]) === isDigit);\n  };\n\n  if (!Array.isArray(patterns)) {\n    patterns = [patterns];\n  }\n\n  for (i = 0; i < defaultPattern.length; i++) {\n    if (processedIndexes.indexOf(i) < 0 && patterns.filter(patternsFilter).length) {\n      i = getPatternStartIndex(defaultPattern, i);\n\n      do {\n        isDigit = checkDigit(defaultPattern[i]);\n\n        if (!result.length && !isDigit && checkDigit(patterns[0][i])) {\n          break;\n        }\n\n        result.push(i);\n        processedIndexes.unshift(i);\n        i++;\n      } while (defaultPattern[i] && checkPatternContinue(defaultPattern, i, isDigit));\n\n      break;\n    }\n  }\n\n  if (1 === result.length && (\"0\" === defaultPattern[processedIndexes[0] - 1] || \"\\u0660\" === defaultPattern[processedIndexes[0] - 1])) {\n    processedIndexes.unshift(processedIndexes[0] - 1);\n  }\n\n  return result;\n};\n\nvar replaceCharsCore = function (pattern, indexes, char, patternPositions) {\n  var baseCharIndex = indexes[0];\n  var patternIndex = baseCharIndex < patternPositions.length ? patternPositions[baseCharIndex] : baseCharIndex;\n  indexes.forEach(function (_, index) {\n    pattern = pattern.substr(0, patternIndex + index) + (char.length > 1 ? char[index] : char) + pattern.substr(patternIndex + index + 1);\n  });\n\n  if (1 === indexes.length) {\n    pattern = pattern.replace(\"0\" + char, char + char);\n    pattern = pattern.replace(\"\\u0660\" + char, char + char);\n  }\n\n  return pattern;\n};\n\nvar replaceChars = function (pattern, indexes, char, patternPositions) {\n  var i;\n  var index;\n  var patternIndex;\n\n  if (!checkDigit(pattern[indexes[0]] || \"0\")) {\n    var letterCount = Math.max(indexes.length <= 3 ? 3 : 4, char.length);\n\n    while (indexes.length > letterCount) {\n      index = indexes.pop();\n      patternIndex = patternPositions[index];\n      patternPositions[index] = -1;\n\n      for (i = index + 1; i < patternPositions.length; i++) {\n        patternPositions[i]--;\n      }\n\n      pattern = pattern.substr(0, patternIndex) + pattern.substr(patternIndex + 1);\n    }\n\n    index = indexes[indexes.length - 1] + 1, patternIndex = index < patternPositions.length ? patternPositions[index] : index;\n\n    while (indexes.length < letterCount) {\n      indexes.push(indexes[indexes.length - 1] + 1);\n\n      for (i = index; i < patternPositions.length; i++) {\n        patternPositions[i]++;\n      }\n\n      pattern = pattern.substr(0, patternIndex) + \" \" + pattern.substr(patternIndex);\n    }\n  }\n\n  pattern = replaceCharsCore(pattern, indexes, char, patternPositions);\n  return pattern;\n};\n\nvar formatValue = function (value, formatter) {\n  if (Array.isArray(value)) {\n    return value.map(function (value) {\n      return (formatter(value) || \"\").toString();\n    });\n  }\n\n  return (formatter(value) || \"\").toString();\n};\n\nvar ESCAPE_CHARS_REGEXP = /[a-zA-Z]/g;\n\nvar escapeChars = function (pattern, defaultPattern, processedIndexes, patternPositions) {\n  var escapeIndexes = defaultPattern.split(\"\").map(function (char, index) {\n    if (processedIndexes.indexOf(index) < 0 && (char.match(ESCAPE_CHARS_REGEXP) || \"'\" === char)) {\n      return patternPositions[index];\n    }\n\n    return -1;\n  });\n  pattern = pattern.split(\"\").map(function (char, index) {\n    var result = char;\n    var isCurrentCharEscaped = escapeIndexes.indexOf(index) >= 0;\n    var isPrevCharEscaped = index > 0 && escapeIndexes.indexOf(index - 1) >= 0;\n    var isNextCharEscaped = escapeIndexes.indexOf(index + 1) >= 0;\n\n    if (isCurrentCharEscaped) {\n      if (!isPrevCharEscaped) {\n        result = \"'\" + result;\n      }\n\n      if (!isNextCharEscaped) {\n        result += \"'\";\n      }\n    }\n\n    return result;\n  }).join(\"\");\n  return pattern;\n};\n\nvar getFormat = function (formatter) {\n  var processedIndexes = [];\n  var defaultPattern = formatValue(new Date(2009, 8, 8, 6, 5, 4), formatter);\n  var patternPositions = defaultPattern.split(\"\").map(function (_, index) {\n    return index;\n  });\n  var result = defaultPattern;\n  var replacedPatterns = {};\n  var datePatterns = [{\n    date: new Date(2009, 8, 8, 6, 5, 4, 100),\n    pattern: \"S\"\n  }, {\n    date: new Date(2009, 8, 8, 6, 5, 2),\n    pattern: \"s\"\n  }, {\n    date: new Date(2009, 8, 8, 6, 2, 4),\n    pattern: \"m\"\n  }, {\n    date: new Date(2009, 8, 8, 18, 5, 4),\n    pattern: \"H\",\n    isDigit: true\n  }, {\n    date: new Date(2009, 8, 8, 2, 5, 4),\n    pattern: \"h\",\n    isDigit: true\n  }, {\n    date: new Date(2009, 8, 8, 18, 5, 4),\n    pattern: \"a\",\n    isDigit: false\n  }, {\n    date: new Date(2009, 8, 1, 6, 5, 4),\n    pattern: \"d\"\n  }, {\n    date: [new Date(2009, 8, 2, 6, 5, 4), new Date(2009, 8, 3, 6, 5, 4), new Date(2009, 8, 4, 6, 5, 4)],\n    pattern: \"E\"\n  }, {\n    date: new Date(2009, 9, 6, 6, 5, 4),\n    pattern: \"M\"\n  }, {\n    date: new Date(1998, 8, 8, 6, 5, 4),\n    pattern: \"y\"\n  }];\n\n  if (!result) {\n    return;\n  }\n\n  datePatterns.forEach(function (test) {\n    var diff = getDifference(defaultPattern, formatValue(test.date, formatter), processedIndexes, test.isDigit);\n    var pattern = \"M\" === test.pattern && !replacedPatterns.d ? \"L\" : test.pattern;\n    result = replaceChars(result, diff, pattern, patternPositions);\n    replacedPatterns[pattern] = diff.length;\n  });\n  result = escapeChars(result, defaultPattern, processedIndexes, patternPositions);\n\n  if (processedIndexes.length) {\n    return result;\n  }\n};\n\nexports.getFormat = getFormat;","map":null,"metadata":{},"sourceType":"script"}