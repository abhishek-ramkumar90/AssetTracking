{"ast":null,"code":"/**\r\n * DevExtreme (exporter/image_creator.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _renderer = require(\"../core/renderer\");\n\nvar _renderer2 = _interopRequireDefault(_renderer);\n\nvar _color = require(\"../color\");\n\nvar _color2 = _interopRequireDefault(_color);\n\nvar _type = require(\"../core/utils/type\");\n\nvar _svg = require(\"../core/utils/svg\");\n\nvar _svg2 = _interopRequireDefault(_svg);\n\nvar _iterator = require(\"../core/utils/iterator\");\n\nvar _extend = require(\"../core/utils/extend\");\n\nvar _dom_adapter = require(\"../core/dom_adapter\");\n\nvar _dom_adapter2 = _interopRequireDefault(_dom_adapter);\n\nvar _dom = require(\"../core/utils/dom\");\n\nvar _dom2 = _interopRequireDefault(_dom);\n\nvar _window = require(\"../core/utils/window\");\n\nvar _window2 = _interopRequireDefault(_window);\n\nvar _inflector = require(\"../core/utils/inflector\");\n\nvar _deferred = require(\"../core/utils/deferred\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar window = _window2.default.getWindow();\n\nvar _math = Math;\nvar PI = _math.PI;\nvar _min = _math.min;\nvar _abs = _math.abs;\nvar _sqrt = _math.sqrt;\nvar _pow = _math.pow;\nvar _atan2 = _math.atan2;\nvar _cos = _math.cos;\nvar _sin = _math.sin;\nvar _number = Number;\nvar IMAGE_QUALITY = 1;\nvar TEXT_DECORATION_LINE_WIDTH_COEFF = .05;\nvar DEFAULT_FONT_SIZE = \"10px\";\nvar DEFAULT_FONT_FAMILY = \"sans-serif\";\nvar DEFAULT_TEXT_COLOR = \"#000\";\n\nfunction createCanvas(width, height, margin) {\n  var canvas = (0, _renderer2.default)(\"<canvas>\")[0];\n  canvas.width = width + 2 * margin;\n  canvas.height = height + 2 * margin;\n  canvas.hidden = true;\n  return canvas;\n}\n\nfunction getStringFromCanvas(canvas, mimeType) {\n  var dataURL = canvas.toDataURL(mimeType, IMAGE_QUALITY);\n  var imageData = window.atob(dataURL.substring((\"data:\" + mimeType + \";base64,\").length));\n  return imageData;\n}\n\nfunction arcTo(x1, y1, x2, y2, radius, largeArcFlag, clockwise, context) {\n  var cBx = (x1 + x2) / 2;\n  var cBy = (y1 + y2) / 2;\n\n  var aB = _atan2(y1 - y2, x1 - x2);\n\n  var k = largeArcFlag ? 1 : -1;\n  var opSide;\n  var adjSide;\n  var centerX;\n  var centerY;\n  var startAngle;\n  var endAngle;\n  aB += 90 * (PI / 180) * (clockwise ? 1 : -1);\n  opSide = _sqrt(_pow(x2 - x1, 2) + _pow(y2 - y1, 2)) / 2;\n  adjSide = _sqrt(_abs(_pow(radius, 2) - _pow(opSide, 2)));\n  centerX = cBx + k * (adjSide * _cos(aB));\n  centerY = cBy + k * (adjSide * _sin(aB));\n  startAngle = _atan2(y1 - centerY, x1 - centerX);\n  endAngle = _atan2(y2 - centerY, x2 - centerX);\n  context.arc(centerX, centerY, radius, startAngle, endAngle, !clockwise);\n}\n\nfunction getElementOptions(element, rootAppended) {\n  var attr = parseAttributes(element.attributes || {});\n  var options = (0, _extend.extend)({}, attr, {\n    text: element.textContent.replace(/\\s+/g, \" \"),\n    textAlign: \"middle\" === attr[\"text-anchor\"] ? \"center\" : attr[\"text-anchor\"]\n  });\n  var transform = attr.transform;\n  var coords;\n\n  if (transform) {\n    coords = transform.match(/translate\\(-*\\d+([.]\\d+)*(,*\\s*-*\\d+([.]\\d+)*)*/);\n\n    if (coords) {\n      coords = coords[0].match(/-*\\d+([.]\\d+)*/g);\n      options.translateX = _number(coords[0]);\n      options.translateY = coords[1] ? _number(coords[1]) : 0;\n    }\n\n    coords = transform.match(/rotate\\(-*\\d+([.]\\d+)*(,*\\s*-*\\d+([.]\\d+)*,*\\s*-*\\d+([.]\\d+)*)*/);\n\n    if (coords) {\n      coords = coords[0].match(/-*\\d+([.]\\d+)*/g);\n      options.rotationAngle = _number(coords[0]);\n      options.rotationX = coords[1] && _number(coords[1]);\n      options.rotationY = coords[2] && _number(coords[2]);\n    }\n\n    coords = transform.match(/scale\\(-*\\d+([.]\\d+)*(,*\\s*-*\\d+([.]\\d+)*)*/);\n\n    if (coords) {\n      coords = coords[0].match(/-*\\d+([.]\\d+)*/g);\n      options.scaleX = _number(coords[0]);\n\n      if (coords.length > 1) {\n        options.scaleY = _number(coords[1]);\n      } else {\n        options.scaleY = options.scaleX;\n      }\n    }\n  }\n\n  parseStyles(element, options, rootAppended);\n  return options;\n}\n\nfunction drawRect(context, options) {\n  var x = options.x;\n  var y = options.y;\n  var width = options.width;\n  var height = options.height;\n  var cornerRadius = options.rx;\n\n  if (!cornerRadius) {\n    context.rect(x, y, width, height);\n  } else {\n    cornerRadius = _min(cornerRadius, width / 2, height / 2);\n    context.save();\n    context.translate(x, y);\n    context.moveTo(width / 2, 0);\n    context.arcTo(width, 0, width, height, cornerRadius);\n    context.arcTo(width, height, 0, height, cornerRadius);\n    context.arcTo(0, height, 0, 0, cornerRadius);\n    context.arcTo(0, 0, cornerRadius, 0, cornerRadius);\n    context.lineTo(width / 2, 0);\n    context.restore();\n  }\n}\n\nfunction drawImage(context, options, shared) {\n  var d = new _deferred.Deferred();\n  var image = new window.Image();\n\n  image.onload = function () {\n    context.save();\n    context.globalAlpha = options.globalAlpha;\n    transformElement(context, options);\n    clipElement(context, options, shared);\n    context.drawImage(image, options.x, options.y, options.width, options.height);\n    context.restore();\n    d.resolve();\n  };\n\n  image.onerror = function () {\n    d.resolve();\n  };\n\n  image.setAttribute(\"crossOrigin\", \"anonymous\");\n  image.src = options.href || options[\"xlink:href\"];\n  return d;\n}\n\nfunction drawPath(context, dAttr) {\n  var dArray = dAttr.replace(/,/g, \" \").split(/([A-Z])/i).filter(function (item) {\n    return \"\" !== item.trim();\n  });\n  var i = 0;\n  var params;\n  var prevParams;\n  var prevParamsLen;\n\n  do {\n    params = (dArray[i + 1] || \"\").trim().split(\" \");\n\n    switch (dArray[i]) {\n      case \"M\":\n        context.moveTo(_number(params[0]), _number(params[1]));\n        i += 2;\n        break;\n\n      case \"L\":\n        for (var j = 0; j < params.length / 2; j++) {\n          context.lineTo(_number(params[2 * j]), _number(params[2 * j + 1]));\n        }\n\n        i += 2;\n        break;\n\n      case \"C\":\n        context.bezierCurveTo(_number(params[0]), _number(params[1]), _number(params[2]), _number(params[3]), _number(params[4]), _number(params[5]));\n        i += 2;\n        break;\n\n      case \"a\":\n        prevParams = dArray[i - 1].trim().split(\" \");\n        prevParamsLen = prevParams.length - 1;\n        arcTo(_number(prevParams[prevParamsLen - 1]), _number(prevParams[prevParamsLen]), _number(prevParams[prevParamsLen - 1]) + _number(params[5]), _number(prevParams[prevParamsLen]) + _number(params[6]), _number(params[0]), _number(params[3]), _number(params[4]), context);\n        i += 2;\n        break;\n\n      case \"A\":\n        prevParams = dArray[i - 1].trim().split(\" \");\n        prevParamsLen = prevParams.length - 1;\n        arcTo(_number(prevParams[prevParamsLen - 1]), _number(prevParams[prevParamsLen]), _number(params[5]), _number(params[6]), _number(params[0]), _number(params[3]), _number(params[4]), context);\n        i += 2;\n        break;\n\n      case \"Z\":\n        context.closePath();\n        i += 1;\n        break;\n\n      default:\n        i++;\n    }\n  } while (i < dArray.length);\n}\n\nfunction parseStyles(element, options, rootAppended) {\n  var style = element.style || {};\n  var field;\n\n  for (field in style) {\n    if (\"\" !== style[field]) {\n      options[(0, _inflector.camelize)(field)] = style[field];\n    }\n  }\n\n  if (rootAppended && _dom_adapter2.default.isElementNode(element)) {\n    style = window.getComputedStyle(element);\n    [\"fill\", \"stroke\", \"stroke-width\", \"font-family\", \"font-size\", \"font-style\", \"font-weight\"].forEach(function (prop) {\n      if (prop in style && \"\" !== style[prop]) {\n        options[(0, _inflector.camelize)(prop)] = style[prop];\n      }\n    });\n    [\"opacity\", \"fill-opacity\", \"stroke-opacity\"].forEach(function (prop) {\n      if (prop in style && \"\" !== style[prop] && \"1\" !== style[prop]) {\n        options[prop] = _number(style[prop]);\n      }\n    });\n  }\n\n  options.textDecoration = options.textDecoration || options.textDecorationLine;\n  options.globalAlpha = (0, _type.isDefined)(options.opacity) ? options.opacity : options.globalAlpha;\n}\n\nfunction parseUrl(urlString) {\n  var matches = urlString && urlString.match(/url\\(.*#(.*?)[\"']?\\)/i);\n  return matches && matches[1];\n}\n\nfunction setFontStyle(context, options) {\n  var fontParams = [];\n  options.fontSize = options.fontSize || DEFAULT_FONT_SIZE;\n  options.fontFamily || DEFAULT_FONT_FAMILY;\n  options.fill = options.fill || DEFAULT_TEXT_COLOR;\n  options.fontStyle && fontParams.push(options.fontStyle);\n  options.fontWeight && fontParams.push(options.fontWeight);\n  fontParams.push(options.fontSize);\n  fontParams.push(options.fontFamily);\n  context.font = fontParams.join(\" \");\n  context.textAlign = options.textAlign;\n  context.fillStyle = options.fill;\n  context.globalAlpha = options.globalAlpha;\n}\n\nfunction drawText(context, options, shared) {\n  setFontStyle(context, options);\n  applyFilter(context, options, shared);\n  options.text && context.fillText(options.text, options.x || 0, options.y || 0);\n  strokeElement(context, options, true);\n  drawTextDecoration(context, options, shared);\n}\n\nfunction drawTextDecoration(context, options, shared) {\n  if (!options.textDecoration || \"none\" === options.textDecoration) {\n    return;\n  }\n\n  var x = options.x;\n  var textWidth = context.measureText(options.text).width;\n  var textHeight = parseInt(options.fontSize, 10);\n  var lineHeight = textHeight * TEXT_DECORATION_LINE_WIDTH_COEFF < 1 ? 1 : textHeight * TEXT_DECORATION_LINE_WIDTH_COEFF;\n  var y = options.y;\n\n  switch (options.textDecoration) {\n    case \"line-through\":\n      y -= textHeight / 3 + lineHeight / 2;\n      break;\n\n    case \"overline\":\n      y -= textHeight - lineHeight;\n      break;\n\n    case \"underline\":\n      y += lineHeight;\n  }\n\n  context.rect(x, y, textWidth, lineHeight);\n  fillElement(context, options, shared);\n  strokeElement(context, options);\n}\n\nfunction aggregateOpacity(options) {\n  options.strokeOpacity = void 0 !== options[\"stroke-opacity\"] ? options[\"stroke-opacity\"] : 1;\n  options.fillOpacity = void 0 !== options[\"fill-opacity\"] ? options[\"fill-opacity\"] : 1;\n\n  if (void 0 !== options.opacity) {\n    options.strokeOpacity *= options.opacity;\n    options.fillOpacity *= options.opacity;\n  }\n}\n\nfunction hasTspan(element) {\n  var nodes = element.childNodes;\n\n  for (var i = 0; i < nodes.length; i++) {\n    if (\"tspan\" === nodes[i].tagName) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction drawTextElement(childNodes, context, options, shared) {\n  var lines = [];\n  var line;\n  var offset = 0;\n\n  for (var i = 0; i < childNodes.length; i++) {\n    var element = childNodes[i];\n\n    if (void 0 === element.tagName) {\n      drawElement(element, context, options, shared);\n    } else {\n      if (\"tspan\" === element.tagName || \"text\" === element.tagName) {\n        var elementOptions = getElementOptions(element, shared.rootAppended);\n        var mergedOptions = (0, _extend.extend)({}, options, elementOptions);\n\n        if (\"tspan\" === element.tagName && hasTspan(element)) {\n          drawTextElement(element.childNodes, context, mergedOptions, shared);\n          continue;\n        }\n\n        mergedOptions.textAlign = \"start\";\n\n        if (!line || void 0 !== elementOptions.x) {\n          line = {\n            elements: [],\n            options: [],\n            widths: [],\n            offsets: []\n          };\n          lines.push(line);\n        }\n\n        if (void 0 !== elementOptions.y) {\n          offset = 0;\n        }\n\n        if (void 0 !== elementOptions.dy) {\n          offset += parseFloat(elementOptions.dy);\n        }\n\n        line.elements.push(element);\n        line.options.push(mergedOptions);\n        line.offsets.push(offset);\n        setFontStyle(context, mergedOptions);\n        line.widths.push(context.measureText(mergedOptions.text).width);\n      }\n    }\n  }\n\n  lines.forEach(function (line) {\n    var commonWidth = line.widths.reduce(function (commonWidth, width) {\n      return commonWidth + width;\n    }, 0);\n    var xDiff = 0;\n    var currentOffset = 0;\n\n    if (\"center\" === options.textAlign) {\n      xDiff = commonWidth / 2;\n    }\n\n    if (\"end\" === options.textAlign) {\n      xDiff = commonWidth;\n    }\n\n    line.options.forEach(function (o, index) {\n      var width = line.widths[index];\n      o.x = o.x - xDiff + currentOffset;\n      o.y += line.offsets[index];\n      currentOffset += width;\n    });\n    line.elements.forEach(function (element, index) {\n      drawTextElement(element.childNodes, context, line.options[index], shared);\n    });\n  });\n}\n\nfunction drawElement(element, context, parentOptions, shared) {\n  var tagName = element.tagName;\n  var isText = \"text\" === tagName || \"tspan\" === tagName || void 0 === tagName;\n  var isImage = \"image\" === tagName;\n  var options = (0, _extend.extend)({}, parentOptions, getElementOptions(element, shared.rootAppended));\n\n  if (\"hidden\" === options.visibility || options[\"hidden-for-export\"]) {\n    return;\n  }\n\n  context.save();\n  !isImage && transformElement(context, options);\n  clipElement(context, options, shared);\n  aggregateOpacity(options);\n  var promise;\n  context.beginPath();\n\n  switch (element.tagName) {\n    case void 0:\n      drawText(context, options, shared);\n      break;\n\n    case \"text\":\n    case \"tspan\":\n      drawTextElement(element.childNodes, context, options, shared);\n      break;\n\n    case \"image\":\n      promise = drawImage(context, options, shared);\n      break;\n\n    case \"path\":\n      drawPath(context, options.d);\n      break;\n\n    case \"rect\":\n      drawRect(context, options);\n      context.closePath();\n      break;\n\n    case \"circle\":\n      context.arc(options.cx, options.cy, options.r, 0, 2 * PI, 1);\n  }\n\n  if (!isText) {\n    applyFilter(context, options, shared);\n    fillElement(context, options, shared);\n    strokeElement(context, options);\n  }\n\n  applyGradient(context, options, shared, element);\n  context.restore();\n  return promise;\n}\n\nfunction applyGradient(context, options, _ref, element) {\n  var gradients = _ref.gradients;\n\n  if (0 === gradients.length) {\n    return;\n  }\n\n  var id = parseUrl(options.fill);\n\n  if (id && gradients[id]) {\n    var box = element.getBBox();\n    var gradient = context.createLinearGradient(box.x, 0, box.x + box.width, 0);\n    gradients[id].forEach(function (opt) {\n      var offset = parseInt(opt.offset.replace(/%/, \"\"));\n      gradient.addColorStop(offset / 100, opt.stopColor);\n    });\n    context.globalAlpha = options.opacity;\n    context.fillStyle = gradient;\n    context.fill();\n  }\n}\n\nfunction applyFilter(context, options, shared) {\n  var filterOptions;\n  var id = parseUrl(options.filter);\n\n  if (id) {\n    filterOptions = shared.filters[id];\n\n    if (!filterOptions) {\n      filterOptions = {\n        offsetX: 0,\n        offsetY: 0,\n        blur: 0,\n        color: \"#000\"\n      };\n    }\n\n    context.shadowOffsetX = filterOptions.offsetX;\n    context.shadowOffsetY = filterOptions.offsetY;\n    context.shadowColor = filterOptions.color;\n    context.shadowBlur = filterOptions.blur;\n  }\n}\n\nfunction transformElement(context, options) {\n  context.translate(options.translateX || 0, options.translateY || 0);\n  options.translateX = void 0;\n  options.translateY = void 0;\n\n  if (options.rotationAngle) {\n    context.translate(options.rotationX || 0, options.rotationY || 0);\n    context.rotate(options.rotationAngle * PI / 180);\n    context.translate(-(options.rotationX || 0), -(options.rotationY || 0));\n    options.rotationAngle = void 0;\n    options.rotationX = void 0;\n    options.rotationY = void 0;\n  }\n\n  if (isFinite(options.scaleX)) {\n    context.scale(options.scaleX, options.scaleY);\n    options.scaleX = void 0;\n    options.scaleY = void 0;\n  }\n}\n\nfunction clipElement(context, options, shared) {\n  if (options[\"clip-path\"]) {\n    drawElement(shared.clipPaths[parseUrl(options[\"clip-path\"])], context, {}, shared);\n    context.clip();\n    options[\"clip-path\"] = void 0;\n  }\n}\n\nfunction hex2rgba(hexColor, alpha) {\n  var color = new _color2.default(hexColor);\n  return \"rgba(\" + color.r + \",\" + color.g + \",\" + color.b + \",\" + alpha + \")\";\n}\n\nfunction createGradient(element) {\n  var options = [];\n  (0, _iterator.each)(element.childNodes, function (_, _ref2) {\n    var attributes = _ref2.attributes;\n    options.push({\n      offset: attributes.offset.value,\n      stopColor: attributes[\"stop-color\"].value\n    });\n  });\n  return options;\n}\n\nfunction createFilter(element) {\n  var color;\n  var opacity;\n  var filterOptions = {};\n  (0, _iterator.each)(element.childNodes, function (_, node) {\n    var attr = node.attributes;\n\n    if (!attr.result) {\n      return;\n    }\n\n    switch (attr.result.value) {\n      case \"gaussianBlurResult\":\n        filterOptions.blur = _number(attr.stdDeviation.value);\n        break;\n\n      case \"offsetResult\":\n        filterOptions.offsetX = _number(attr.dx.value);\n        filterOptions.offsetY = _number(attr.dy.value);\n        break;\n\n      case \"floodResult\":\n        color = attr[\"flood-color\"] ? attr[\"flood-color\"].value : \"#000\";\n        opacity = attr[\"flood-opacity\"] ? attr[\"flood-opacity\"].value : 1;\n        filterOptions.color = hex2rgba(color, opacity);\n    }\n  });\n  return filterOptions;\n}\n\nfunction asyncEach(array, callback) {\n  var d = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new _deferred.Deferred();\n\n  if (0 === array.length) {\n    return d.resolve();\n  }\n\n  var result = callback(array[0]);\n\n  function next() {\n    asyncEach(Array.prototype.slice.call(array, 1), callback, d);\n  }\n\n  if ((0, _type.isPromise)(result)) {\n    result.then(next);\n  } else {\n    next();\n  }\n\n  return d;\n}\n\nfunction drawCanvasElements(elements, context, parentOptions, shared) {\n  return asyncEach(elements, function (element) {\n    switch (element.tagName && element.tagName.toLowerCase()) {\n      case \"g\":\n      case \"svg\":\n        var options = (0, _extend.extend)({}, parentOptions, getElementOptions(element, shared.rootAppended));\n        context.save();\n        transformElement(context, options);\n        clipElement(context, options, shared);\n\n        var onDone = function () {\n          context.restore();\n        };\n\n        var d = drawCanvasElements(element.childNodes, context, options, shared);\n\n        if ((0, _type.isPromise)(d)) {\n          d.then(onDone);\n        } else {\n          onDone();\n        }\n\n        return d;\n\n      case \"defs\":\n        return drawCanvasElements(element.childNodes, context, {}, shared);\n\n      case \"clippath\":\n        shared.clipPaths[element.attributes.id.textContent] = element.childNodes[0];\n        break;\n\n      case \"pattern\":\n        shared.patterns[element.attributes.id.textContent] = element;\n        break;\n\n      case \"filter\":\n        shared.filters[element.id] = createFilter(element);\n        break;\n\n      case \"lineargradient\":\n        shared.gradients[element.attributes.id.textContent] = createGradient(element);\n        break;\n\n      default:\n        return drawElement(element, context, parentOptions, shared);\n    }\n  });\n}\n\nfunction setLineDash(context, options) {\n  var matches = options[\"stroke-dasharray\"] && options[\"stroke-dasharray\"].match(/(\\d+)/g);\n\n  if (matches && matches.length) {\n    matches = (0, _iterator.map)(matches, function (item) {\n      return _number(item);\n    });\n    context.setLineDash(matches);\n  }\n}\n\nfunction strokeElement(context, options, isText) {\n  var stroke = options.stroke;\n\n  if (stroke && \"none\" !== stroke && 0 !== options[\"stroke-width\"]) {\n    setLineDash(context, options);\n    context.lineJoin = options[\"stroke-linejoin\"];\n    context.lineWidth = options[\"stroke-width\"];\n    context.globalAlpha = options.strokeOpacity;\n    context.strokeStyle = stroke;\n    isText ? context.strokeText(options.text, options.x, options.y) : context.stroke();\n    context.globalAlpha = 1;\n  }\n}\n\nfunction getPattern(context, pattern, shared) {\n  var options = getElementOptions(pattern, shared.rootAppended);\n  var patternCanvas = createCanvas(options.width, options.height, 0);\n  var patternContext = patternCanvas.getContext(\"2d\");\n  drawCanvasElements(pattern.childNodes, patternContext, options, shared);\n  return context.createPattern(patternCanvas, \"repeat\");\n}\n\nfunction fillElement(context, options, shared) {\n  var fill = options.fill;\n\n  if (fill && \"none\" !== fill) {\n    if (fill.search(/url/) === -1) {\n      context.fillStyle = fill;\n    } else {\n      var pattern = shared.patterns[parseUrl(fill)];\n\n      if (!pattern) {\n        return;\n      }\n\n      context.fillStyle = getPattern(context, pattern, shared);\n    }\n\n    context.globalAlpha = options.fillOpacity;\n    context.fill();\n    context.globalAlpha = 1;\n  }\n}\n\nvar parseAttributes = function (attributes) {\n  var newAttributes = {};\n  var attr;\n  (0, _iterator.each)(attributes, function (index, item) {\n    attr = item.textContent;\n\n    if (isFinite(attr)) {\n      attr = _number(attr);\n    }\n\n    newAttributes[item.name.toLowerCase()] = attr;\n  });\n  return newAttributes;\n};\n\nfunction drawBackground(context, width, height, backgroundColor, margin) {\n  context.fillStyle = backgroundColor || \"#ffffff\";\n  context.fillRect(-margin, -margin, width + 2 * margin, height + 2 * margin);\n}\n\nfunction createInvisibleDiv() {\n  var invisibleDiv = _dom_adapter2.default.createElement(\"div\");\n\n  invisibleDiv.style.left = \"-9999px\";\n  invisibleDiv.style.position = \"absolute\";\n  return invisibleDiv;\n}\n\nfunction convertSvgToCanvas(svg, canvas, rootAppended) {\n  return drawCanvasElements(svg.childNodes, canvas.getContext(\"2d\"), {}, {\n    clipPaths: {},\n    patterns: {},\n    filters: {},\n    gradients: {},\n    rootAppended: rootAppended\n  });\n}\n\nfunction getCanvasFromSvg(markup, width, height, backgroundColor, margin) {\n  var svgToCanvas = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : convertSvgToCanvas;\n  var canvas = createCanvas(width, height, margin);\n  var context = canvas.getContext(\"2d\");\n\n  var svgElem = _svg2.default.getSvgElement(markup);\n\n  var invisibleDiv;\n\n  var markupIsDomElement = _dom_adapter2.default.isElementNode(markup);\n\n  context.translate(margin, margin);\n\n  _dom_adapter2.default.getBody().appendChild(canvas);\n\n  if (!markupIsDomElement) {\n    invisibleDiv = createInvisibleDiv();\n    invisibleDiv.appendChild(svgElem);\n\n    _dom_adapter2.default.getBody().appendChild(invisibleDiv);\n  }\n\n  if (svgElem.attributes.direction) {\n    canvas.dir = svgElem.attributes.direction.textContent;\n  }\n\n  drawBackground(context, width, height, backgroundColor, margin);\n  return (0, _deferred.fromPromise)(svgToCanvas(svgElem, canvas, markupIsDomElement && _dom2.default.contains(_dom_adapter2.default.getBody(), markup))).then(function () {\n    return canvas;\n  }).always(function () {\n    invisibleDiv && _dom_adapter2.default.getBody().removeChild(invisibleDiv);\n\n    _dom_adapter2.default.getBody().removeChild(canvas);\n  });\n}\n\nexports.imageCreator = {\n  getImageData: function (markup, options) {\n    var mimeType = \"image/\" + options.format;\n    var width = options.width;\n    var height = options.height;\n    var backgroundColor = options.backgroundColor;\n\n    if ((0, _type.isFunction)(options.__parseAttributesFn)) {\n      parseAttributes = options.__parseAttributesFn;\n    }\n\n    return getCanvasFromSvg(markup, width, height, backgroundColor, options.margin, options.svgToCanvas).then(function (canvas) {\n      return getStringFromCanvas(canvas, mimeType);\n    });\n  },\n  getData: function (markup, options) {\n    var that = this;\n    return exports.imageCreator.getImageData(markup, options).then(function (binaryData) {\n      var mimeType = \"image/\" + options.format;\n      var data = (0, _type.isFunction)(window.Blob) && !options.forceProxy ? that._getBlob(binaryData, mimeType) : that._getBase64(binaryData);\n      return data;\n    });\n  },\n  _getBlob: function (binaryData, mimeType) {\n    var i;\n    var dataArray = new Uint8Array(binaryData.length);\n\n    for (i = 0; i < binaryData.length; i++) {\n      dataArray[i] = binaryData.charCodeAt(i);\n    }\n\n    return new window.Blob([dataArray.buffer], {\n      type: mimeType\n    });\n  },\n  _getBase64: function (binaryData) {\n    return window.btoa(binaryData);\n  }\n};\n\nexports.getData = function (data, options) {\n  return exports.imageCreator.getData(data, options);\n};\n\nexports.testFormats = function (formats) {\n  var canvas = createCanvas(100, 100, 0);\n  return formats.reduce(function (r, f) {\n    var mimeType = (\"image/\" + f).toLowerCase();\n\n    if (canvas.toDataURL(mimeType).indexOf(mimeType) !== -1) {\n      r.supported.push(f);\n    } else {\n      r.unsupported.push(f);\n    }\n\n    return r;\n  }, {\n    supported: [],\n    unsupported: []\n  });\n};","map":null,"metadata":{},"sourceType":"script"}