{"ast":null,"code":"/**\r\n * DevExtreme (viz/series/pie_series.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar noop = require(\"../../core/utils/common\").noop;\n\nvar each = require(\"../../core/utils/iterator\").each;\n\nvar scatterSeries = require(\"./scatter_series\");\n\nvar vizUtils = require(\"../core/utils\");\n\nvar extend = require(\"../../core/utils/extend\").extend;\n\nvar chartScatterSeries = scatterSeries.chart;\n\nvar barSeries = require(\"./bar_series\").chart.bar;\n\nvar _extend = extend;\nvar _each = each;\nvar _noop = noop;\nvar _map = vizUtils.map;\nvar _isFinite = isFinite;\nvar _max = Math.max;\nvar ANIMATION_DURATION = .7;\nvar INSIDE = \"inside\";\nexports.pie = _extend({}, barSeries, {\n  _setGroupsSettings: function () {\n    chartScatterSeries._setGroupsSettings.apply(this, arguments);\n\n    this._labelsGroup.attr({\n      \"pointer-events\": null\n    });\n  },\n  _createErrorBarGroup: _noop,\n  _drawPoint: function (options) {\n    var point = options.point;\n    var legendCallback = this._legendCallback;\n\n    chartScatterSeries._drawPoint.call(this, options);\n\n    !point.isVisible() && point.setInvisibility();\n    point.isSelected() && legendCallback();\n  },\n  _getOldPoint: function (data, oldPointsByArgument, index) {\n    var point = (this._points || [])[index];\n\n    if (point) {\n      oldPointsByArgument[point.argument.valueOf()] = oldPointsByArgument[point.argument.valueOf()].filter(function (p) {\n        return p !== point;\n      });\n    }\n\n    return point;\n  },\n  adjustLabels: function (moveLabelsFromCenter) {\n    return (this._points || []).reduce(function (r, p) {\n      if (p._label.isVisible()) {\n        p.setLabelTrackerData();\n        r = p.applyWordWrap(moveLabelsFromCenter) || r;\n        p.updateLabelCoord(moveLabelsFromCenter);\n        return r;\n      }\n    }, false);\n  },\n  _applyElementsClipRect: _noop,\n  getColor: _noop,\n  areErrorBarsVisible: _noop,\n  drawLabelsWOPoints: function () {\n    var that = this;\n\n    if (that._options.label.position === INSIDE) {\n      return false;\n    }\n\n    that._labelsGroup.append(that._extGroups.labelsGroup);\n\n    (that._points || []).forEach(function (point) {\n      point.drawLabel();\n    });\n    return true;\n  },\n  getPointsCount: function () {\n    var _this = this;\n\n    return this._data.filter(function (d) {\n      return _this._checkData(d);\n    }).length;\n  },\n  setMaxPointsCount: function (count) {\n    this._pointsCount = count;\n  },\n  _getCreatingPointOptions: function (data, dataIndex) {\n    return this._getPointOptions(data, dataIndex);\n  },\n  _updateOptions: function (options) {\n    this.labelSpace = 0;\n    this.innerRadius = \"pie\" === this.type ? 0 : options.innerRadius;\n  },\n  _checkData: function (data, skippedFields) {\n    var base = barSeries._checkData.call(this, data, skippedFields, {\n      value: this.getValueFields()[0]\n    });\n\n    return this._options.paintNullPoints ? base : base && null !== data.value;\n  },\n  _createGroups: chartScatterSeries._createGroups,\n  _setMarkerGroupSettings: function () {\n    this._markersGroup.attr({\n      \"class\": \"dxc-markers\"\n    });\n  },\n  _getMainColor: function (data, point) {\n    var pointsByArg = this.getPointsByArg(data.argument);\n    var argumentIndex = point ? pointsByArg.indexOf(point) : pointsByArg.length;\n    return this._options.mainSeriesColor(data.argument, argumentIndex, this._pointsCount);\n  },\n  _getPointOptions: function (data) {\n    return this._parsePointOptions(this._preparePointOptions(), this._options.label, data);\n  },\n  _getRangeData: function () {\n    return this._rangeData;\n  },\n  _createPointStyles: function (pointOptions, data, point) {\n    var that = this;\n\n    var mainColor = pointOptions.color || that._getMainColor(data, point);\n\n    return {\n      normal: that._parsePointStyle(pointOptions, mainColor, mainColor),\n      hover: that._parsePointStyle(pointOptions.hoverStyle, mainColor, mainColor),\n      selection: that._parsePointStyle(pointOptions.selectionStyle, mainColor, mainColor),\n      legendStyles: {\n        normal: that._createLegendState(pointOptions, mainColor),\n        hover: that._createLegendState(pointOptions.hoverStyle, mainColor),\n        selection: that._createLegendState(pointOptions.selectionStyle, mainColor)\n      }\n    };\n  },\n  _getArrangeMinShownValue: function (points, total) {\n    var minSegmentSize = this._options.minSegmentSize;\n    var totalMinSegmentSize = 0;\n    var totalNotMinValues = 0;\n    total = total || points.length;\n\n    _each(points, function (_, point) {\n      if (point.isVisible()) {\n        if (point.normalInitialValue < minSegmentSize * total / 360) {\n          totalMinSegmentSize += minSegmentSize;\n        } else {\n          totalNotMinValues += point.normalInitialValue;\n        }\n      }\n    });\n\n    return totalMinSegmentSize < 360 ? minSegmentSize * totalNotMinValues / (360 - totalMinSegmentSize) : 0;\n  },\n  _applyArrangeCorrection: function (points, minShownValue, total) {\n    var options = this._options;\n    var isClockWise = \"anticlockwise\" !== options.segmentsDirection;\n    var shiftedAngle = _isFinite(options.startAngle) ? vizUtils.normalizeAngle(options.startAngle) : 0;\n    var minSegmentSize = options.minSegmentSize;\n    var percent;\n    var correction = 0;\n    var zeroTotalCorrection = 0;\n\n    if (0 === total) {\n      total = points.filter(function (el) {\n        return el.isVisible();\n      }).length;\n      zeroTotalCorrection = 1;\n    }\n\n    _each(isClockWise ? points : points.concat([]).reverse(), function (_, point) {\n      var val = point.isVisible() ? zeroTotalCorrection || point.normalInitialValue : 0;\n      var updatedZeroValue;\n\n      if (minSegmentSize && point.isVisible() && val < minShownValue) {\n        updatedZeroValue = minShownValue;\n      }\n\n      percent = val / total;\n      point.correctValue(correction, percent, zeroTotalCorrection + (updatedZeroValue || 0));\n      point.shiftedAngle = shiftedAngle;\n      correction += updatedZeroValue || val;\n    });\n\n    this._rangeData = {\n      val: {\n        min: 0,\n        max: correction\n      }\n    };\n  },\n  _removePoint: function (point) {\n    var points = this.getPointsByArg(point.argument);\n    points.splice(points.indexOf(point), 1);\n    point.dispose();\n  },\n  arrangePoints: function () {\n    var that = this;\n    var originalPoints = that._points || [];\n    var minSegmentSize = that._options.minSegmentSize;\n    var minShownValue;\n    var total;\n    var isAllPointsNegative = true;\n    var points;\n    var i = 0;\n    var len = originalPoints.length;\n    var maxValue;\n\n    while (i < len && isAllPointsNegative) {\n      isAllPointsNegative = originalPoints[i].value <= 0;\n      i++;\n    }\n\n    points = that._points = _map(originalPoints, function (point) {\n      if (null === point.value || !isAllPointsNegative && point.value < 0) {\n        that._removePoint(point);\n\n        return null;\n      } else {\n        return point;\n      }\n    });\n    maxValue = points.reduce(function (max, p) {\n      return _max(max, Math.abs(p.initialValue));\n    }, 0);\n    points.forEach(function (p) {\n      p.normalInitialValue = p.initialValue / (0 !== maxValue ? maxValue : 1);\n    });\n    total = points.reduce(function (total, point) {\n      return total + (point.isVisible() ? point.normalInitialValue : 0);\n    }, 0);\n\n    if (minSegmentSize) {\n      minShownValue = this._getArrangeMinShownValue(points, total);\n    }\n\n    that._applyArrangeCorrection(points, minShownValue, total);\n  },\n  correctPosition: function (correction, canvas) {\n    _each(this._points, function (_, point) {\n      point.correctPosition(correction);\n    });\n\n    this.setVisibleArea(canvas);\n  },\n  correctRadius: function (correction) {\n    this._points.forEach(function (point) {\n      point.correctRadius(correction);\n    });\n  },\n  correctLabelRadius: function (labelRadius) {\n    this._points.forEach(function (point) {\n      point.correctLabelRadius(labelRadius);\n    });\n  },\n  setVisibleArea: function (canvas) {\n    this._visibleArea = {\n      minX: canvas.left,\n      maxX: canvas.width - canvas.right,\n      minY: canvas.top,\n      maxY: canvas.height - canvas.bottom\n    };\n  },\n  _applyVisibleArea: _noop,\n  _animate: function (firstDrawing) {\n    var that = this;\n    var points = that._points;\n    var pointsCount = points && points.length;\n\n    var completeFunc = function () {\n      that._animateComplete();\n    };\n\n    var animatePoint;\n\n    if (firstDrawing) {\n      animatePoint = function (p, i) {\n        p.animate(i === pointsCount - 1 ? completeFunc : void 0, ANIMATION_DURATION, (1 - ANIMATION_DURATION) * i / (pointsCount - 1));\n      };\n    } else {\n      animatePoint = function (p, i) {\n        p.animate(i === pointsCount - 1 ? completeFunc : void 0);\n      };\n    }\n\n    points.forEach(animatePoint);\n  },\n  getVisiblePoints: function () {\n    return _map(this._points, function (p) {\n      return p.isVisible() ? p : null;\n    });\n  },\n  getPointsByKeys: function (arg, argumentIndex) {\n    var pointsByArg = this.getPointsByArg(arg);\n    return pointsByArg[argumentIndex] && [pointsByArg[argumentIndex]] || [];\n  }\n});\nexports.doughnut = exports.donut = exports.pie;","map":null,"metadata":{},"sourceType":"script"}