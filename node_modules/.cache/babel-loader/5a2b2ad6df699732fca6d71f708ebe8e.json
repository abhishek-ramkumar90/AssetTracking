{"ast":null,"code":"/**\r\n * DevExtreme (viz/series/range_series.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar extend = require(\"../../core/utils/extend\").extend;\n\nvar _extend = extend;\n\nvar _isDefined = require(\"../../core/utils/type\").isDefined;\n\nvar _map = require(\"../core/utils\").map;\n\nvar _noop = require(\"../../core/utils/common\").noop;\n\nvar scatterSeries = require(\"./scatter_series\").chart;\n\nvar barSeries = require(\"./bar_series\").chart.bar;\n\nvar areaSeries = require(\"./area_series\").chart.area;\n\nexports.chart = {};\nvar baseRangeSeries = {\n  areErrorBarsVisible: _noop,\n  _createErrorBarGroup: _noop,\n  _checkData: function (data, skippedFields) {\n    var valueFields = this.getValueFields();\n    return scatterSeries._checkData.call(this, data, skippedFields, {\n      minValue: valueFields[0],\n      value: valueFields[1]\n    }) && data.minValue === data.minValue;\n  },\n  getValueRangeInitialValue: scatterSeries.getValueRangeInitialValue,\n  _getPointDataSelector: function (data) {\n    var _this = this;\n\n    var valueFields = this.getValueFields();\n    var val1Field = valueFields[0];\n    var val2Field = valueFields[1];\n    var tagField = this.getTagField();\n    var argumentField = this.getArgumentField();\n    return function (data) {\n      return {\n        tag: data[tagField],\n        minValue: _this._processEmptyValue(data[val1Field]),\n        value: _this._processEmptyValue(data[val2Field]),\n        argument: data[argumentField],\n        data: data\n      };\n    };\n  },\n  _defaultAggregator: \"range\",\n  _aggregators: {\n    range: function (_ref, series) {\n      var _data$reduce;\n\n      var intervalStart = _ref.intervalStart,\n          data = _ref.data;\n\n      if (!data.length) {\n        return;\n      }\n\n      var valueFields = series.getValueFields();\n      var val1Field = valueFields[0];\n      var val2Field = valueFields[1];\n      var result = data.reduce(function (result, item) {\n        var val1 = item[val1Field];\n        var val2 = item[val2Field];\n\n        if (!_isDefined(val1) || !_isDefined(val2)) {\n          return result;\n        }\n\n        result[val1Field] = Math.min(result[val1Field], Math.min(val1, val2));\n        result[val2Field] = Math.max(result[val2Field], Math.max(val1, val2));\n        return result;\n      }, (_data$reduce = {}, _defineProperty(_data$reduce, val1Field, 1 / 0), _defineProperty(_data$reduce, val2Field, -(1 / 0)), _defineProperty(_data$reduce, series.getArgumentField(), intervalStart), _data$reduce));\n\n      if (!isFinite(result[val1Field]) || !isFinite(result[val2Field])) {\n        if (data.filter(function (i) {\n          return null === i[val1Field] && null === i[val2Field];\n        }).length === data.length) {\n          result[val1Field] = result[val2Field] = null;\n        } else {\n          return;\n        }\n      }\n\n      return result;\n    }\n  },\n  getValueFields: function () {\n    return [this._options.rangeValue1Field || \"val1\", this._options.rangeValue2Field || \"val2\"];\n  },\n  getSeriesPairCoord: function (coord, isArgument) {\n    var oppositeCoord = null;\n    var rotated = this._options.rotated;\n    var isOpposite = !isArgument && !rotated || isArgument && rotated;\n    var coordName = isOpposite ? \"vy\" : \"vx\";\n    var minCoordName = rotated ? \"minX\" : \"minY\";\n    var oppositeCoordName = isOpposite ? \"vx\" : \"vy\";\n    var points = this.getPoints();\n\n    for (var i = 0; i < points.length; i++) {\n      var p = points[i];\n      var tmpCoord = void 0;\n\n      if (isArgument) {\n        tmpCoord = p.getCenterCoord()[coordName[1]] === coord ? p[oppositeCoordName] : void 0;\n      } else {\n        var coords = [Math.min(p[coordName], p[minCoordName]), Math.max(p[coordName], p[minCoordName])];\n        tmpCoord = coord >= coords[0] && coord <= coords[1] ? p[oppositeCoordName] : void 0;\n      }\n\n      if (this.checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\n        oppositeCoord = tmpCoord;\n        break;\n      }\n    }\n\n    return oppositeCoord;\n  }\n};\nexports.chart.rangebar = _extend({}, barSeries, baseRangeSeries);\nexports.chart.rangearea = _extend({}, areaSeries, {\n  _drawPoint: function (options) {\n    var point = options.point;\n\n    if (point.isInVisibleArea()) {\n      point.clearVisibility();\n      point.draw(this._renderer, options.groups);\n\n      this._drawnPoints.push(point);\n\n      if (!point.visibleTopMarker) {\n        point.hideMarker(\"top\");\n      }\n\n      if (!point.visibleBottomMarker) {\n        point.hideMarker(\"bottom\");\n      }\n    } else {\n      point.setInvisibility();\n    }\n  },\n  _prepareSegment: function (points, rotated) {\n    var processedPoints = this._processSinglePointsAreaSegment(points, rotated);\n\n    var processedMinPointsCoords = _map(processedPoints, function (pt) {\n      return pt.getCoords(true);\n    });\n\n    return {\n      line: processedPoints,\n      bottomLine: processedMinPointsCoords,\n      area: _map(processedPoints, function (pt) {\n        return pt.getCoords();\n      }).concat(processedMinPointsCoords.slice().reverse()),\n      singlePointSegment: processedPoints !== points\n    };\n  },\n  _getDefaultSegment: function (segment) {\n    var defaultSegment = areaSeries._getDefaultSegment.call(this, segment);\n\n    defaultSegment.bottomLine = defaultSegment.line;\n    return defaultSegment;\n  },\n  _removeElement: function (element) {\n    areaSeries._removeElement.call(this, element);\n\n    element.bottomLine && element.bottomLine.remove();\n  },\n  _drawElement: function (segment, group) {\n    var that = this;\n\n    var drawnElement = areaSeries._drawElement.call(that, segment, group);\n\n    drawnElement.bottomLine = that._bordersGroup && that._createBorderElement(segment.bottomLine, {\n      \"stroke-width\": that._styles.normal.border[\"stroke-width\"]\n    }).append(that._bordersGroup);\n    return drawnElement;\n  },\n  _applyStyle: function (style) {\n    var that = this;\n    var elementsGroup = that._elementsGroup;\n    var bordersGroup = that._bordersGroup;\n    elementsGroup && elementsGroup.smartAttr(style.elements);\n    bordersGroup && bordersGroup.attr(style.border);\n    (that._graphics || []).forEach(function (graphic) {\n      graphic.line && graphic.line.attr({\n        \"stroke-width\": style.border[\"stroke-width\"]\n      });\n      graphic.bottomLine && graphic.bottomLine.attr({\n        \"stroke-width\": style.border[\"stroke-width\"]\n      });\n    });\n  },\n  _updateElement: function (element, segment, animate, complete) {\n    var bottomLineParams = {\n      points: segment.bottomLine\n    };\n    var bottomBorderElement = element.bottomLine;\n\n    areaSeries._updateElement.apply(this, arguments);\n\n    if (bottomBorderElement) {\n      animate ? bottomBorderElement.animate(bottomLineParams) : bottomBorderElement.attr(bottomLineParams);\n    }\n  }\n}, baseRangeSeries);","map":null,"metadata":{},"sourceType":"script"}