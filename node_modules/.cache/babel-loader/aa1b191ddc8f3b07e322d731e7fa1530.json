{"ast":null,"code":"/**\r\n * DevExtreme (viz/series/helpers/range_data_calculator.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _utils = require(\"../../core/utils\");\n\nvar _type = require(\"../../../core/utils/type\");\n\nvar _common = require(\"../../../core/utils/common\");\n\nvar DISCRETE = \"discrete\";\nvar abs = Math.abs,\n    floor = Math.floor,\n    ceil = Math.ceil,\n    min = Math.min;\n\nfunction continuousRangeCalculator(range, minValue, maxValue) {\n  range.min = range.min < minValue ? range.min : minValue;\n  range.max = range.max > maxValue ? range.max : maxValue;\n}\n\nfunction createGetLogFunction(axisType, axis) {\n  if (\"logarithmic\" !== axisType) {\n    return null;\n  }\n\n  var base = axis.getOptions().logarithmBase;\n  return function (value) {\n    var log = (0, _utils.getLog)(abs(value), base);\n    var round = log < 0 ? floor : ceil;\n    return round(log);\n  };\n}\n\nfunction getRangeCalculator(axisType, axis, getLog) {\n  var rangeCalculator = continuousRangeCalculator;\n\n  if (axisType === DISCRETE) {\n    rangeCalculator = function (range, minValue, maxValue) {\n      if (minValue !== maxValue) {\n        range.categories.push(maxValue);\n      }\n\n      range.categories.push(minValue);\n    };\n  } else {\n    if (axis) {\n      rangeCalculator = function (range, value) {\n        var interval = axis.calculateInterval(value, range.prevValue);\n        var minInterval = range.interval;\n        range.interval = (minInterval < interval ? minInterval : interval) || minInterval;\n        range.prevValue = value;\n        continuousRangeCalculator(range, value, value);\n      };\n    }\n  }\n\n  if (getLog) {\n    return function (range, minValue, maxValue) {\n      var minArgs = [];\n      rangeCalculator(range, minValue, maxValue);\n      0 !== minValue && minArgs.push(getLog(minValue));\n      0 !== maxValue && minArgs.push(getLog(maxValue));\n      var linearThreshold = min.apply(null, minArgs);\n      range.linearThreshold = range.linearThreshold < linearThreshold ? range.linearThreshold : linearThreshold;\n    };\n  }\n\n  return rangeCalculator;\n}\n\nfunction getInitialRange(axisType, dataType, firstValue) {\n  var range = {\n    axisType: axisType,\n    dataType: dataType\n  };\n\n  if (axisType === DISCRETE) {\n    range.categories = [];\n  } else {\n    range.min = firstValue;\n    range.max = firstValue;\n  }\n\n  return range;\n}\n\nfunction processCategories(range) {\n  if (range.categories) {\n    range.categories = (0, _utils.unique)(range.categories);\n  }\n\n  return range;\n}\n\nfunction getValueForArgument(point, extraPoint, x, range) {\n  if (extraPoint && (0, _type.isDefined)(extraPoint.value)) {\n    var y1 = point.value;\n    var y2 = extraPoint.value;\n    var x1 = point.argument;\n    var x2 = extraPoint.argument;\n    var r = (x - x1) * (y2 - y1) / (x2 - x1) + y1.valueOf();\n    return \"datetime\" === range.dataType ? new Date(r) : r;\n  } else {\n    return point.value;\n  }\n}\n\nfunction calculateRangeBetweenPoints(rangeCalculator, range, point, prevPoint, bound) {\n  var value = getValueForArgument(point, prevPoint, bound, range);\n  rangeCalculator(range, value, value);\n}\n\nfunction isLineSeries(series) {\n  return series.type.toLowerCase().indexOf(\"line\") >= 0 || series.type.toLowerCase().indexOf(\"area\") >= 0;\n}\n\nfunction getViewportReducer(series) {\n  var rangeCalculator = getRangeCalculator(series.valueAxisType);\n  var argumentAxis = series.getArgumentAxis();\n  var viewport = argumentAxis && series.getArgumentAxis().visualRange() || {};\n  var viewportFilter;\n  var calculatePointBetweenPoints = isLineSeries(series) ? calculateRangeBetweenPoints : _common.noop;\n\n  if (argumentAxis && argumentAxis.getMarginOptions().checkInterval) {\n    var range = series.getArgumentAxis().getTranslator().getBusinessRange();\n    var add = (0, _utils.getAddFunction)(range, false);\n    var interval = range.interval;\n\n    if (isFinite(interval) && (0, _type.isDefined)(viewport.startValue) && (0, _type.isDefined)(viewport.endValue)) {\n      viewport.startValue = add(viewport.startValue, interval, -1);\n      viewport.endValue = add(viewport.endValue, interval);\n    }\n  }\n\n  viewportFilter = getViewPortFilter(viewport);\n  return function (range, point, index, points) {\n    var argument = point.argument;\n\n    if (!point.hasValue()) {\n      return range;\n    }\n\n    if (viewportFilter(argument)) {\n      if (!range.startCalc) {\n        range.startCalc = true;\n        calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.startValue);\n      }\n\n      rangeCalculator(range, point.getMinValue(), point.getMaxValue());\n    } else {\n      if (!viewport.categories && (0, _type.isDefined)(viewport.startValue) && argument > viewport.startValue) {\n        if (!range.startCalc) {\n          calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.startValue);\n        }\n\n        range.endCalc = true;\n        calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.endValue);\n      }\n    }\n\n    return range;\n  };\n}\n\nfunction getViewPortFilter(viewport) {\n  if (viewport.categories) {\n    var dictionary = viewport.categories.reduce(function (result, category) {\n      result[category.valueOf()] = true;\n      return result;\n    }, {});\n    return function (argument) {\n      return (0, _type.isDefined)(argument) && dictionary[argument.valueOf()];\n    };\n  }\n\n  if (!(0, _type.isDefined)(viewport.startValue) && !(0, _type.isDefined)(viewport.endValue)) {\n    return function () {\n      return true;\n    };\n  }\n\n  if (!(0, _type.isDefined)(viewport.endValue)) {\n    return function (argument) {\n      return argument >= viewport.startValue;\n    };\n  }\n\n  if (!(0, _type.isDefined)(viewport.startValue)) {\n    return function (argument) {\n      return argument <= viewport.endValue;\n    };\n  }\n\n  return function (argument) {\n    return argument >= viewport.startValue && argument <= viewport.endValue;\n  };\n}\n\nmodule.exports = {\n  getViewPortFilter: getViewPortFilter,\n  getArgumentRange: function (series) {\n    var data = series._data || [];\n    var range = {};\n\n    if (data.length) {\n      if (series.argumentAxisType === DISCRETE) {\n        range = {\n          categories: data.map(function (item) {\n            return item.argument;\n          })\n        };\n      } else {\n        var interval;\n\n        if (data.length > 1) {\n          var i1 = series.getArgumentAxis().calculateInterval(data[0].argument, data[1].argument);\n          var i2 = series.getArgumentAxis().calculateInterval(data[data.length - 1].argument, data[data.length - 2].argument);\n          interval = min(i1, i2);\n        }\n\n        range = {\n          min: data[0].argument,\n          max: data[data.length - 1].argument,\n          interval: interval\n        };\n      }\n    }\n\n    return processCategories(range);\n  },\n  getRangeData: function (series) {\n    var points = series.getPoints();\n    var useAggregation = series.useAggregation();\n    var argumentCalculator = getRangeCalculator(series.argumentAxisType, points.length > 1 && series.getArgumentAxis(), createGetLogFunction(series.argumentAxisType, series.getArgumentAxis()));\n    var valueRangeCalculator = getRangeCalculator(series.valueAxisType, null, createGetLogFunction(series.valueAxisType, series.getValueAxis()));\n    var viewportReducer = getViewportReducer(series);\n    var range = points.reduce(function (range, point, index, points) {\n      var argument = point.argument;\n\n      if (!point.isArgumentCorrect()) {\n        return range;\n      }\n\n      argumentCalculator(range.arg, argument, argument);\n\n      if (point.hasValue()) {\n        valueRangeCalculator(range.val, point.getMinValue(), point.getMaxValue());\n        viewportReducer(range.viewport, point, index, points);\n      }\n\n      return range;\n    }, {\n      arg: getInitialRange(series.argumentAxisType, series.argumentType),\n      val: getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0),\n      viewport: getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0)\n    });\n\n    if (useAggregation) {\n      var argumentRange = this.getArgumentRange(series);\n\n      if (series.argumentAxisType === DISCRETE) {\n        range.arg = argumentRange;\n      } else {\n        var viewport = series.getArgumentAxis().getViewport();\n\n        if ((0, _type.isDefined)(viewport.startValue) || (0, _type.isDefined)(viewport.length)) {\n          argumentCalculator(range.arg, argumentRange.min, argumentRange.min);\n        }\n\n        if ((0, _type.isDefined)(viewport.endValue) || (0, _type.isDefined)(viewport.length) && (0, _type.isDefined)(viewport.startValue)) {\n          argumentCalculator(range.arg, argumentRange.max, argumentRange.max);\n        }\n      }\n    }\n\n    processCategories(range.arg);\n    processCategories(range.val);\n    return range;\n  },\n  getViewport: function (series) {\n    var points = series.getPoints();\n    var range = {};\n    var reducer;\n    reducer = getViewportReducer(series);\n    range = getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0);\n    points.some(function (point, index) {\n      reducer(range, point, index, points);\n      return range.endCalc;\n    });\n    return range;\n  },\n  getPointsInViewPort: function (series) {\n    var argumentViewPortFilter = getViewPortFilter(series.getArgumentAxis().visualRange() || {});\n    var valueViewPort = series.getValueAxis().visualRange() || {};\n    var valueViewPortFilter = getViewPortFilter(valueViewPort);\n    var points = series.getPoints();\n\n    var addValue = function (values, point, isEdge) {\n      var minValue = point.getMinValue();\n      var maxValue = point.getMaxValue();\n      var isMinValueInViewPort = valueViewPortFilter(minValue);\n      var isMaxValueInViewPort = valueViewPortFilter(maxValue);\n\n      if (isMinValueInViewPort) {\n        values.push(minValue);\n      }\n\n      if (maxValue !== minValue && isMaxValueInViewPort) {\n        values.push(maxValue);\n      }\n\n      if (isEdge && !isMinValueInViewPort && !isMaxValueInViewPort) {\n        if (!values.length) {\n          values.push(valueViewPort.startValue);\n        } else {\n          values.push(valueViewPort.endValue);\n        }\n      }\n    };\n\n    var addEdgePoints = isLineSeries(series) ? function (result, points, index) {\n      var point = points[index];\n      var prevPoint = points[index - 1];\n      var nextPoint = points[index + 1];\n\n      if (nextPoint && argumentViewPortFilter(nextPoint.argument)) {\n        addValue(result[1], point, true);\n      }\n\n      if (prevPoint && argumentViewPortFilter(prevPoint.argument)) {\n        addValue(result[1], point, true);\n      }\n    } : _common.noop;\n\n    var checkPointInViewport = function (result, point, index) {\n      if (argumentViewPortFilter(point.argument)) {\n        addValue(result[0], point);\n      } else {\n        addEdgePoints(result, points, index);\n      }\n\n      return result;\n    };\n\n    return points.reduce(checkPointInViewport, [[], []]);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}