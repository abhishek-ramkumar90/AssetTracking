{"ast":null,"code":"/**\r\n * DevExtreme (viz/chart_components/base_chart.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar commonUtils = require(\"../../core/utils/common\");\n\nvar noop = commonUtils.noop;\n\nvar eventsEngine = require(\"../../events/core/events_engine\");\n\nvar typeUtils = require(\"../../core/utils/type\");\n\nvar iteratorModule = require(\"../../core/utils/iterator\");\n\nvar extend = require(\"../../core/utils/extend\").extend;\n\nvar inArray = require(\"../../core/utils/array\").inArray;\n\nvar eventUtils = require(\"../../events/utils\");\n\nvar BaseWidget = require(\"../core/base_widget\");\n\nvar coreDataUtils = require(\"../../core/utils/data\");\n\nvar legendModule = require(\"../components/legend\");\n\nvar dataValidatorModule = require(\"../components/data_validator\");\n\nvar seriesModule = require(\"../series/base_series\");\n\nvar chartThemeManagerModule = require(\"../components/chart_theme_manager\");\n\nvar LayoutManagerModule = require(\"./layout_manager\");\n\nvar trackerModule = require(\"./tracker\");\n\nvar REINIT_REFRESH_ACTION = \"_reinit\";\nvar REINIT_DATA_SOURCE_REFRESH_ACTION = \"_updateDataSource\";\nvar DATA_INIT_REFRESH_ACTION = \"_dataInit\";\nvar FORCE_RENDER_REFRESH_ACTION = \"_forceRender\";\nvar RESIZE_REFRESH_ACTION = \"_resize\";\nvar ACTIONS_BY_PRIORITY = [REINIT_REFRESH_ACTION, REINIT_DATA_SOURCE_REFRESH_ACTION, DATA_INIT_REFRESH_ACTION, FORCE_RENDER_REFRESH_ACTION, RESIZE_REFRESH_ACTION];\n\nvar vizUtils = require(\"../core/utils\");\n\nvar _map = vizUtils.map;\nvar _each = iteratorModule.each;\nvar _reverseEach = iteratorModule.reverseEach;\nvar _isArray = Array.isArray;\nvar _isDefined = typeUtils.isDefined;\nvar _setCanvasValues = vizUtils.setCanvasValues;\nvar DEFAULT_OPACITY = .3;\nvar REFRESH_SERIES_DATA_INIT_ACTION_OPTIONS = [\"series\", \"commonSeriesSettings\", \"dataPrepareSettings\", \"seriesSelectionMode\", \"pointSelectionMode\", \"synchronizeMultiAxes\", \"resolveLabelsOverlapping\"];\nvar REFRESH_SERIES_FAMILIES_ACTION_OPTIONS = [\"equalBarWidth\", \"minBubbleSize\", \"maxBubbleSize\", \"barWidth\", \"barGroupPadding\", \"barGroupWidth\", \"negativesAsZeroes\", \"negativesAsZeros\"];\nvar FORCE_RENDER_REFRESH_ACTION_OPTIONS = [\"adaptiveLayout\", \"crosshair\", \"resolveLabelOverlapping\", \"adjustOnZoom\", \"zoomingMode\", \"scrollingMode\", \"stickyHovering\"];\nvar FONT = \"font\";\n\nfunction checkHeightRollingStock(rollingStocks, stubCanvas) {\n  var canvasSize = stubCanvas.end - stubCanvas.start;\n  var size = 0;\n  rollingStocks.forEach(function (rollingStock) {\n    size += rollingStock.getBoundingRect().width;\n  });\n\n  while (canvasSize < size) {\n    size -= findAndKillSmallValue(rollingStocks);\n  }\n}\n\nfunction findAndKillSmallValue(rollingStocks) {\n  var smallestObject;\n  var width;\n  smallestObject = rollingStocks.reduce(function (prev, rollingStock, index) {\n    if (!rollingStock) {\n      return prev;\n    }\n\n    var value = rollingStock.value();\n    return value < prev.value ? {\n      value: value,\n      rollingStock: rollingStock,\n      index: index\n    } : prev;\n  }, {\n    rollingStock: void 0,\n    value: 1 / 0,\n    index: void 0\n  });\n  smallestObject.rollingStock.getLabels()[0].draw(false);\n  width = smallestObject.rollingStock.getBoundingRect().width;\n  rollingStocks[smallestObject.index] = null;\n  return width;\n}\n\nfunction checkStackOverlap(rollingStocks) {\n  var i;\n  var j;\n  var iLength;\n  var jLength;\n  var overlap = false;\n\n  for (i = 0, iLength = rollingStocks.length - 1; i < iLength; i++) {\n    for (j = i + 1, jLength = rollingStocks.length; j < jLength; j++) {\n      if (i !== j && checkStacksOverlapping(rollingStocks[i], rollingStocks[j], true)) {\n        overlap = true;\n        break;\n      }\n    }\n\n    if (overlap) {\n      break;\n    }\n  }\n\n  return overlap;\n}\n\nfunction resolveLabelOverlappingInOneDirection(points, canvas, isRotated, shiftFunction) {\n  var customSorting = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : function () {\n    return 0;\n  };\n  var rollingStocks = [];\n  var stubCanvas = {\n    start: isRotated ? canvas.left : canvas.top,\n    end: isRotated ? canvas.width - canvas.right : canvas.height - canvas.bottom\n  };\n  var hasStackedSeries = false;\n  points.forEach(function (p) {\n    if (!p) {\n      return;\n    }\n\n    hasStackedSeries = hasStackedSeries || p.series.isStackedSeries() || p.series.isFullStackedSeries();\n    p.getLabels().forEach(function (l) {\n      l.isVisible() && rollingStocks.push(new RollingStock(l, isRotated, shiftFunction));\n    });\n  });\n\n  if (hasStackedSeries) {\n    !isRotated && rollingStocks.reverse();\n  } else {\n    var rollingStocksTmp = rollingStocks.slice();\n    rollingStocks.sort(function (a, b) {\n      return customSorting(a, b) || a.getInitialPosition() - b.getInitialPosition() || rollingStocksTmp.indexOf(a) - rollingStocksTmp.indexOf(b);\n    });\n  }\n\n  if (!checkStackOverlap(rollingStocks)) {\n    return false;\n  }\n\n  checkHeightRollingStock(rollingStocks, stubCanvas);\n  prepareOverlapStacks(rollingStocks);\n  rollingStocks.reverse();\n  moveRollingStock(rollingStocks, stubCanvas);\n  return true;\n}\n\nfunction checkStacksOverlapping(firstRolling, secondRolling, inTwoSides) {\n  if (!firstRolling || !secondRolling) {\n    return;\n  }\n\n  var firstRect = firstRolling.getBoundingRect();\n  var secondRect = secondRolling.getBoundingRect();\n  var oppositeOverlapping = inTwoSides ? firstRect.oppositeStart <= secondRect.oppositeStart && firstRect.oppositeEnd > secondRect.oppositeStart || secondRect.oppositeStart <= firstRect.oppositeStart && secondRect.oppositeEnd > firstRect.oppositeStart : true;\n  return firstRect.end > secondRect.start && oppositeOverlapping;\n}\n\nfunction prepareOverlapStacks(rollingStocks) {\n  var i;\n  var currentRollingStock;\n  var root;\n\n  for (i = 0; i < rollingStocks.length - 1; i++) {\n    currentRollingStock = root || rollingStocks[i];\n\n    if (checkStacksOverlapping(currentRollingStock, rollingStocks[i + 1])) {\n      currentRollingStock.toChain(rollingStocks[i + 1]);\n      rollingStocks[i + 1] = null;\n      root = currentRollingStock;\n    } else {\n      root = rollingStocks[i + 1] || currentRollingStock;\n    }\n  }\n}\n\nfunction moveRollingStock(rollingStocks, canvas) {\n  var i;\n  var j;\n  var currentRollingStock;\n  var nextRollingStock;\n  var currentBBox;\n  var nextBBox;\n\n  for (i = 0; i < rollingStocks.length; i++) {\n    currentRollingStock = rollingStocks[i];\n\n    if (rollingStocksIsOut(currentRollingStock, canvas)) {\n      currentBBox = currentRollingStock.getBoundingRect();\n\n      for (j = i + 1; j < rollingStocks.length; j++) {\n        nextRollingStock = rollingStocks[j];\n\n        if (!nextRollingStock) {\n          continue;\n        }\n\n        nextBBox = nextRollingStock.getBoundingRect();\n\n        if (nextBBox.end > currentBBox.start - (currentBBox.end - canvas.end)) {\n          nextRollingStock.toChain(currentRollingStock);\n          rollingStocks[i] = currentRollingStock = null;\n          break;\n        }\n      }\n    }\n\n    currentRollingStock && currentRollingStock.setRollingStockInCanvas(canvas);\n  }\n}\n\nfunction rollingStocksIsOut(rollingStock, canvas) {\n  return rollingStock && rollingStock.getBoundingRect().end > canvas.end;\n}\n\nfunction RollingStock(label, isRotated, shiftFunction) {\n  var bBox = label.getBoundingRect();\n  var x = bBox.x;\n  var y = bBox.y;\n  var endX = bBox.x + bBox.width;\n  var endY = bBox.y + bBox.height;\n  this.labels = [label];\n  this.shiftFunction = shiftFunction;\n  this._bBox = {\n    start: isRotated ? x : y,\n    width: isRotated ? bBox.width : bBox.height,\n    end: isRotated ? endX : endY,\n    oppositeStart: isRotated ? y : x,\n    oppositeEnd: isRotated ? endY : endX\n  };\n  this._initialPosition = isRotated ? bBox.x : bBox.y;\n  return this;\n}\n\nRollingStock.prototype = {\n  toChain: function (nextRollingStock) {\n    var nextRollingStockBBox = nextRollingStock.getBoundingRect();\n    nextRollingStock.shift(nextRollingStockBBox.start - this._bBox.end);\n\n    this._changeBoxWidth(nextRollingStockBBox.width);\n\n    this.labels = this.labels.concat(nextRollingStock.labels);\n  },\n  getBoundingRect: function () {\n    return this._bBox;\n  },\n  shift: function (shiftLength) {\n    var shiftFunction = this.shiftFunction;\n\n    _each(this.labels, function (index, label) {\n      var bBox = label.getBoundingRect();\n      var coords = shiftFunction(bBox, shiftLength);\n\n      if (!label.hideInsideLabel(coords)) {\n        label.shift(coords.x, coords.y);\n      }\n    });\n\n    this._bBox.end -= shiftLength;\n    this._bBox.start -= shiftLength;\n  },\n  setRollingStockInCanvas: function (canvas) {\n    if (this._bBox.end > canvas.end) {\n      this.shift(this._bBox.end - canvas.end);\n    }\n  },\n  getLabels: function () {\n    return this.labels;\n  },\n  value: function () {\n    return this.labels[0].getData().value;\n  },\n  getInitialPosition: function () {\n    return this._initialPosition;\n  },\n  _changeBoxWidth: function (width) {\n    this._bBox.end += width;\n    this._bBox.width += width;\n  }\n};\n\nfunction getLegendFields(name) {\n  return {\n    nameField: name + \"Name\",\n    colorField: name + \"Color\",\n    indexField: name + \"Index\"\n  };\n}\n\nfunction getLegendSettings(legendDataField) {\n  var formatObjectFields = getLegendFields(legendDataField);\n  return {\n    getFormatObject: function (data) {\n      var res = {};\n      res[formatObjectFields.indexField] = data.id;\n      res[formatObjectFields.colorField] = data.states.normal.fill;\n      res[formatObjectFields.nameField] = data.text;\n      return res;\n    },\n    textField: formatObjectFields.nameField\n  };\n}\n\nfunction checkOverlapping(firstRect, secondRect) {\n  return (firstRect.x <= secondRect.x && secondRect.x <= firstRect.x + firstRect.width || firstRect.x >= secondRect.x && firstRect.x <= secondRect.x + secondRect.width) && (firstRect.y <= secondRect.y && secondRect.y <= firstRect.y + firstRect.height || firstRect.y >= secondRect.y && firstRect.y <= secondRect.y + secondRect.height);\n}\n\nvar overlapping = {\n  resolveLabelOverlappingInOneDirection: resolveLabelOverlappingInOneDirection\n};\nvar BaseChart = BaseWidget.inherit({\n  _eventsMap: {\n    onSeriesClick: {\n      name: \"seriesClick\"\n    },\n    onPointClick: {\n      name: \"pointClick\"\n    },\n    onArgumentAxisClick: {\n      name: \"argumentAxisClick\"\n    },\n    onLegendClick: {\n      name: \"legendClick\"\n    },\n    onSeriesSelectionChanged: {\n      name: \"seriesSelectionChanged\"\n    },\n    onPointSelectionChanged: {\n      name: \"pointSelectionChanged\"\n    },\n    onSeriesHoverChanged: {\n      name: \"seriesHoverChanged\"\n    },\n    onPointHoverChanged: {\n      name: \"pointHoverChanged\"\n    },\n    onDone: {\n      name: \"done\"\n    },\n    onZoomStart: {\n      name: \"zoomStart\"\n    },\n    onZoomEnd: {\n      name: \"zoomEnd\"\n    }\n  },\n  _fontFields: [\"legend.\" + FONT, \"legend.title.\" + FONT, \"legend.title.subtitle.\" + FONT, \"commonSeriesSettings.label.\" + FONT],\n  _rootClassPrefix: \"dxc\",\n  _rootClass: \"dxc-chart\",\n  _initialChanges: [\"INIT\"],\n  _themeDependentChanges: [\"REFRESH_SERIES_REINIT\"],\n  _getThemeManagerOptions: function () {\n    var themeOptions = this.callBase.apply(this, arguments);\n    themeOptions.options = this.option();\n    return themeOptions;\n  },\n  _createThemeManager: function () {\n    var chartOption = this.option();\n    var themeManager = new chartThemeManagerModule.ThemeManager(this._getThemeManagerOptions());\n    themeManager.setTheme(chartOption.theme, chartOption.rtlEnabled);\n    return themeManager;\n  },\n  _initCore: function () {\n    var that = this;\n    that._canvasClipRect = that._renderer.clipRect();\n\n    that._createHtmlStructure();\n\n    that._createLegend();\n\n    that._createTracker();\n\n    that._needHandleRenderComplete = true;\n    that.layoutManager = new LayoutManagerModule.LayoutManager();\n\n    that._createScrollBar();\n\n    eventsEngine.on(that._$element, \"contextmenu\", function (event) {\n      if (eventUtils.isTouchEvent(event) || eventUtils.isPointerEvent(event)) {\n        event.preventDefault();\n      }\n    });\n    eventsEngine.on(that._$element, \"MSHoldVisual\", function (event) {\n      event.preventDefault();\n    });\n  },\n  _getLayoutItems: noop,\n  _layoutManagerOptions: function () {\n    return this._themeManager.getOptions(\"adaptiveLayout\");\n  },\n  _reinit: function () {\n    var that = this;\n\n    _setCanvasValues(that._canvas);\n\n    that._reinitAxes();\n\n    that._requestChange([\"DATA_SOURCE\", \"DATA_INIT\", \"CORRECT_AXIS\", \"FULL_RENDER\"]);\n  },\n  _correctAxes: noop,\n  _createHtmlStructure: function () {\n    var that = this;\n    var renderer = that._renderer;\n    var root = renderer.root;\n\n    var createConstantLinesGroup = function () {\n      return renderer.g().attr({\n        \"class\": \"dxc-constant-lines-group\"\n      }).linkOn(root, \"constant-lines\");\n    };\n\n    that._constantLinesGroup = {\n      dispose: function () {\n        this.under.dispose();\n        this.above.dispose();\n      },\n      linkOff: function () {\n        this.under.linkOff();\n        this.above.linkOff();\n      },\n      clear: function () {\n        this.under.linkRemove().clear();\n        this.above.linkRemove().clear();\n      },\n      linkAppend: function () {\n        this.under.linkAppend();\n        this.above.linkAppend();\n      }\n    };\n    that._backgroundRect = renderer.rect().attr({\n      fill: \"gray\",\n      opacity: 1e-4\n    }).append(root);\n    that._panesBackgroundGroup = renderer.g().attr({\n      \"class\": \"dxc-background\"\n    }).append(root);\n    that._stripsGroup = renderer.g().attr({\n      \"class\": \"dxc-strips-group\"\n    }).linkOn(root, \"strips\");\n    that._gridGroup = renderer.g().attr({\n      \"class\": \"dxc-grids-group\"\n    }).linkOn(root, \"grids\");\n    that._panesBorderGroup = renderer.g().attr({\n      \"class\": \"dxc-border\"\n    }).linkOn(root, \"border\");\n    that._axesGroup = renderer.g().attr({\n      \"class\": \"dxc-axes-group\"\n    }).linkOn(root, \"axes\");\n    that._labelAxesGroup = renderer.g().attr({\n      \"class\": \"dxc-strips-labels-group\"\n    }).linkOn(root, \"strips-labels\");\n    that._constantLinesGroup.under = createConstantLinesGroup();\n    that._seriesGroup = renderer.g().attr({\n      \"class\": \"dxc-series-group\"\n    }).linkOn(root, \"series\");\n    that._constantLinesGroup.above = createConstantLinesGroup();\n    that._scaleBreaksGroup = renderer.g().attr({\n      \"class\": \"dxc-scale-breaks\"\n    }).linkOn(root, \"scale-breaks\");\n    that._labelsGroup = renderer.g().attr({\n      \"class\": \"dxc-labels-group\"\n    }).linkOn(root, \"labels\");\n    that._crosshairCursorGroup = renderer.g().attr({\n      \"class\": \"dxc-crosshair-cursor\"\n    }).linkOn(root, \"crosshair\");\n    that._legendGroup = renderer.g().attr({\n      \"class\": \"dxc-legend\",\n      \"clip-path\": that._getCanvasClipRectID()\n    }).linkOn(root, \"legend\").linkAppend(root).enableLinks();\n    that._scrollBarGroup = renderer.g().attr({\n      \"class\": \"dxc-scroll-bar\"\n    }).linkOn(root, \"scroll-bar\");\n  },\n  _disposeObjectsInArray: function (propName, fieldNames) {\n    _each(this[propName] || [], function (_, item) {\n      if (fieldNames && item) {\n        _each(fieldNames, function (_, field) {\n          item[field] && item[field].dispose();\n        });\n      } else {\n        item && item.dispose();\n      }\n    });\n\n    this[propName] = null;\n  },\n  _disposeCore: function () {\n    var that = this;\n\n    var disposeObject = function (propName) {\n      if (that[propName]) {\n        that[propName].dispose();\n        that[propName] = null;\n      }\n    };\n\n    var unlinkGroup = function (name) {\n      that[name].linkOff();\n    };\n\n    var disposeObjectsInArray = this._disposeObjectsInArray;\n\n    that._renderer.stopAllAnimations();\n\n    disposeObjectsInArray.call(that, \"series\");\n    disposeObject(\"_tracker\");\n    disposeObject(\"_crosshair\");\n    that.layoutManager = that._userOptions = that._canvas = that._groupsData = null;\n    unlinkGroup(\"_stripsGroup\");\n    unlinkGroup(\"_gridGroup\");\n    unlinkGroup(\"_axesGroup\");\n    unlinkGroup(\"_constantLinesGroup\");\n    unlinkGroup(\"_labelAxesGroup\");\n    unlinkGroup(\"_panesBorderGroup\");\n    unlinkGroup(\"_seriesGroup\");\n    unlinkGroup(\"_labelsGroup\");\n    unlinkGroup(\"_crosshairCursorGroup\");\n    unlinkGroup(\"_legendGroup\");\n    unlinkGroup(\"_scrollBarGroup\");\n    unlinkGroup(\"_scaleBreaksGroup\");\n    disposeObject(\"_canvasClipRect\");\n    disposeObject(\"_panesBackgroundGroup\");\n    disposeObject(\"_backgroundRect\");\n    disposeObject(\"_stripsGroup\");\n    disposeObject(\"_gridGroup\");\n    disposeObject(\"_axesGroup\");\n    disposeObject(\"_constantLinesGroup\");\n    disposeObject(\"_labelAxesGroup\");\n    disposeObject(\"_panesBorderGroup\");\n    disposeObject(\"_seriesGroup\");\n    disposeObject(\"_labelsGroup\");\n    disposeObject(\"_crosshairCursorGroup\");\n    disposeObject(\"_legendGroup\");\n    disposeObject(\"_scrollBarGroup\");\n    disposeObject(\"_scaleBreaksGroup\");\n  },\n  _getAnimationOptions: function () {\n    return this._themeManager.getOptions(\"animation\");\n  },\n  _getDefaultSize: function () {\n    return {\n      width: 400,\n      height: 400\n    };\n  },\n  _getOption: function (name) {\n    return this._themeManager.getOptions(name);\n  },\n  _applySize: function (rect) {\n    this._rect = rect.slice();\n\n    if (!this._changes.has(\"FULL_RENDER\")) {\n      this._processRefreshData(RESIZE_REFRESH_ACTION);\n    }\n  },\n  _resize: function () {\n    this._doRender(this.__renderOptions || {\n      animate: false,\n      isResize: true\n    });\n  },\n  _trackerType: \"ChartTracker\",\n  _createTracker: function () {\n    var that = this;\n    that._tracker = new trackerModule[that._trackerType]({\n      seriesGroup: that._seriesGroup,\n      renderer: that._renderer,\n      tooltip: that._tooltip,\n      legend: that._legend,\n      eventTrigger: that._eventTrigger\n    });\n  },\n  _getTrackerSettings: function () {\n    return extend({\n      chart: this\n    }, this._getSelectionModes());\n  },\n  _getSelectionModes: function () {\n    var themeManager = this._themeManager;\n    return {\n      seriesSelectionMode: themeManager.getOptions(\"seriesSelectionMode\"),\n      pointSelectionMode: themeManager.getOptions(\"pointSelectionMode\")\n    };\n  },\n  _updateTracker: function (trackerCanvases) {\n    var that = this;\n\n    that._tracker.update(that._getTrackerSettings());\n\n    that._tracker.setCanvases({\n      left: 0,\n      right: that._canvas.width,\n      top: 0,\n      bottom: that._canvas.height\n    }, trackerCanvases);\n  },\n  _createCanvasFromRect: function (rect) {\n    var currentCanvas = this._canvas;\n    return _setCanvasValues({\n      left: rect[0],\n      top: rect[1],\n      right: currentCanvas.width - rect[2],\n      bottom: currentCanvas.height - rect[3],\n      width: currentCanvas.width,\n      height: currentCanvas.height\n    });\n  },\n  _doRender: function (_options) {\n    var that = this;\n    var drawOptions;\n    var recreateCanvas;\n\n    if (0 === that._canvas.width && 0 === that._canvas.height) {\n      return;\n    }\n\n    that._resetIsReady();\n\n    drawOptions = that._prepareDrawOptions(_options);\n    recreateCanvas = drawOptions.recreateCanvas;\n\n    that._preserveOriginalCanvas();\n\n    if (recreateCanvas) {\n      that.__currentCanvas = that._canvas;\n    } else {\n      that._canvas = that.__currentCanvas;\n    }\n\n    recreateCanvas && that._updateCanvasClipRect(that._canvas);\n    this._canvas = this._createCanvasFromRect(this._rect);\n\n    that._renderer.stopAllAnimations(true);\n\n    that._cleanGroups();\n\n    var startTime = new Date();\n\n    that._renderElements(drawOptions);\n\n    that._lastRenderingTime = new Date() - startTime;\n  },\n  _preserveOriginalCanvas: function () {\n    this.__originalCanvas = this._canvas;\n    this._canvas = extend({}, this._canvas);\n  },\n  _layoutAxes: noop,\n  _renderElements: function (drawOptions) {\n    var that = this;\n\n    var preparedOptions = that._prepareToRender(drawOptions);\n\n    var isRotated = that._isRotated();\n\n    var isLegendInside = that._isLegendInside();\n\n    var trackerCanvases = [];\n    extend({}, that._canvas);\n    var argBusinessRange;\n    var zoomMinArg;\n    var zoomMaxArg;\n\n    that._renderer.lock();\n\n    if (drawOptions.drawLegend && that._legend) {\n      that._legendGroup.linkAppend();\n    }\n\n    that.layoutManager.setOptions(that._layoutManagerOptions());\n\n    var layoutTargets = that._getLayoutTargets();\n\n    this._layoutAxes(function (needSpace) {\n      var axisDrawOptions = needSpace ? extend({}, drawOptions, {\n        animate: false\n      }) : drawOptions;\n\n      var canvas = that._renderAxes(axisDrawOptions, preparedOptions);\n\n      that._shrinkAxes(needSpace, canvas);\n    });\n\n    that._applyClipRects(preparedOptions);\n\n    that._appendSeriesGroups();\n\n    that._createCrosshairCursor();\n\n    layoutTargets.forEach(function (_ref) {\n      var canvas = _ref.canvas;\n      trackerCanvases.push({\n        left: canvas.left,\n        right: canvas.width - canvas.right,\n        top: canvas.top,\n        bottom: canvas.height - canvas.bottom\n      });\n    });\n\n    if (that._scrollBar) {\n      argBusinessRange = that._argumentAxes[0].getTranslator().getBusinessRange();\n\n      if (\"discrete\" === argBusinessRange.axisType && argBusinessRange.categories && argBusinessRange.categories.length <= 1 || \"discrete\" !== argBusinessRange.axisType && argBusinessRange.min === argBusinessRange.max) {\n        zoomMinArg = zoomMaxArg = void 0;\n      } else {\n        zoomMinArg = argBusinessRange.minVisible;\n        zoomMaxArg = argBusinessRange.maxVisible;\n      }\n\n      that._scrollBar.init(argBusinessRange, !that._argumentAxes[0].getOptions().valueMarginsEnabled).setPosition(zoomMinArg, zoomMaxArg);\n    }\n\n    that._updateTracker(trackerCanvases);\n\n    that._updateLegendPosition(drawOptions, isLegendInside);\n\n    that._applyPointMarkersAutoHiding();\n\n    that._renderSeries(drawOptions, isRotated, isLegendInside);\n\n    that._renderer.unlock();\n  },\n  _createCrosshairCursor: noop,\n  _appendSeriesGroups: function () {\n    this._seriesGroup.linkAppend();\n\n    this._labelsGroup.linkAppend();\n\n    this._appendAdditionalSeriesGroups();\n  },\n  _renderSeries: function (drawOptions, isRotated, isLegendInside) {\n    this._calculateSeriesLayout(drawOptions, isRotated);\n\n    this._renderSeriesElements(drawOptions, isRotated, isLegendInside);\n  },\n  _calculateSeriesLayout: function (drawOptions, isRotated) {\n    drawOptions.hideLayoutLabels = this.layoutManager.needMoreSpaceForPanesCanvas(this._getLayoutTargets(), isRotated) && !this._themeManager.getOptions(\"adaptiveLayout\").keepLabels;\n\n    this._updateSeriesDimensions(drawOptions);\n  },\n  _getArgFilter: function () {\n    return function () {\n      return true;\n    };\n  },\n  _getValFilter: function (series) {\n    return function () {\n      return true;\n    };\n  },\n  _getPointsToAnimation: function (series) {\n    var _this = this;\n\n    var argViewPortFilter = this._getArgFilter();\n\n    return series.map(function (s) {\n      var valViewPortFilter = _this._getValFilter(s);\n\n      return s.getPoints().filter(function (p) {\n        return p.getOptions().visible && argViewPortFilter(p.argument) && (valViewPortFilter(p.getMinValue(true)) || valViewPortFilter(p.getMaxValue(true)));\n      }).length;\n    });\n  },\n  _renderSeriesElements: function (drawOptions, isRotated, isLegendInside) {\n    var that = this;\n    var i;\n    var series = that.series;\n    var singleSeries;\n    var seriesLength = series.length;\n\n    var resolveLabelOverlapping = that._themeManager.getOptions(\"resolveLabelOverlapping\");\n\n    var pointsToAnimation = that._getPointsToAnimation(series);\n\n    for (i = 0; i < seriesLength; i++) {\n      singleSeries = series[i];\n\n      that._applyExtraSettings(singleSeries, drawOptions);\n\n      singleSeries.draw(drawOptions.animate && pointsToAnimation[i] <= drawOptions.animationPointsLimit && that._renderer.animationEnabled(), drawOptions.hideLayoutLabels, that._getLegendCallBack(singleSeries));\n    }\n\n    if (\"none\" === resolveLabelOverlapping) {\n      that._adjustSeriesLabels(false);\n    } else {\n      that._locateLabels(resolveLabelOverlapping);\n    }\n\n    that._renderTrackers(isLegendInside);\n\n    that._tracker.repairTooltip();\n\n    that._clearCanvas();\n\n    that._renderExtraElements();\n\n    that._drawn();\n\n    that._renderCompleteHandler();\n  },\n  _locateLabels: function (resolveLabelOverlapping) {\n    this._resolveLabelOverlapping(resolveLabelOverlapping);\n  },\n  _renderExtraElements: function () {},\n  _clearCanvas: function () {\n    this._canvas = this.__originalCanvas;\n  },\n  _resolveLabelOverlapping: function (resolveLabelOverlapping) {\n    var func;\n\n    switch (resolveLabelOverlapping) {\n      case \"stack\":\n        func = this._resolveLabelOverlappingStack;\n        break;\n\n      case \"hide\":\n        func = this._resolveLabelOverlappingHide;\n        break;\n\n      case \"shift\":\n        func = this._resolveLabelOverlappingShift;\n    }\n\n    return typeUtils.isFunction(func) && func.call(this);\n  },\n  _getVisibleSeries: function () {\n    return commonUtils.grep(this.getAllSeries(), function (series) {\n      return series.isVisible();\n    });\n  },\n  _resolveLabelOverlappingHide: function () {\n    var labels = [];\n    var currentLabel;\n    var nextLabel;\n    var currentLabelRect;\n    var nextLabelRect;\n    var i;\n    var j;\n    var points;\n\n    var series = this._getVisibleSeries();\n\n    for (i = 0; i < series.length; i++) {\n      points = series[i].getVisiblePoints();\n\n      for (j = 0; j < points.length; j++) {\n        labels.push.apply(labels, points[j].getLabels());\n      }\n    }\n\n    for (i = 0; i < labels.length; i++) {\n      currentLabel = labels[i];\n\n      if (!currentLabel.isVisible()) {\n        continue;\n      }\n\n      currentLabelRect = currentLabel.getBoundingRect();\n\n      for (j = i + 1; j < labels.length; j++) {\n        nextLabel = labels[j];\n        nextLabelRect = nextLabel.getBoundingRect();\n\n        if (checkOverlapping(currentLabelRect, nextLabelRect)) {\n          nextLabel.draw(false);\n        }\n      }\n    }\n  },\n  _cleanGroups: function () {\n    var that = this;\n\n    that._stripsGroup.linkRemove().clear();\n\n    that._gridGroup.linkRemove().clear();\n\n    that._axesGroup.linkRemove().clear();\n\n    that._constantLinesGroup.above.clear();\n\n    that._labelAxesGroup.linkRemove().clear();\n\n    that._labelsGroup.linkRemove().clear();\n\n    that._crosshairCursorGroup.linkRemove().clear();\n\n    that._scaleBreaksGroup.linkRemove().clear();\n  },\n  _allowLegendInsidePosition: function () {\n    return false;\n  },\n  _updateLegendPosition: noop,\n  _createLegend: function () {\n    var that = this;\n    var legendSettings = getLegendSettings(that._legendDataField);\n    that._legend = new legendModule.Legend({\n      renderer: that._renderer,\n      widget: that,\n      group: that._legendGroup,\n      backgroundClass: \"dxc-border\",\n      itemGroupClass: \"dxc-item\",\n      titleGroupClass: \"dxc-title\",\n      textField: legendSettings.textField,\n      getFormatObject: legendSettings.getFormatObject,\n      allowInsidePosition: that._allowLegendInsidePosition()\n    });\n\n    that._updateLegend();\n\n    that._layout.add(that._legend);\n  },\n  _updateLegend: function () {\n    var that = this;\n    var themeManager = that._themeManager;\n    var legendOptions = themeManager.getOptions(\"legend\");\n\n    var legendData = that._getLegendData();\n\n    legendOptions.containerBackgroundColor = themeManager.getOptions(\"containerBackgroundColor\");\n    legendOptions._incidentOccurred = that._incidentOccurred;\n\n    that._legend.update(legendData, legendOptions, themeManager.theme(\"legend\").title);\n\n    this._change([\"LAYOUT\"]);\n  },\n  _prepareDrawOptions: function (drawOptions) {\n    var animationOptions = this._getAnimationOptions();\n\n    var options;\n    options = extend({}, {\n      force: false,\n      adjustAxes: true,\n      drawLegend: true,\n      drawTitle: true,\n      animate: animationOptions.enabled,\n      animationPointsLimit: animationOptions.maxPointCountSupported\n    }, drawOptions, this.__renderOptions);\n\n    if (!_isDefined(options.recreateCanvas)) {\n      options.recreateCanvas = options.adjustAxes && options.drawLegend && options.drawTitle;\n    }\n\n    return options;\n  },\n  _processRefreshData: function (newRefreshAction) {\n    var currentRefreshActionPosition = inArray(this._currentRefreshData, ACTIONS_BY_PRIORITY);\n    var newRefreshActionPosition = inArray(newRefreshAction, ACTIONS_BY_PRIORITY);\n\n    if (!this._currentRefreshData || currentRefreshActionPosition >= 0 && newRefreshActionPosition < currentRefreshActionPosition) {\n      this._currentRefreshData = newRefreshAction;\n    }\n\n    this._requestChange([\"REFRESH\"]);\n  },\n  _getLegendData: function () {\n    return _map(this._getLegendTargets(), function (item) {\n      var legendData = item.legendData;\n      var style = item.getLegendStyles;\n      var opacity = style.normal.opacity;\n\n      if (!item.visible) {\n        if (!_isDefined(opacity) || opacity > DEFAULT_OPACITY) {\n          opacity = DEFAULT_OPACITY;\n        }\n\n        legendData.textOpacity = DEFAULT_OPACITY;\n      }\n\n      var opacityStyle = {\n        opacity: opacity\n      };\n      legendData.states = {\n        hover: extend({}, style.hover, opacityStyle),\n        selection: extend({}, style.selection, opacityStyle),\n        normal: extend({}, style.normal, opacityStyle)\n      };\n      return legendData;\n    });\n  },\n  _getLegendOptions: function (item) {\n    return {\n      legendData: {\n        text: item[this._legendItemTextField],\n        id: item.index,\n        visible: true\n      },\n      getLegendStyles: item.getLegendStyles(),\n      visible: item.isVisible()\n    };\n  },\n  _disposeSeries: function (seriesIndex) {\n    var that = this;\n\n    if (that.series) {\n      if (_isDefined(seriesIndex)) {\n        that.series[seriesIndex].dispose();\n        that.series.splice(seriesIndex, 1);\n      } else {\n        _each(that.series, function (_, s) {\n          return s.dispose();\n        });\n\n        that.series.length = 0;\n      }\n    }\n\n    if (!that.series || !that.series.length) {\n      that.series = [];\n    }\n  },\n  _disposeSeriesFamilies: function () {\n    var that = this;\n\n    _each(that.seriesFamilies || [], function (_, family) {\n      family.dispose();\n    });\n\n    that.seriesFamilies = null;\n    that._needHandleRenderComplete = true;\n  },\n  _simulateOptionChange: function (fullName, value, previousValue) {\n    var that = this;\n    var optionSetter = coreDataUtils.compileSetter(fullName);\n    optionSetter(that._options, value, {\n      functionsAsIs: true,\n      merge: !that._getOptionsByReference()[fullName]\n    });\n\n    that._notifyOptionChanged(fullName, value, previousValue);\n\n    that._changes.reset();\n  },\n  _optionChanged: function (arg) {\n    this._themeManager.resetOptions(arg.name);\n\n    this.callBase.apply(this, arguments);\n  },\n  _applyChanges: function () {\n    var that = this;\n\n    that._themeManager.update(that._options);\n\n    that.callBase.apply(that, arguments);\n  },\n  _optionChangesMap: {\n    animation: \"ANIMATION\",\n    dataSource: \"DATA_SOURCE\",\n    palette: \"PALETTE\",\n    paletteExtensionMode: \"PALETTE\",\n    legend: \"FORCE_DATA_INIT\",\n    seriesTemplate: \"FORCE_DATA_INIT\",\n    \"export\": \"FORCE_RENDER\",\n    valueAxis: \"AXES_AND_PANES\",\n    argumentAxis: \"AXES_AND_PANES\",\n    commonAxisSettings: \"AXES_AND_PANES\",\n    panes: \"AXES_AND_PANES\",\n    defaultPane: \"AXES_AND_PANES\",\n    useAggregation: \"AXES_AND_PANES\",\n    containerBackgroundColor: \"AXES_AND_PANES\",\n    rotated: \"ROTATED\",\n    autoHidePointMarkers: \"REFRESH_SERIES_REINIT\",\n    customizePoint: \"REFRESH_SERIES_REINIT\",\n    customizeLabel: \"REFRESH_SERIES_REINIT\",\n    scrollBar: \"SCROLL_BAR\"\n  },\n  _optionChangesOrder: [\"ROTATED\", \"PALETTE\", \"REFRESH_SERIES_REINIT\", \"AXES_AND_PANES\", \"INIT\", \"REINIT\", \"DATA_SOURCE\", \"REFRESH_SERIES_DATA_INIT\", \"DATA_INIT\", \"FORCE_DATA_INIT\", \"REFRESH_AXES\", \"CORRECT_AXIS\"],\n  _customChangesOrder: [\"ANIMATION\", \"REFRESH_SERIES_FAMILIES\", \"FORCE_RENDER\", \"VISUAL_RANGE\", \"SCROLL_BAR\", \"REINIT\", \"REFRESH\", \"FULL_RENDER\"],\n  _change_ANIMATION: function () {\n    this._renderer.updateAnimationOptions(this._getAnimationOptions());\n  },\n  _change_DATA_SOURCE: function () {\n    this._needHandleRenderComplete = true;\n\n    this._updateDataSource();\n  },\n  _change_PALETTE: function () {\n    this._themeManager.updatePalette();\n\n    this._refreshSeries(\"DATA_INIT\");\n  },\n  _change_REFRESH_SERIES_DATA_INIT: function () {\n    this._refreshSeries(\"DATA_INIT\");\n  },\n  _change_DATA_INIT: function () {\n    if ((!this.series || this.needToPopulateSeries) && !this._changes.has(\"FORCE_DATA_INIT\")) {\n      this._dataInit();\n    }\n  },\n  _change_FORCE_DATA_INIT: function () {\n    this._dataInit();\n  },\n  _change_REFRESH_SERIES_FAMILIES: function () {\n    this._processSeriesFamilies();\n\n    this._populateBusinessRange();\n\n    this._processRefreshData(FORCE_RENDER_REFRESH_ACTION);\n  },\n  _change_FORCE_RENDER: function () {\n    this._processRefreshData(FORCE_RENDER_REFRESH_ACTION);\n  },\n  _change_AXES_AND_PANES: function () {\n    this._refreshSeries(\"INIT\");\n  },\n  _change_ROTATED: function () {\n    this._createScrollBar();\n\n    this._refreshSeries(\"INIT\");\n  },\n  _change_REFRESH_SERIES_REINIT: function () {\n    this._refreshSeries(\"INIT\");\n  },\n  _change_REFRESH_AXES: function () {\n    var that = this;\n\n    _setCanvasValues(that._canvas);\n\n    that._reinitAxes();\n\n    that._requestChange([\"CORRECT_AXIS\", \"FULL_RENDER\"]);\n  },\n  _change_SCROLL_BAR: function () {\n    this._createScrollBar();\n\n    this._processRefreshData(FORCE_RENDER_REFRESH_ACTION);\n  },\n  _change_REINIT: function () {\n    this._processRefreshData(REINIT_REFRESH_ACTION);\n  },\n  _refreshSeries: function (actionName) {\n    this.needToPopulateSeries = true;\n\n    this._requestChange([actionName]);\n  },\n  _change_CORRECT_AXIS: function () {\n    this._correctAxes();\n  },\n  _doRefresh: function () {\n    var methodName = this._currentRefreshData;\n\n    if (methodName) {\n      this._currentRefreshData = null;\n\n      this._renderer.stopAllAnimations(true);\n\n      this[methodName]();\n    }\n  },\n  _updateCanvasClipRect: function (canvas) {\n    var that = this;\n    var width;\n    var height;\n    width = Math.max(canvas.width - canvas.left - canvas.right, 0);\n    height = Math.max(canvas.height - canvas.top - canvas.bottom, 0);\n\n    that._canvasClipRect.attr({\n      x: canvas.left,\n      y: canvas.top,\n      width: width,\n      height: height\n    });\n\n    that._backgroundRect.attr({\n      x: canvas.left,\n      y: canvas.top,\n      width: width,\n      height: height\n    });\n  },\n  _getCanvasClipRectID: function () {\n    return this._canvasClipRect.id;\n  },\n  _dataSourceChangedHandler: function () {\n    if (this._changes.has(\"INIT\")) {\n      this._requestChange([\"DATA_INIT\"]);\n    } else {\n      this._requestChange([\"FORCE_DATA_INIT\"]);\n    }\n  },\n  _dataInit: function () {\n    this._dataSpecificInit(true);\n  },\n  _processSingleSeries: function (singleSeries) {\n    singleSeries.createPoints(false);\n  },\n  _handleSeriesDataUpdated: function () {\n    var _this2 = this;\n\n    if (this._getVisibleSeries().some(function (s) {\n      return s.useAggregation();\n    })) {\n      this._populateMarginOptions();\n    }\n\n    this.series.forEach(function (s) {\n      return _this2._processSingleSeries(s);\n    }, this);\n  },\n  _dataSpecificInit: function (needRedraw) {\n    var that = this;\n\n    if (!that.series || that.needToPopulateSeries) {\n      that.series = that._populateSeries();\n    }\n\n    that._repopulateSeries();\n\n    that._seriesPopulatedHandlerCore();\n\n    that._populateBusinessRange();\n\n    that._tracker.updateSeries(that.series, this._changes.has(\"INIT\"));\n\n    that._updateLegend();\n\n    if (needRedraw) {\n      this._requestChange([\"FULL_RENDER\"]);\n    }\n  },\n  _forceRender: function () {\n    this._doRender({\n      force: true\n    });\n  },\n  _repopulateSeries: function () {\n    var that = this;\n    var parsedData;\n    var themeManager = that._themeManager;\n\n    var data = that._dataSourceItems();\n\n    var dataValidatorOptions = themeManager.getOptions(\"dataPrepareSettings\");\n    var seriesTemplate = themeManager.getOptions(\"seriesTemplate\");\n\n    if (seriesTemplate) {\n      that._populateSeries(data);\n    }\n\n    that._groupSeries();\n\n    parsedData = dataValidatorModule.validateData(data, that._groupsData, that._incidentOccurred, dataValidatorOptions);\n    themeManager.resetPalette();\n    that.series.forEach(function (singleSeries) {\n      singleSeries.updateData(parsedData[singleSeries.getArgumentField()]);\n    });\n\n    that._handleSeriesDataUpdated();\n  },\n  _renderCompleteHandler: function () {\n    var that = this;\n    var allSeriesInited = true;\n\n    if (that._needHandleRenderComplete) {\n      _each(that.series, function (_, s) {\n        allSeriesInited = allSeriesInited && s.canRenderCompleteHandle();\n      });\n\n      if (allSeriesInited) {\n        that._needHandleRenderComplete = false;\n\n        that._eventTrigger(\"done\", {\n          target: that\n        });\n      }\n    }\n  },\n  _dataIsReady: function () {\n    return _isDefined(this.option(\"dataSource\")) && this._dataIsLoaded();\n  },\n  _populateSeriesOptions: function (data) {\n    var that = this;\n    var themeManager = that._themeManager;\n    var seriesTemplate = themeManager.getOptions(\"seriesTemplate\");\n    var seriesOptions = seriesTemplate ? vizUtils.processSeriesTemplate(seriesTemplate, data || []) : that.option(\"series\");\n    var allSeriesOptions = _isArray(seriesOptions) ? seriesOptions : seriesOptions ? [seriesOptions] : [];\n\n    var extraOptions = that._getExtraOptions();\n\n    var particularSeriesOptions;\n    var seriesTheme;\n    var seriesThemes = [];\n\n    var seriesVisibilityChanged = function (target) {\n      that._specialProcessSeries();\n\n      that._populateBusinessRange(target && target.getValueAxis(), true);\n\n      that._renderer.stopAllAnimations(true);\n\n      that._updateLegend();\n\n      that._requestChange([\"FULL_RENDER\"]);\n    };\n\n    for (var i = 0; i < allSeriesOptions.length; i++) {\n      particularSeriesOptions = extend(true, {}, allSeriesOptions[i], extraOptions);\n\n      if (!particularSeriesOptions.name) {\n        particularSeriesOptions.name = \"Series \" + (i + 1).toString();\n      }\n\n      particularSeriesOptions.rotated = that._isRotated();\n      particularSeriesOptions.customizePoint = themeManager.getOptions(\"customizePoint\");\n      particularSeriesOptions.customizeLabel = themeManager.getOptions(\"customizeLabel\");\n      particularSeriesOptions.visibilityChanged = seriesVisibilityChanged;\n      particularSeriesOptions.incidentOccurred = that._incidentOccurred;\n      seriesTheme = themeManager.getOptions(\"series\", particularSeriesOptions, allSeriesOptions.length);\n\n      if (that._checkPaneName(seriesTheme)) {\n        seriesThemes.push(seriesTheme);\n      }\n    }\n\n    return seriesThemes;\n  },\n  _populateSeries: function (data) {\n    var that = this;\n    var seriesBasis = [];\n    var incidentOccurred = that._incidentOccurred;\n\n    var seriesThemes = that._populateSeriesOptions(data);\n\n    var particularSeries;\n    var disposeSeriesFamilies = false;\n    that.needToPopulateSeries = false;\n\n    _each(seriesThemes, function (_, theme) {\n      var curSeries = that.series && that.series.filter(function (s) {\n        return s.name === theme.name && seriesBasis.map(function (sb) {\n          return sb.series;\n        }).indexOf(s) === -1;\n      })[0];\n\n      if (curSeries && curSeries.type === theme.type) {\n        seriesBasis.push({\n          series: curSeries,\n          options: theme\n        });\n      } else {\n        seriesBasis.push({\n          options: theme\n        });\n        disposeSeriesFamilies = true;\n      }\n    });\n\n    that._tracker.clearHover();\n\n    _reverseEach(that.series, function (index, series) {\n      if (!seriesBasis.some(function (s) {\n        return series === s.series;\n      })) {\n        that._disposeSeries(index);\n\n        disposeSeriesFamilies = true;\n      }\n    });\n\n    !disposeSeriesFamilies && (disposeSeriesFamilies = seriesBasis.some(function (sb) {\n      return sb.series.name !== seriesThemes[sb.series.index].name;\n    }));\n    that.series = [];\n    disposeSeriesFamilies && that._disposeSeriesFamilies();\n\n    that._themeManager.resetPalette();\n\n    var eventPipe = function (data) {\n      that.series.forEach(function (currentSeries) {\n        currentSeries.notify(data);\n      });\n    };\n\n    _each(seriesBasis, function (_, basis) {\n      var seriesTheme = basis.options;\n      var renderSettings = {\n        commonSeriesModes: that._getSelectionModes(),\n        argumentAxis: that.getArgumentAxis(),\n        valueAxis: that._getValueAxis(seriesTheme.pane, seriesTheme.axis)\n      };\n\n      if (basis.series) {\n        particularSeries = basis.series;\n        particularSeries.updateOptions(seriesTheme, renderSettings);\n      } else {\n        particularSeries = new seriesModule.Series(extend({\n          renderer: that._renderer,\n          seriesGroup: that._seriesGroup,\n          labelsGroup: that._labelsGroup,\n          eventTrigger: that._eventTrigger,\n          eventPipe: eventPipe,\n          incidentOccurred: incidentOccurred\n        }, renderSettings), seriesTheme);\n      }\n\n      if (!particularSeries.isUpdated) {\n        incidentOccurred(\"E2101\", [seriesTheme.type]);\n      } else {\n        particularSeries.index = that.series.length;\n        that.series.push(particularSeries);\n      }\n    });\n\n    return that.series;\n  },\n  getStackedPoints: function (point) {\n    var stackName = point.series.getStackName();\n    return this._getVisibleSeries().reduce(function (stackPoints, series) {\n      if (!_isDefined(series.getStackName()) && !_isDefined(stackName) || stackName === series.getStackName()) {\n        stackPoints = stackPoints.concat(series.getPointsByArg(point.argument));\n      }\n\n      return stackPoints;\n    }, []);\n  },\n  getAllSeries: function () {\n    return (this.series || []).slice();\n  },\n  getSeriesByName: function (name) {\n    var found = null;\n\n    _each(this.series, function (i, singleSeries) {\n      if (singleSeries.name === name) {\n        found = singleSeries;\n        return false;\n      }\n    });\n\n    return found;\n  },\n  getSeriesByPos: function (pos) {\n    return (this.series || [])[pos];\n  },\n  clearSelection: function () {\n    this._tracker.clearSelection();\n  },\n  hideTooltip: function () {\n    this._tracker._hideTooltip();\n  },\n  clearHover: function () {\n    this._tracker.clearHover();\n  },\n  render: function (renderOptions) {\n    var that = this;\n    that.__renderOptions = renderOptions;\n    that.__forceRender = renderOptions && renderOptions.force;\n    that.callBase.apply(that, arguments);\n    that.__renderOptions = that.__forceRender = null;\n    return that;\n  },\n  refresh: function () {\n    this._disposeSeries();\n\n    this._disposeSeriesFamilies();\n\n    this._requestChange([\"CONTAINER_SIZE\", \"REFRESH_SERIES_REINIT\"]);\n  },\n  _getMinSize: function () {\n    var adaptiveLayout = this._layoutManagerOptions();\n\n    return [adaptiveLayout.width, adaptiveLayout.height];\n  },\n  _change_REFRESH: function () {\n    if (!this._changes.has(\"INIT\")) {\n      this._doRefresh();\n    } else {\n      this._currentRefreshData = null;\n    }\n  },\n  _change_FULL_RENDER: function () {\n    this._forceRender();\n  },\n  _change_INIT: function () {\n    this._reinit();\n  },\n  _stopCurrentHandling: function () {\n    this._tracker.stopCurrentHandling();\n  }\n});\nREFRESH_SERIES_DATA_INIT_ACTION_OPTIONS.forEach(function (name) {\n  BaseChart.prototype._optionChangesMap[name] = \"REFRESH_SERIES_DATA_INIT\";\n});\nFORCE_RENDER_REFRESH_ACTION_OPTIONS.forEach(function (name) {\n  BaseChart.prototype._optionChangesMap[name] = \"FORCE_RENDER\";\n});\nREFRESH_SERIES_FAMILIES_ACTION_OPTIONS.forEach(function (name) {\n  BaseChart.prototype._optionChangesMap[name] = \"REFRESH_SERIES_FAMILIES\";\n});\nexports.overlapping = overlapping;\nexports.BaseChart = BaseChart;\nBaseChart.addPlugin(require(\"../core/export\").plugin);\nBaseChart.addPlugin(require(\"../core/title\").plugin);\nBaseChart.addPlugin(require(\"../core/tooltip\").plugin);\nBaseChart.addPlugin(require(\"../core/loading_indicator\").plugin);\nBaseChart.addPlugin(require(\"../core/data_source\").plugin);\nvar _change_TITLE = BaseChart.prototype._change_TITLE;\n\nBaseChart.prototype._change_TITLE = function () {\n  _change_TITLE.apply(this, arguments);\n\n  this._change([\"FORCE_RENDER\"]);\n};","map":null,"metadata":{},"sourceType":"script"}