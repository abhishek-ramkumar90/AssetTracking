{"ast":null,"code":"/**\r\n * DevExtreme (viz/components/data_validator.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar typeUtils = require(\"../../core/utils/type\");\n\nvar STRING = \"string\";\nvar NUMERIC = \"numeric\";\nvar DATETIME = \"datetime\";\nvar DISCRETE = \"discrete\";\nvar SEMIDISCRETE = \"semidiscrete\";\nvar CONTINUOUS = \"continuous\";\nvar LOGARITHMIC = \"logarithmic\";\nvar VALUE_TYPE = \"valueType\";\nvar ARGUMENT_TYPE = \"argumentType\";\n\nvar extend = require(\"../../core/utils/extend\").extend;\n\nvar axisTypeParser = require(\"../core/utils\").enumParser([STRING, NUMERIC, DATETIME]);\n\nvar _getParser = require(\"./parse_utils\").getParser;\n\nvar _isDefined = typeUtils.isDefined;\nvar _isFunction = typeUtils.isFunction;\nvar _isArray = Array.isArray;\nvar _isString = typeUtils.isString;\nvar _isDate = typeUtils.isDate;\nvar _isNumber = typeUtils.isNumeric;\nvar _isObject = typeUtils.isObject;\n\nfunction groupingValues(data, others, valueField, index) {\n  if (index >= 0) {\n    data.slice(index).forEach(function (cell) {\n      if (_isDefined(cell[valueField])) {\n        others[valueField] += cell[valueField];\n        cell[valueField] = void 0;\n      }\n    });\n  }\n}\n\nfunction processGroups(groups) {\n  groups.forEach(function (group) {\n    group.valueType = group.valueAxisType = null;\n    group.series.forEach(function (series) {\n      series.updateDataType({});\n    });\n    group.valueAxis && group.valueAxis.resetTypes(VALUE_TYPE);\n  });\n}\n\nfunction sortValues(data, asc, selector) {\n  var func = asc ? function (a, b) {\n    return a - b;\n  } : function (a, b) {\n    return b - a;\n  };\n  data.sort(function (a, b) {\n    var valA = selector(a);\n    var valB = selector(b);\n    var aa = _isDefined(valA) ? 1 : 0;\n    var bb = _isDefined(valB) ? 1 : 0;\n    return aa && bb ? func(valA, valB) : func(aa, bb);\n  });\n  return data;\n}\n\nfunction resetArgumentAxes(axes) {\n  axes && axes.forEach(function (axis) {\n    axis.resetTypes(ARGUMENT_TYPE);\n  });\n}\n\nfunction parseCategories(categories, parser) {\n  var newArray = [];\n  categories.forEach(function (category) {\n    var parsedCategory = parser(category);\n    void 0 !== parsedCategory && newArray.push(parsedCategory);\n  });\n  return newArray;\n}\n\nfunction parseAxisCategories(groupsData, parsers) {\n  var argumentCategories = groupsData.argumentOptions && groupsData.argumentOptions.categories;\n  groupsData.groups.forEach(function (valueGroup, i) {\n    var categories = valueGroup.valueOptions && valueGroup.valueOptions.categories;\n\n    if (categories) {\n      valueGroup.valueOptions.categories = parseCategories(categories, parsers[i + 1]);\n    }\n  });\n\n  if (argumentCategories) {\n    groupsData.argumentOptions.categories = parseCategories(argumentCategories, parsers[0]);\n  }\n}\n\nfunction eigen(x) {\n  return x;\n}\n\nfunction getType(unit, type) {\n  var result = type;\n\n  if (type === STRING || _isString(unit)) {\n    result = STRING;\n  } else {\n    if (type === DATETIME || _isDate(unit)) {\n      result = DATETIME;\n    } else {\n      if (_isNumber(unit)) {\n        result = NUMERIC;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction correctAxisType(type, axisType, hasCategories, incidentOccurred) {\n  if (type === STRING && (axisType === CONTINUOUS || axisType === LOGARITHMIC || axisType === SEMIDISCRETE)) {\n    incidentOccurred(\"E2002\");\n  }\n\n  return axisType === LOGARITHMIC ? LOGARITHMIC : hasCategories || axisType === DISCRETE || type === STRING ? DISCRETE : axisType === SEMIDISCRETE ? SEMIDISCRETE : CONTINUOUS;\n}\n\nfunction validUnit(unit, field, incidentOccurred) {\n  if (unit) {\n    incidentOccurred(!_isNumber(unit) && !_isDate(unit) && !_isString(unit) ? \"E2003\" : \"E2004\", [field]);\n  }\n}\n\nfunction createParserUnit(type, axisType, incidentOccurred) {\n  var parser = type ? _getParser(type) : eigen;\n  var filterInfinity = axisType !== DISCRETE ? function (x) {\n    return isFinite(x) || void 0 === x ? x : null;\n  } : eigen;\n  return function (unit, field) {\n    var parseUnit = filterInfinity(parser(unit));\n\n    if (void 0 === parseUnit) {\n      validUnit(unit, field, incidentOccurred);\n    }\n\n    return parseUnit;\n  };\n}\n\nfunction prepareParsers(groupsData, incidentOccurred) {\n  var argumentParser = createParserUnit(groupsData.argumentType, groupsData.argumentAxisType, incidentOccurred);\n  var sizeParser;\n  var valueParser;\n  var categoryParsers = [argumentParser];\n  var cache = {};\n  var list = [];\n  groupsData.groups.forEach(function (group, groupIndex) {\n    group.series.forEach(function (series) {\n      valueParser = createParserUnit(group.valueType, group.valueAxisType, incidentOccurred);\n      sizeParser = createParserUnit(NUMERIC, CONTINUOUS, incidentOccurred);\n      cache[series.getArgumentField()] = argumentParser;\n      series.getValueFields().forEach(function (field) {\n        categoryParsers[groupIndex + 1] = valueParser;\n        cache[field] = valueParser;\n      });\n\n      if (series.getSizeField()) {\n        cache[series.getSizeField()] = sizeParser;\n      }\n    });\n  });\n\n  for (var field in cache) {\n    list.push([field, cache[field]]);\n  }\n\n  list.length && parseAxisCategories(groupsData, categoryParsers);\n  return list;\n}\n\nfunction getParsedCell(cell, parsers) {\n  var i;\n  var ii = parsers.length;\n  var obj = extend({}, cell);\n  var field;\n  var value;\n\n  for (i = 0; i < ii; ++i) {\n    field = parsers[i][0];\n    value = cell[field];\n    obj[field] = parsers[i][1](value, field);\n  }\n\n  return obj;\n}\n\nfunction parse(data, parsers) {\n  var parsedData = [];\n  var i;\n  var ii = data.length;\n  parsedData.length = ii;\n\n  for (i = 0; i < ii; ++i) {\n    parsedData[i] = getParsedCell(data[i], parsers);\n  }\n\n  return parsedData;\n}\n\nfunction findIndexByThreshold(data, valueField, threshold) {\n  var i;\n  var ii = data.length;\n  var value;\n\n  for (i = 0; i < ii; ++i) {\n    value = data[i][valueField];\n\n    if (_isDefined(value) && threshold > value) {\n      break;\n    }\n  }\n\n  return i;\n}\n\nfunction groupMinSlices(originalData, argumentField, valueField, smallValuesGrouping) {\n  smallValuesGrouping = smallValuesGrouping || {};\n  var mode = smallValuesGrouping.mode;\n  var others = {};\n  var data;\n\n  if (!mode || \"none\" === mode) {\n    return;\n  }\n\n  others[argumentField] = String(smallValuesGrouping.groupName || \"others\");\n  others[valueField] = 0;\n  data = sortValues(originalData.slice(), false, function (a) {\n    return a[valueField];\n  });\n  groupingValues(data, others, valueField, \"smallValueThreshold\" === mode ? findIndexByThreshold(data, valueField, smallValuesGrouping.threshold) : smallValuesGrouping.topCount);\n  others[valueField] && originalData.push(others);\n}\n\nfunction groupPieData(data, groupsData) {\n  var firstSeries = groupsData.groups[0] && groupsData.groups[0].series[0];\n  var isPie = firstSeries && (\"pie\" === firstSeries.type || \"doughnut\" === firstSeries.type || \"donut\" === firstSeries.type);\n\n  if (!isPie) {\n    return;\n  }\n\n  groupsData.groups.forEach(function (group) {\n    group.series.forEach(function (series) {\n      groupMinSlices(data, series.getArgumentField(), series.getValueFields()[0], series.getOptions().smallValuesGrouping);\n    });\n  });\n}\n\nfunction addUniqueItemToCollection(item, collection, itemsHash) {\n  if (!itemsHash[item]) {\n    collection.push(item);\n    itemsHash[item] = true;\n  }\n}\n\nfunction getUniqueArgumentFields(groupsData) {\n  var uniqueArgumentFields = [];\n  var hash = {};\n  groupsData.groups.forEach(function (group) {\n    group.series.forEach(function (series) {\n      addUniqueItemToCollection(series.getArgumentField(), uniqueArgumentFields, hash);\n    });\n  });\n  return uniqueArgumentFields;\n}\n\nfunction sort(a, b) {\n  var result = a - b;\n\n  if (isNaN(result)) {\n    if (!_isDefined(a)) {\n      return 1;\n    }\n\n    if (!_isDefined(b)) {\n      return -1;\n    }\n\n    return 0;\n  }\n\n  return result;\n}\n\nfunction sortByArgument(data, argumentField) {\n  return data.slice().sort(function (a, b) {\n    return sort(a[argumentField], b[argumentField]);\n  });\n}\n\nfunction sortByCallback(data, callback) {\n  return data.slice().sort(callback);\n}\n\nfunction checkValueTypeOfGroup(group, cell) {\n  group.series.forEach(function (series) {\n    series.getValueFields().forEach(function (field) {\n      group.valueType = getType(cell[field], group.valueType);\n    });\n  });\n  return group.valueType;\n}\n\nfunction getSortByCategories(categories) {\n  var hash = {};\n  categories.forEach(function (value, i) {\n    hash[value] = i;\n  });\n  return function (data, argumentField) {\n    return sortValues(data.slice(), true, function (a) {\n      return hash[a[argumentField]];\n    });\n  };\n}\n\nfunction sortData(data, groupsData, options, uniqueArgumentFields) {\n  var dataByArguments = {};\n  var isDiscrete = groupsData.argumentAxisType === DISCRETE;\n  var userCategories = isDiscrete && groupsData.argumentOptions && groupsData.argumentOptions.categories;\n\n  var sortFunction = function (data) {\n    return data;\n  };\n\n  var sortingMethodOption = options.sortingMethod;\n  var reSortCategories;\n\n  if (!userCategories && _isFunction(sortingMethodOption)) {\n    data = sortByCallback(data, sortingMethodOption);\n  }\n\n  if (isDiscrete) {\n    groupsData.categories = getCategories(data, uniqueArgumentFields, userCategories);\n  }\n\n  if (userCategories || !_isFunction(sortingMethodOption) && groupsData.argumentType === STRING && !options._skipArgumentSorting) {\n    sortFunction = getSortByCategories(groupsData.categories);\n  } else {\n    if (true === sortingMethodOption && groupsData.argumentType !== STRING) {\n      sortFunction = sortByArgument;\n      reSortCategories = isDiscrete;\n    }\n  }\n\n  uniqueArgumentFields.forEach(function (field) {\n    dataByArguments[field] = sortFunction(data, field);\n  });\n\n  if (reSortCategories) {\n    groupsData.categories = groupsData.categories.sort(sort);\n  }\n\n  return dataByArguments;\n}\n\nfunction checkItemExistence(collection, item) {\n  return collection.map(function (collectionItem) {\n    return collectionItem.valueOf();\n  }).indexOf(item.valueOf()) === -1;\n}\n\nfunction getCategories(data, uniqueArgumentFields, userCategories) {\n  var categories = userCategories ? userCategories.slice() : [];\n  uniqueArgumentFields.forEach(function (field) {\n    data.forEach(function (item) {\n      var dataItem = item[field];\n      _isDefined(dataItem) && checkItemExistence(categories, dataItem) && categories.push(dataItem);\n    });\n  });\n  return categories;\n}\n\nfunction checkArgumentTypeOfGroup(series, cell, groupsData) {\n  series.forEach(function (currentSeries) {\n    groupsData.argumentType = getType(cell[currentSeries.getArgumentField()], groupsData.argumentType);\n  });\n  return groupsData.argumentType;\n}\n\nfunction checkType(data, groupsData, checkTypeForAllData) {\n  var groupsWithUndefinedValueType = [];\n  var groupsWithUndefinedArgumentType = [];\n  var argumentTypeGroup = groupsData.argumentOptions && axisTypeParser(groupsData.argumentOptions.argumentType);\n  var groupsIndexes;\n  groupsData.groups.forEach(function (group) {\n    if (!group.series.length) {\n      return;\n    }\n\n    var valueTypeGroup = group.valueOptions && axisTypeParser(group.valueOptions.valueType);\n    group.valueType = valueTypeGroup;\n    groupsData.argumentType = argumentTypeGroup;\n    !valueTypeGroup && groupsWithUndefinedValueType.push(group);\n    !argumentTypeGroup && groupsWithUndefinedArgumentType.push(group);\n  });\n\n  if (groupsWithUndefinedValueType.length || groupsWithUndefinedArgumentType.length) {\n    groupsIndexes = groupsWithUndefinedValueType.map(function (_, index) {\n      return index;\n    });\n    data.some(function (cell) {\n      var defineArg;\n      groupsWithUndefinedValueType.forEach(function (group, groupIndex) {\n        if (checkValueTypeOfGroup(group, cell) && groupsIndexes.indexOf(groupIndex) >= 0) {\n          groupsIndexes.splice(groupIndex, 1);\n        }\n      });\n\n      if (!defineArg) {\n        groupsWithUndefinedArgumentType.forEach(function (group) {\n          defineArg = checkArgumentTypeOfGroup(group.series, cell, groupsData);\n        });\n      }\n\n      if (!checkTypeForAllData && defineArg && 0 === groupsIndexes.length) {\n        return true;\n      }\n    });\n  }\n}\n\nfunction checkAxisType(groupsData, incidentOccurred) {\n  var argumentOptions = groupsData.argumentOptions || {};\n  var userArgumentCategories = argumentOptions && argumentOptions.categories || [];\n  var argumentAxisType = correctAxisType(groupsData.argumentType, argumentOptions.type, !!userArgumentCategories.length, incidentOccurred);\n  groupsData.groups.forEach(function (group) {\n    var valueOptions = group.valueOptions || {};\n    var valueCategories = valueOptions.categories || [];\n    var valueAxisType = correctAxisType(group.valueType, valueOptions.type, !!valueCategories.length, incidentOccurred);\n    group.series.forEach(function (series) {\n      var optionsSeries = {};\n      optionsSeries.argumentAxisType = argumentAxisType;\n      optionsSeries.valueAxisType = valueAxisType;\n      groupsData.argumentAxisType = groupsData.argumentAxisType || optionsSeries.argumentAxisType;\n      group.valueAxisType = group.valueAxisType || optionsSeries.valueAxisType;\n      optionsSeries.argumentType = groupsData.argumentType;\n      optionsSeries.valueType = group.valueType;\n      optionsSeries.showZero = valueOptions.showZero;\n      series.updateDataType(optionsSeries);\n    });\n    group.valueAxisType = group.valueAxisType || valueAxisType;\n\n    if (group.valueAxis) {\n      group.valueAxis.setTypes(group.valueAxisType, group.valueType, VALUE_TYPE);\n      group.valueAxis.validate();\n    }\n  });\n  groupsData.argumentAxisType = groupsData.argumentAxisType || argumentAxisType;\n\n  if (groupsData.argumentAxes) {\n    groupsData.argumentAxes.forEach(function (axis) {\n      axis.setTypes(groupsData.argumentAxisType, groupsData.argumentType, ARGUMENT_TYPE);\n      axis.validate();\n    });\n  }\n}\n\nfunction verifyData(source, incidentOccurred) {\n  var data = [];\n\n  var sourceIsDefined = _isDefined(source);\n\n  var hasError = sourceIsDefined && !_isArray(source);\n  var i;\n  var ii;\n  var k;\n  var item;\n\n  if (sourceIsDefined && !hasError) {\n    for (i = 0, ii = source.length, k = 0; i < ii; ++i) {\n      item = source[i];\n\n      if (_isObject(item)) {\n        data[k++] = item;\n      } else {\n        if (item) {\n          hasError = true;\n        }\n      }\n    }\n  }\n\n  if (hasError) {\n    incidentOccurred(\"E2001\");\n  }\n\n  return data;\n}\n\nfunction validateData(data, groupsData, incidentOccurred, options) {\n  var dataByArgumentFields;\n  data = verifyData(data, incidentOccurred);\n  groupsData.argumentType = groupsData.argumentAxisType = null;\n  processGroups(groupsData.groups);\n  resetArgumentAxes(groupsData.argumentAxes);\n  checkType(data, groupsData, options.checkTypeForAllData);\n  checkAxisType(groupsData, incidentOccurred);\n\n  if (options.convertToAxisDataType) {\n    data = parse(data, prepareParsers(groupsData, incidentOccurred));\n  }\n\n  groupPieData(data, groupsData);\n  dataByArgumentFields = sortData(data, groupsData, options, getUniqueArgumentFields(groupsData));\n  return dataByArgumentFields;\n}\n\nexports.validateData = validateData;","map":null,"metadata":{},"sourceType":"script"}