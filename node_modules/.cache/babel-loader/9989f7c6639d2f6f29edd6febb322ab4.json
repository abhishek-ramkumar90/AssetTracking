{"ast":null,"code":"/*!\n * devextreme-react\n * Version: 19.2.7\n * Build date: Thu Mar 26 2020\n *\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\n *\n * This software may be modified and distributed under the terms\n * of the MIT license. See the LICENSE file in the root of the project for details.\n *\n * https://github.com/DevExpress/devextreme-react\n */\n\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar React = require(\"react\");\n\nvar widget_config_1 = require(\"../../widget-config\");\n\nvar element_1 = require(\"./element\");\n\nvar utils_1 = require(\"../utils\");\n\nvar templates_1 = require(\"./templates\");\n\nfunction buildConfigTree(widgetDescriptor, props) {\n  return createConfigNode({\n    type: element_1.ElementType.Option,\n    descriptor: __assign({\n      name: \"\",\n      isCollection: false\n    }, widgetDescriptor),\n    props: props\n  }, \"\");\n}\n\nexports.buildConfigTree = buildConfigTree;\n\nfunction createConfigNode(element, path) {\n  var fullName = element.descriptor.isCollection ? path : utils_1.mergeNameParts(path, element.descriptor.name);\n  var separatedValues = widget_config_1.separateProps(element.props, element.descriptor.initialValuesProps, element.descriptor.templates);\n  var childrenData = processChildren(element, fullName);\n\n  for (var _i = 0, _a = element.descriptor.templates; _i < _a.length; _i++) {\n    var templateMeta = _a[_i];\n    var template = templates_1.getAnonymousTemplate(element.props, templateMeta, path.length > 0 ? childrenData.hasTranscludedContent : false);\n\n    if (template) {\n      childrenData.templates.push(template);\n    }\n  }\n\n  return {\n    fullName: fullName,\n    predefinedOptions: element.descriptor.predefinedValuesProps,\n    initialOptions: separatedValues.defaults,\n    options: separatedValues.options,\n    templates: childrenData.templates,\n    configCollections: childrenData.configCollections,\n    configs: childrenData.configs\n  };\n}\n\nfunction processChildren(parentElement, parentFullName) {\n  var templates = [];\n  var configCollections = {};\n  var configs = {};\n  var hasTranscludedContent = false;\n  React.Children.map(parentElement.props.children, function (child) {\n    var element = element_1.getElementInfo(child, parentElement.descriptor.expectedChildren);\n\n    if (element.type === element_1.ElementType.Unknown) {\n      hasTranscludedContent = true;\n      return;\n    }\n\n    if (element.type === element_1.ElementType.Template) {\n      var template = templates_1.getNamedTemplate(element.props);\n\n      if (template) {\n        templates.push(template);\n      }\n\n      return;\n    }\n\n    if (element.descriptor.isCollection) {\n      var collection = configCollections[element.descriptor.name];\n\n      if (!collection) {\n        collection = [];\n        configCollections[element.descriptor.name] = collection;\n      }\n\n      var collectionItem = createConfigNode(element, utils_1.mergeNameParts(parentFullName, element.descriptor.name) + \"[\" + collection.length + \"]\");\n      collection.push(collectionItem);\n      return;\n    }\n\n    var configNode = createConfigNode(element, parentFullName);\n    configs[element.descriptor.name] = configNode;\n  });\n  return {\n    configs: configs,\n    configCollections: configCollections,\n    templates: templates,\n    hasTranscludedContent: hasTranscludedContent\n  };\n}","map":null,"metadata":{},"sourceType":"script"}