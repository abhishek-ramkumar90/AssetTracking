{"ast":null,"code":"/**\r\n * DevExtreme (viz/series/points/pie_point.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar extend = require(\"../../../core/utils/extend\").extend;\n\nvar symbolPoint = require(\"./symbol_point\");\n\nvar _extend = extend;\nvar _round = Math.round;\nvar _sqrt = Math.sqrt;\nvar _acos = Math.acos;\nvar DEG = 180 / Math.PI;\nvar _abs = Math.abs;\n\nvar vizUtils = require(\"../../core/utils\");\n\nvar _normalizeAngle = vizUtils.normalizeAngle;\nvar _getCosAndSin = vizUtils.getCosAndSin;\n\nvar _isDefined = require(\"../../../core/utils/type\").isDefined;\n\nvar getVerticallyShiftedAngularCoords = vizUtils.getVerticallyShiftedAngularCoords;\n\nvar RADIAL_LABEL_INDENT = require(\"../../components/consts\").radialLabelIndent;\n\nmodule.exports = _extend({}, symbolPoint, {\n  _updateData: function (data, argumentChanged) {\n    var that = this;\n\n    symbolPoint._updateData.call(this, data);\n\n    if (argumentChanged || !_isDefined(that._visible)) {\n      that._visible = true;\n    }\n\n    that.minValue = that.initialMinValue = that.originalMinValue = _isDefined(data.minValue) ? data.minValue : 0;\n  },\n  animate: function (complete, duration, delay) {\n    var that = this;\n    that.graphic.animate({\n      x: that.centerX,\n      y: that.centerY,\n      outerRadius: that.radiusOuter,\n      innerRadius: that.radiusInner,\n      startAngle: that.toAngle,\n      endAngle: that.fromAngle\n    }, {\n      delay: delay,\n      partitionDuration: duration\n    }, complete);\n  },\n  correctPosition: function (correction) {\n    var that = this;\n    that.correctRadius(correction);\n    that.correctLabelRadius(correction.radiusOuter + RADIAL_LABEL_INDENT);\n    that.centerX = correction.centerX;\n    that.centerY = correction.centerY;\n  },\n  correctRadius: function (correction) {\n    this.radiusInner = correction.radiusInner;\n    this.radiusOuter = correction.radiusOuter;\n  },\n  correctLabelRadius: function (radiusLabels) {\n    this.radiusLabels = radiusLabels;\n  },\n  correctValue: function (correction, percent, base) {\n    var that = this;\n    that.value = (base || that.normalInitialValue) + correction;\n    that.minValue = correction;\n    that.percent = percent;\n\n    that._label.setDataField(\"percent\", percent);\n  },\n  _updateLabelData: function () {\n    this._label.setData(this._getLabelFormatObject());\n  },\n  _getShiftLabelCoords: function () {\n    var that = this;\n\n    var bBox = that._label.getBoundingRect();\n\n    var coord = that._getLabelCoords(that._label);\n\n    var visibleArea = that._getVisibleArea();\n\n    if (that._isLabelDrawingWithoutPoints) {\n      return that._checkLabelPosition(coord, bBox, visibleArea);\n    } else {\n      return that._getLabelExtraCoord(coord, that._checkVerticalLabelPosition(coord, bBox, visibleArea), bBox);\n    }\n  },\n  _getLabelPosition: function (options) {\n    return options.position;\n  },\n  _getLabelCoords: function (label) {\n    var that = this;\n    var bBox = label.getBoundingRect();\n    var options = label.getLayoutOptions();\n\n    var angleFunctions = _getCosAndSin(that.middleAngle);\n\n    var position = that._getLabelPosition(options);\n\n    var radiusInner = that.radiusInner;\n    var radiusOuter = that.radiusOuter;\n    var radiusLabels = that.radiusLabels;\n    var columnsPosition = \"columns\" === position;\n    var rad;\n    var x;\n\n    if (\"inside\" === position) {\n      rad = radiusInner + (radiusOuter - radiusInner) / 2 + options.radialOffset;\n      x = that.centerX + rad * angleFunctions.cos - bBox.width / 2;\n    } else {\n      rad = radiusLabels + options.radialOffset;\n\n      if (angleFunctions.cos > .1 || columnsPosition && angleFunctions.cos >= 0) {\n        x = that.centerX + rad * angleFunctions.cos;\n      } else {\n        if (angleFunctions.cos < -.1 || columnsPosition && angleFunctions.cos < 0) {\n          x = that.centerX + rad * angleFunctions.cos - bBox.width;\n        } else {\n          x = that.centerX + rad * angleFunctions.cos - bBox.width / 2;\n        }\n      }\n    }\n\n    return {\n      x: x,\n      y: _round(that.centerY - rad * angleFunctions.sin - bBox.height / 2)\n    };\n  },\n  _correctLabelCoord: function (coord, moveLabelsFromCenter) {\n    var that = this;\n    var label = that._label;\n    var bBox = label.getBoundingRect();\n    var labelWidth = bBox.width;\n    var options = label.getLayoutOptions();\n\n    var visibleArea = that._getVisibleArea();\n\n    var rightBorderX = visibleArea.maxX - labelWidth;\n    var leftBorderX = visibleArea.minX;\n\n    var angleOfPoint = _normalizeAngle(that.middleAngle);\n\n    var centerX = that.centerX;\n    var connectorOffset = options.connectorOffset;\n    var x = coord.x;\n\n    if (\"columns\" === options.position) {\n      if (angleOfPoint <= 90 || angleOfPoint >= 270) {\n        x = rightBorderX;\n      } else {\n        x = leftBorderX;\n      }\n\n      coord.x = x;\n    } else {\n      if (\"inside\" !== options.position && moveLabelsFromCenter) {\n        if (angleOfPoint <= 90 || angleOfPoint >= 270) {\n          if (x - connectorOffset < centerX) {\n            x = centerX + connectorOffset;\n          }\n        } else {\n          if (x + labelWidth + connectorOffset > centerX) {\n            x = centerX - labelWidth - connectorOffset;\n          }\n        }\n\n        coord.x = x;\n      }\n    }\n\n    return coord;\n  },\n  drawLabel: function () {\n    this.translate();\n    this._isLabelDrawingWithoutPoints = true;\n\n    this._drawLabel();\n\n    this._isLabelDrawingWithoutPoints = false;\n  },\n  updateLabelCoord: function (moveLabelsFromCenter) {\n    var that = this;\n\n    var bBox = that._label.getBoundingRect();\n\n    var coord = that._correctLabelCoord(bBox, moveLabelsFromCenter);\n\n    coord = that._checkHorizontalLabelPosition(coord, bBox, that._getVisibleArea());\n\n    that._label.shift(_round(coord.x), _round(bBox.y));\n  },\n  _checkVerticalLabelPosition: function (coord, box, visibleArea) {\n    var x = coord.x;\n    var y = coord.y;\n\n    if (coord.y + box.height > visibleArea.maxY) {\n      y = visibleArea.maxY - box.height;\n    } else {\n      if (coord.y < visibleArea.minY) {\n        y = visibleArea.minY;\n      }\n    }\n\n    return {\n      x: x,\n      y: y\n    };\n  },\n  _getLabelExtraCoord: function (coord, shiftCoord, box) {\n    return coord.y !== shiftCoord.y ? getVerticallyShiftedAngularCoords({\n      x: coord.x,\n      y: coord.y,\n      width: box.width,\n      height: box.height\n    }, shiftCoord.y - coord.y, {\n      x: this.centerX,\n      y: this.centerY\n    }) : coord;\n  },\n  _checkHorizontalLabelPosition: function (coord, box, visibleArea) {\n    var x = coord.x;\n    var y = coord.y;\n\n    if (coord.x + box.width > visibleArea.maxX) {\n      x = visibleArea.maxX - box.width;\n    } else {\n      if (coord.x < visibleArea.minX) {\n        x = visibleArea.minX;\n      }\n    }\n\n    return {\n      x: x,\n      y: y\n    };\n  },\n  applyWordWrap: function (moveLabelsFromCenter) {\n    var that = this;\n    var label = that._label;\n    var box = label.getBoundingRect();\n\n    var visibleArea = that._getVisibleArea();\n\n    var position = label.getLayoutOptions().position;\n    var width = box.width;\n    var rowCountChanged = false;\n\n    if (\"columns\" === position && that.series.index > 0) {\n      width = visibleArea.maxX - that.centerX - that.radiusLabels;\n    } else {\n      if (\"inside\" === position) {\n        if (width > visibleArea.maxX - visibleArea.minX) {\n          width = visibleArea.maxX - visibleArea.minX;\n        }\n      } else {\n        if (moveLabelsFromCenter && box.x < that.centerX && box.width + box.x > that.centerX) {\n          width = Math.floor((visibleArea.maxX - visibleArea.minX) / 2);\n        } else {\n          if (box.x + width > visibleArea.maxX) {\n            width = visibleArea.maxX - box.x;\n          } else {\n            if (box.x < visibleArea.minX) {\n              width = box.x + width - visibleArea.minX;\n            }\n          }\n        }\n      }\n    }\n\n    if (width < box.width) {\n      rowCountChanged = label.fit(width);\n    }\n\n    return rowCountChanged;\n  },\n  setLabelTrackerData: function () {\n    this._label.setTrackerData(this);\n  },\n  _checkLabelPosition: function (coord, bBox, visibleArea) {\n    coord = this._checkHorizontalLabelPosition(coord, bBox, visibleArea);\n    return this._checkVerticalLabelPosition(coord, bBox, visibleArea);\n  },\n  _getLabelConnector: function () {\n    var that = this;\n    var rad = that.radiusOuter;\n    var seriesStyle = that._options.styles.normal;\n    var strokeWidthBy2 = seriesStyle[\"stroke-width\"] / 2;\n    var borderWidth = that.series.getOptions().containerBackgroundColor === seriesStyle.stroke ? _round(strokeWidthBy2) : _round(-strokeWidthBy2);\n\n    var angleFunctions = _getCosAndSin(_round(that.middleAngle));\n\n    return {\n      x: _round(that.centerX + (rad - borderWidth) * angleFunctions.cos),\n      y: _round(that.centerY - (rad - borderWidth) * angleFunctions.sin),\n      angle: that.middleAngle\n    };\n  },\n  _drawMarker: function (renderer, group, animationEnabled, firstDrawing) {\n    var that = this;\n    var radiusOuter = that.radiusOuter;\n    var radiusInner = that.radiusInner;\n    var fromAngle = that.fromAngle;\n    var toAngle = that.toAngle;\n\n    if (animationEnabled) {\n      radiusInner = radiusOuter = 0;\n\n      if (!firstDrawing) {\n        fromAngle = toAngle = that.shiftedAngle;\n      }\n    }\n\n    that.graphic = renderer.arc(that.centerX, that.centerY, radiusInner, radiusOuter, toAngle, fromAngle).attr({\n      \"stroke-linejoin\": \"round\"\n    }).smartAttr(that._getStyle()).data({\n      \"chart-data-point\": that\n    }).sharp().append(group);\n  },\n  getTooltipParams: function () {\n    var that = this;\n\n    var angleFunctions = _getCosAndSin(that.middleAngle);\n\n    var radiusInner = that.radiusInner;\n    var radiusOuter = that.radiusOuter;\n    return {\n      x: that.centerX + (radiusInner + (radiusOuter - radiusInner) / 2) * angleFunctions.cos,\n      y: that.centerY - (radiusInner + (radiusOuter - radiusInner) / 2) * angleFunctions.sin,\n      offset: 0\n    };\n  },\n  _translate: function () {\n    var that = this;\n    var angle = that.shiftedAngle || 0;\n    var value = that.value;\n    var minValue = that.minValue;\n\n    var translator = that._getValTranslator();\n\n    that.fromAngle = translator.translate(minValue) + angle;\n    that.toAngle = translator.translate(value) + angle;\n    that.middleAngle = translator.translate((value - minValue) / 2 + minValue) + angle;\n\n    if (!that.isVisible()) {\n      that.middleAngle = that.toAngle = that.fromAngle = that.fromAngle || angle;\n    }\n  },\n  getMarkerVisibility: function () {\n    return true;\n  },\n  _updateMarker: function (animationEnabled, style, _, callback) {\n    var that = this;\n\n    if (!animationEnabled) {\n      style = _extend({\n        x: that.centerX,\n        y: that.centerY,\n        outerRadius: that.radiusOuter,\n        innerRadius: that.radiusInner,\n        startAngle: that.toAngle,\n        endAngle: that.fromAngle\n      }, style);\n    }\n\n    that.graphic.smartAttr(style).sharp();\n    callback && callback();\n  },\n  getLegendStyles: function () {\n    return this._styles.legendStyles;\n  },\n  isInVisibleArea: function () {\n    return true;\n  },\n  hide: function () {\n    var that = this;\n\n    if (that._visible) {\n      that._visible = false;\n      that.hideTooltip();\n\n      that._options.visibilityChanged();\n    }\n  },\n  show: function () {\n    var that = this;\n\n    if (!that._visible) {\n      that._visible = true;\n\n      that._options.visibilityChanged();\n    }\n  },\n  setInvisibility: function () {\n    this._label.draw(false);\n  },\n  isVisible: function () {\n    return this._visible;\n  },\n  _getFormatObject: function (tooltip) {\n    var formatObject = symbolPoint._getFormatObject.call(this, tooltip);\n\n    var percent = this.percent;\n    formatObject.percent = percent;\n    formatObject.percentText = tooltip.formatValue(percent, \"percent\");\n    return formatObject;\n  },\n  getColor: function () {\n    return this._styles.normal.fill;\n  },\n  coordsIn: function (x, y) {\n    var that = this;\n    var lx = x - that.centerX;\n    var ly = y - that.centerY;\n\n    var r = _sqrt(lx * lx + ly * ly);\n\n    var fromAngle = that.fromAngle % 360;\n    var toAngle = that.toAngle % 360;\n    var angle;\n\n    if (r < that.radiusInner || r > that.radiusOuter || 0 === r) {\n      return false;\n    }\n\n    angle = _acos(lx / r) * DEG * (ly > 0 ? -1 : 1);\n\n    if (angle < 0) {\n      angle += 360;\n    }\n\n    if (fromAngle === toAngle && _abs(that.toAngle - that.fromAngle) > 1e-4) {\n      return true;\n    } else {\n      return fromAngle >= toAngle ? angle <= fromAngle && angle >= toAngle : !(angle >= fromAngle && angle <= toAngle);\n    }\n  }\n});","map":null,"metadata":{},"sourceType":"script"}