{"ast":null,"code":"/**\r\n * DevExtreme (localization/ldml/date.parser.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar escapeRegExp = require(\"../../core/utils/common\").escapeRegExp;\n\nvar FORMAT_TYPES = {\n  3: \"abbreviated\",\n  4: \"wide\",\n  5: \"narrow\"\n};\n\nvar monthRegExpGenerator = function (count, dateParts) {\n  if (count > 2) {\n    return Object.keys(FORMAT_TYPES).map(function (count) {\n      return [\"format\", \"standalone\"].map(function (type) {\n        return dateParts.getMonthNames(FORMAT_TYPES[count], type).join(\"|\");\n      }).join(\"|\");\n    }).join(\"|\");\n  }\n\n  return \"0?[1-9]|1[012]\";\n};\n\nvar PATTERN_REGEXPS = {\n  y: function (count) {\n    return \"[0-9]+\";\n  },\n  M: monthRegExpGenerator,\n  L: monthRegExpGenerator,\n  Q: function (count, dateParts) {\n    if (count > 2) {\n      return dateParts.getQuarterNames(FORMAT_TYPES[count], \"format\").join(\"|\");\n    }\n\n    return \"0?[1-4]\";\n  },\n  E: function (count, dateParts) {\n    return \"\\\\D*\";\n  },\n  a: function (count, dateParts) {\n    return dateParts.getPeriodNames(FORMAT_TYPES[count < 3 ? 3 : count], \"format\").join(\"|\");\n  },\n  d: function (count) {\n    return \"0?[1-9]|[12][0-9]|3[01]\";\n  },\n  H: function (count) {\n    return \"0?[0-9]|1[0-9]|2[0-3]\";\n  },\n  h: function (count) {\n    return \"0?[1-9]|1[012]\";\n  },\n  m: function (count) {\n    return \"0?[0-9]|[1-5][0-9]\";\n  },\n  s: function (count) {\n    return \"0?[0-9]|[1-5][0-9]\";\n  },\n  S: function (count) {\n    return \"[0-9]{1,\" + count + \"}\";\n  }\n};\nvar parseNumber = Number;\n\nvar caseInsensitiveIndexOf = function (array, value) {\n  return array.map(function (item) {\n    return item.toLowerCase();\n  }).indexOf(value.toLowerCase());\n};\n\nvar monthPatternParser = function (text, count, dateParts) {\n  if (count > 2) {\n    return [\"format\", \"standalone\"].map(function (type) {\n      return Object.keys(FORMAT_TYPES).map(function (count) {\n        var monthNames = dateParts.getMonthNames(FORMAT_TYPES[count], type);\n        return caseInsensitiveIndexOf(monthNames, text);\n      });\n    }).reduce(function (a, b) {\n      return a.concat(b);\n    }).filter(function (index) {\n      return index >= 0;\n    })[0];\n  }\n\n  return parseNumber(text) - 1;\n};\n\nvar PATTERN_PARSERS = {\n  y: function (text, count) {\n    var year = parseNumber(text);\n\n    if (2 === count) {\n      return year < 30 ? 2e3 + year : 1900 + year;\n    }\n\n    return year;\n  },\n  M: monthPatternParser,\n  L: monthPatternParser,\n  Q: function (text, count, dateParts) {\n    if (count > 2) {\n      return dateParts.getQuarterNames(FORMAT_TYPES[count], \"format\").indexOf(text);\n    }\n\n    return parseNumber(text) - 1;\n  },\n  E: function (text, count, dateParts) {\n    var dayNames = dateParts.getDayNames(FORMAT_TYPES[count < 3 ? 3 : count], \"format\");\n    return caseInsensitiveIndexOf(dayNames, text);\n  },\n  a: function (text, count, dateParts) {\n    var periodNames = dateParts.getPeriodNames(FORMAT_TYPES[count < 3 ? 3 : count], \"format\");\n    return caseInsensitiveIndexOf(periodNames, text);\n  },\n  d: parseNumber,\n  H: parseNumber,\n  h: parseNumber,\n  m: parseNumber,\n  s: parseNumber,\n  S: function (text, count) {\n    count = Math.max(count, 3);\n    text = text.slice(0, 3);\n\n    while (count < 3) {\n      text += \"0\";\n      count++;\n    }\n\n    return parseNumber(text);\n  }\n};\nvar ORDERED_PATTERNS = [\"y\", \"M\", \"d\", \"h\", \"m\", \"s\", \"S\"];\nvar PATTERN_SETTERS = {\n  y: \"setFullYear\",\n  M: \"setMonth\",\n  L: \"setMonth\",\n  a: function (date, value, datePartValues) {\n    var hours = date.getHours();\n    var hourPartValue = datePartValues.h;\n\n    if (void 0 !== hourPartValue && hourPartValue !== hours) {\n      hours--;\n    }\n\n    if (!value && 12 === hours) {\n      hours = 0;\n    } else {\n      if (value && 12 !== hours) {\n        hours += 12;\n      }\n    }\n\n    date.setHours(hours);\n  },\n  d: \"setDate\",\n  H: \"setHours\",\n  h: \"setHours\",\n  m: \"setMinutes\",\n  s: \"setSeconds\",\n  S: \"setMilliseconds\"\n};\n\nvar getSameCharCount = function (text, index) {\n  var char = text[index];\n  var count = 0;\n\n  do {\n    index++;\n    count++;\n  } while (text[index] === char);\n\n  return count;\n};\n\nvar createPattern = function (char, count) {\n  var result = \"\";\n\n  for (var i = 0; i < count; i++) {\n    result += char;\n  }\n\n  return result;\n};\n\nvar getRegExpInfo = function (format, dateParts) {\n  var regexpText = \"\";\n  var stubText = \"\";\n  var isEscaping;\n  var patterns = [];\n\n  var addPreviousStub = function () {\n    if (stubText) {\n      patterns.push(\"'\" + stubText + \"'\");\n      regexpText += escapeRegExp(stubText) + \")\";\n      stubText = \"\";\n    }\n  };\n\n  for (var i = 0; i < format.length; i++) {\n    var char = format[i];\n    var isEscapeChar = \"'\" === char;\n    var regexpPart = PATTERN_REGEXPS[char];\n\n    if (isEscapeChar) {\n      isEscaping = !isEscaping;\n\n      if (\"'\" !== format[i - 1]) {\n        continue;\n      }\n    }\n\n    if (regexpPart && !isEscaping) {\n      var count = getSameCharCount(format, i);\n      var pattern = createPattern(char, count);\n      addPreviousStub();\n      patterns.push(pattern);\n      regexpText += \"(\" + regexpPart(count, dateParts) + \")\";\n      i += count - 1;\n    } else {\n      if (!stubText) {\n        regexpText += \"(\";\n      }\n\n      stubText += char;\n    }\n  }\n\n  addPreviousStub();\n  return {\n    patterns: patterns,\n    regexp: new RegExp(\"^\" + regexpText + \"$\", \"i\")\n  };\n};\n\nvar getPatternSetters = function () {\n  return PATTERN_SETTERS;\n};\n\nvar setPatternPart = function (date, pattern, text, dateParts, datePartValues) {\n  var patternChar = pattern[0];\n  var partSetter = PATTERN_SETTERS[patternChar];\n  var partParser = PATTERN_PARSERS[patternChar];\n\n  if (partSetter && partParser) {\n    var value = partParser(text, pattern.length, dateParts);\n    datePartValues[pattern] = value;\n\n    if (date[partSetter]) {\n      date[partSetter](value);\n    } else {\n      partSetter(date, value, datePartValues);\n    }\n  }\n};\n\nvar setPatternPartFromNow = function (date, pattern, now) {\n  var setterName = PATTERN_SETTERS[pattern];\n  var getterName = \"g\" + setterName.substr(1);\n  var value = now[getterName]();\n  date[setterName](value);\n};\n\nvar getShortPatterns = function (fullPatterns) {\n  return fullPatterns.map(function (pattern) {\n    if (\"'\" === pattern[0]) {\n      return \"\";\n    } else {\n      return \"H\" === pattern[0] ? \"h\" : pattern[0];\n    }\n  });\n};\n\nvar getMaxOrderedPatternIndex = function (patterns) {\n  var indexes = patterns.map(function (pattern) {\n    return ORDERED_PATTERNS.indexOf(pattern);\n  });\n  return Math.max.apply(Math, indexes);\n};\n\nvar getOrderedFormatPatterns = function (formatPatterns) {\n  var otherPatterns = formatPatterns.filter(function (pattern) {\n    return ORDERED_PATTERNS.indexOf(pattern) < 0;\n  });\n  return ORDERED_PATTERNS.concat(otherPatterns);\n};\n\nvar getParser = function (format, dateParts) {\n  var regExpInfo = getRegExpInfo(format, dateParts);\n  return function (text) {\n    var regExpResult = regExpInfo.regexp.exec(text);\n\n    if (regExpResult) {\n      var now = new Date();\n      var date = new Date(now.getFullYear(), 0, 1);\n      var formatPatterns = getShortPatterns(regExpInfo.patterns);\n      var maxPatternIndex = getMaxOrderedPatternIndex(formatPatterns);\n      var orderedFormatPatterns = getOrderedFormatPatterns(formatPatterns);\n      var datePartValues = {};\n      orderedFormatPatterns.forEach(function (pattern, index) {\n        if (!pattern || index < ORDERED_PATTERNS.length && index > maxPatternIndex) {\n          return;\n        }\n\n        var patternIndex = formatPatterns.indexOf(pattern);\n\n        if (patternIndex >= 0) {\n          var regExpPattern = regExpInfo.patterns[patternIndex];\n          var regExpText = regExpResult[patternIndex + 1];\n          setPatternPart(date, regExpPattern, regExpText, dateParts, datePartValues);\n        } else {\n          setPatternPartFromNow(date, pattern, now);\n        }\n      });\n      return date;\n    }\n\n    return null;\n  };\n};\n\nexports.getParser = getParser;\nexports.getRegExpInfo = getRegExpInfo;\nexports.getPatternSetters = getPatternSetters;","map":null,"metadata":{},"sourceType":"script"}