{"ast":null,"code":"/**\r\n * DevExtreme (core/utils/math.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar isExponential = require(\"./type\").isExponential;\n\nvar sign = function (value) {\n  if (0 === value) {\n    return 0;\n  }\n\n  return value / Math.abs(value);\n};\n\nvar fitIntoRange = function (value, minValue, maxValue) {\n  var isMinValueUndefined = !minValue && 0 !== minValue;\n  var isMaxValueUndefined = !maxValue && 0 !== maxValue;\n  isMinValueUndefined && (minValue = !isMaxValueUndefined ? Math.min(value, maxValue) : value);\n  isMaxValueUndefined && (maxValue = !isMinValueUndefined ? Math.max(value, minValue) : value);\n  return Math.min(Math.max(value, minValue), maxValue);\n};\n\nvar inRange = function (value, minValue, maxValue) {\n  return value >= minValue && value <= maxValue;\n};\n\nfunction getExponent(value) {\n  return Math.abs(parseInt(value.toExponential().split(\"e\")[1]));\n}\n\nfunction _isEdgeBug() {\n  var value = 3e-4;\n  var correctValue = \"0.000300\";\n  var precisionValue = 3;\n  return correctValue !== value.toPrecision(precisionValue);\n}\n\nfunction adjust(value, interval) {\n  var precision = getPrecision(interval || 0) + 2;\n  var separatedValue = value.toString().split(\".\");\n  var sourceValue = value;\n  var absValue = Math.abs(value);\n  var separatedAdjustedValue;\n  var isExponentValue = isExponential(value);\n  var integerPart = absValue > 1 ? 10 : 0;\n\n  if (1 === separatedValue.length) {\n    return value;\n  }\n\n  if (!isExponentValue) {\n    if (isExponential(interval)) {\n      precision = separatedValue[0].length + getExponent(interval);\n    }\n\n    value = absValue;\n    value = value - Math.floor(value) + integerPart;\n  }\n\n  precision = _isEdgeBug() && getExponent(value) > 6 || precision > 7 ? 15 : 7;\n\n  if (!isExponentValue) {\n    separatedAdjustedValue = parseFloat(value.toPrecision(precision)).toString().split(\".\");\n\n    if (separatedAdjustedValue[0] === integerPart.toString()) {\n      return parseFloat(separatedValue[0] + \".\" + separatedAdjustedValue[1]);\n    }\n  }\n\n  return parseFloat(sourceValue.toPrecision(precision));\n}\n\nfunction getPrecision(value) {\n  var str = value.toString();\n  var mantissa;\n  var positionOfDelimiter;\n\n  if (str.indexOf(\".\") < 0) {\n    return 0;\n  }\n\n  mantissa = str.split(\".\");\n  positionOfDelimiter = mantissa[1].indexOf(\"e\");\n  return positionOfDelimiter >= 0 ? positionOfDelimiter : mantissa[1].length;\n}\n\nfunction getRoot(x, n) {\n  if (x < 0 && n % 2 !== 1) {\n    return NaN;\n  }\n\n  var y = Math.pow(Math.abs(x), 1 / n);\n  return n % 2 === 1 && x < 0 ? -y : y;\n}\n\nfunction solveCubicEquation(a, b, c, d) {\n  var min = 1e-8;\n\n  if (Math.abs(a) < min) {\n    a = b;\n    b = c;\n    c = d;\n\n    if (Math.abs(a) < min) {\n      a = b;\n      b = c;\n\n      if (Math.abs(a) < min) {\n        return [];\n      }\n\n      return [-b / a];\n    }\n\n    var D2 = b * b - 4 * a * c;\n\n    if (Math.abs(D2) < min) {\n      return [-b / (2 * a)];\n    } else {\n      if (D2 > 0) {\n        return [(-b + Math.sqrt(D2)) / (2 * a), (-b - Math.sqrt(D2)) / (2 * a)];\n      }\n    }\n\n    return [];\n  }\n\n  var p = (3 * a * c - b * b) / (3 * a * a);\n  var q = (2 * b * b * b - 9 * a * b * c + 27 * a * a * d) / (27 * a * a * a);\n  var roots;\n  var u;\n\n  if (Math.abs(p) < min) {\n    roots = [getRoot(-q, 3)];\n  } else {\n    if (Math.abs(q) < min) {\n      roots = [0].concat(p < 0 ? [Math.sqrt(-p), -Math.sqrt(-p)] : []);\n    } else {\n      var D3 = q * q / 4 + p * p * p / 27;\n\n      if (Math.abs(D3) < min) {\n        roots = [-1.5 * q / p, 3 * q / p];\n      } else {\n        if (D3 > 0) {\n          u = getRoot(-q / 2 - Math.sqrt(D3), 3);\n          roots = [u - p / (3 * u)];\n        } else {\n          u = 2 * Math.sqrt(-p / 3);\n          var t = Math.acos(3 * q / p / u) / 3;\n          var k = 2 * Math.PI / 3;\n          roots = [u * Math.cos(t), u * Math.cos(t - k), u * Math.cos(t - 2 * k)];\n        }\n      }\n    }\n  }\n\n  for (var i = 0; i < roots.length; i++) {\n    roots[i] -= b / (3 * a);\n  }\n\n  return roots;\n}\n\nexports.sign = sign;\nexports.fitIntoRange = fitIntoRange;\nexports.inRange = inRange;\nexports.adjust = adjust;\nexports.getPrecision = getPrecision;\nexports.getExponent = getExponent;\nexports.getRoot = getRoot;\nexports.solveCubicEquation = solveCubicEquation;","map":null,"metadata":{},"sourceType":"script"}