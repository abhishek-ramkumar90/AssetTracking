{"ast":null,"code":"/**\r\n * DevExtreme (localization/ldml/number.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar fitIntoRange = require(\"../../core/utils/math\").fitIntoRange;\n\nvar toFixed = require(\"../utils\").toFixed;\n\nvar DEFAULT_CONFIG = {\n  thousandsSeparator: \",\",\n  decimalSeparator: \".\"\n};\nvar ESCAPING_CHAR = \"'\";\nvar MAXIMUM_NUMBER_LENGTH = 15;\n\nfunction getGroupSizes(formatString) {\n  return formatString.split(\",\").slice(1).map(function (str) {\n    return str.split(\"\").filter(function (char) {\n      return \"#\" === char || \"0\" === char;\n    }).length;\n  });\n}\n\nfunction getSignParts(format) {\n  var signParts = format.split(\";\");\n\n  if (1 === signParts.length) {\n    signParts.push(\"-\" + signParts[0]);\n  }\n\n  return signParts;\n}\n\nfunction reverseString(str) {\n  return str.toString().split(\"\").reverse().join(\"\");\n}\n\nfunction isPercentFormat(format) {\n  return format.indexOf(\"%\") !== -1 && !format.match(/'[^']*%[^']*'/g);\n}\n\nfunction getNonRequiredDigitCount(floatFormat) {\n  if (!floatFormat) {\n    return 0;\n  }\n\n  return floatFormat.length - floatFormat.replace(/[#]/g, \"\").length;\n}\n\nfunction getRequiredDigitCount(floatFormat) {\n  if (!floatFormat) {\n    return 0;\n  }\n\n  return floatFormat.length - floatFormat.replace(/[0]/g, \"\").length;\n}\n\nfunction normalizeValueString(valuePart, minDigitCount, maxDigitCount) {\n  if (!valuePart) {\n    return \"\";\n  }\n\n  if (valuePart.length > maxDigitCount) {\n    valuePart = valuePart.substr(0, maxDigitCount);\n  }\n\n  while (valuePart.length > minDigitCount && \"0\" === valuePart.slice(-1)) {\n    valuePart = valuePart.substr(0, valuePart.length - 1);\n  }\n\n  while (valuePart.length < minDigitCount) {\n    valuePart += \"0\";\n  }\n\n  return valuePart;\n}\n\nfunction applyGroups(valueString, groupSizes, thousandsSeparator) {\n  if (!groupSizes.length) {\n    return valueString;\n  }\n\n  var groups = [];\n  var index = 0;\n\n  while (valueString) {\n    var groupSize = groupSizes[index];\n\n    if (!groupSize) {\n      break;\n    }\n\n    groups.push(valueString.slice(0, groupSize));\n    valueString = valueString.slice(groupSize);\n\n    if (index < groupSizes.length - 1) {\n      index++;\n    }\n  }\n\n  return groups.join(thousandsSeparator);\n}\n\nfunction formatNumberPart(format, valueString) {\n  return format.split(ESCAPING_CHAR).map(function (formatPart, escapeIndex) {\n    var isEscape = escapeIndex % 2;\n\n    if (!formatPart && isEscape) {\n      return ESCAPING_CHAR;\n    }\n\n    return isEscape ? formatPart : formatPart.replace(/[,#0]+/, valueString);\n  }).join(\"\");\n}\n\nfunction getFloatPointIndex(format) {\n  var isEscape = false;\n\n  for (var index = 0; index < format.length; index++) {\n    if (\"'\" === format[index]) {\n      isEscape = !isEscape;\n    }\n\n    if (\".\" === format[index] && !isEscape) {\n      return index;\n    }\n  }\n\n  return format.length;\n}\n\nfunction getFormatter(format, config) {\n  config = config || DEFAULT_CONFIG;\n  return function (value) {\n    if (\"number\" !== typeof value || isNaN(value)) {\n      return \"\";\n    }\n\n    var signFormatParts = getSignParts(format);\n    var isPositiveZero = 1 / value === 1 / 0;\n    var isPositive = value > 0 || isPositiveZero;\n    var numberFormat = signFormatParts[isPositive ? 0 : 1];\n\n    if (isPercentFormat(numberFormat)) {\n      value = 100 * value;\n    }\n\n    if (!isPositive) {\n      value = -value;\n    }\n\n    var floatPointIndex = getFloatPointIndex(numberFormat);\n    var floatFormatParts = [numberFormat.substr(0, floatPointIndex), numberFormat.substr(floatPointIndex + 1)];\n    var minFloatPrecision = getRequiredDigitCount(floatFormatParts[1]);\n    var maxFloatPrecision = minFloatPrecision + getNonRequiredDigitCount(floatFormatParts[1]);\n    var minIntegerPrecision = getRequiredDigitCount(floatFormatParts[0]);\n    var maxIntegerPrecision = getNonRequiredDigitCount(floatFormatParts[0]) ? void 0 : minIntegerPrecision;\n    var integerLength = Math.floor(value).toString().length;\n    var floatPrecision = fitIntoRange(maxFloatPrecision, 0, MAXIMUM_NUMBER_LENGTH - integerLength);\n    var groupSizes = getGroupSizes(floatFormatParts[0]).reverse();\n    var valueParts = toFixed(value, floatPrecision < 0 ? 0 : floatPrecision).split(\".\");\n    var valueIntegerPart = normalizeValueString(reverseString(valueParts[0]), minIntegerPrecision, maxIntegerPrecision);\n    var valueFloatPart = normalizeValueString(valueParts[1], minFloatPrecision, maxFloatPrecision);\n    valueIntegerPart = applyGroups(valueIntegerPart, groupSizes, config.thousandsSeparator);\n    var integerString = reverseString(formatNumberPart(reverseString(floatFormatParts[0]), valueIntegerPart));\n    var floatString = maxFloatPrecision ? formatNumberPart(floatFormatParts[1], valueFloatPart) : \"\";\n    var result = integerString + (floatString.match(/\\d/) ? config.decimalSeparator : \"\") + floatString;\n    return result;\n  };\n}\n\nfunction parseValue(text, isPercent, isNegative) {\n  var value = (isPercent ? .01 : 1) * parseFloat(text) || 0;\n  return isNegative ? -value : value;\n}\n\nfunction prepareValueText(valueText, formatter, isPercent, isIntegerPart) {\n  var nextValueText = valueText;\n  var char;\n  var text;\n  var nextText;\n\n  do {\n    if (nextText) {\n      char = text.length === nextText.length ? \"0\" : \"1\";\n      valueText = isIntegerPart ? char + valueText : valueText + char;\n    }\n\n    text = nextText || formatter(parseValue(nextValueText, isPercent));\n    nextValueText = isIntegerPart ? \"1\" + nextValueText : nextValueText + \"1\";\n    nextText = formatter(parseValue(nextValueText, isPercent));\n  } while (text !== nextText && (isIntegerPart ? text.length === nextText.length : text.length <= nextText.length));\n\n  if (isIntegerPart && nextText.length > text.length) {\n    var hasGroups = formatter(12345).indexOf(\"12345\") === -1;\n\n    do {\n      valueText = \"1\" + valueText;\n    } while (hasGroups && parseValue(valueText, isPercent) < 1e5);\n  }\n\n  return valueText;\n}\n\nfunction getFormatByValueText(valueText, formatter, isPercent, isNegative) {\n  var format = formatter(parseValue(valueText, isPercent, isNegative));\n  var valueTextParts = valueText.split(\".\");\n  var valueTextWithModifiedFloat = valueTextParts[0] + \".3\" + valueTextParts[1].slice(1);\n  var valueWithModifiedFloat = parseValue(valueTextWithModifiedFloat, isPercent, isNegative);\n  var decimalSeparatorIndex = formatter(valueWithModifiedFloat).indexOf(\"3\") - 1;\n  format = format.replace(/(\\d)\\D(\\d)/g, \"$1,$2\");\n\n  if (decimalSeparatorIndex >= 0) {\n    format = format.slice(0, decimalSeparatorIndex) + \".\" + format.slice(decimalSeparatorIndex + 1);\n  }\n\n  format = format.replace(/1+/, \"1\").replace(/1/g, \"#\");\n\n  if (!isPercent) {\n    format = format.replace(\"%\", \"'%'\");\n  }\n\n  return format;\n}\n\nfunction getFormat(formatter) {\n  var valueText = \".\";\n  var isPercent = formatter(1).indexOf(\"100\") >= 0;\n  valueText = prepareValueText(valueText, formatter, isPercent, true);\n  valueText = prepareValueText(valueText, formatter, isPercent, false);\n  var positiveFormat = getFormatByValueText(valueText, formatter, isPercent, false);\n  var negativeFormat = getFormatByValueText(valueText, formatter, isPercent, true);\n  return negativeFormat === \"-\" + positiveFormat ? positiveFormat : positiveFormat + \";\" + negativeFormat;\n}\n\nexports.getFormatter = getFormatter;\nexports.getFormat = getFormat;","map":null,"metadata":{},"sourceType":"script"}