{"ast":null,"code":"/**\r\n * DevExtreme (localization/number.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _dependency_injector = require(\"../core/utils/dependency_injector\");\n\nvar _dependency_injector2 = _interopRequireDefault(_dependency_injector);\n\nvar _array = require(\"../core/utils/array\");\n\nvar _common = require(\"../core/utils/common\");\n\nvar _iterator = require(\"../core/utils/iterator\");\n\nvar _type = require(\"../core/utils/type\");\n\nvar _number = require(\"./ldml/number\");\n\nvar _number2 = _interopRequireDefault(_number);\n\nvar _config = require(\"../core/config\");\n\nvar _config2 = _interopRequireDefault(_config);\n\nvar _errors = require(\"../core/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _utils = require(\"./utils\");\n\nvar _currency = require(\"./currency\");\n\nvar _currency2 = _interopRequireDefault(_currency);\n\nvar _number3 = require(\"./intl/number\");\n\nvar _number4 = _interopRequireDefault(_number3);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) {\n    return;\n  }\n\n  if (\"string\" === typeof o) {\n    return _arrayLikeToArray(o, minLen);\n  }\n\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n\n  if (\"Object\" === n && o.constructor) {\n    n = o.constructor.name;\n  }\n\n  if (\"Map\" === n || \"Set\" === n) {\n    return Array.from(n);\n  }\n\n  if (\"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {\n    return _arrayLikeToArray(o, minLen);\n  }\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (null == len || len > arr.length) {\n    len = arr.length;\n  }\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (\"undefined\" === typeof Symbol || !(Symbol.iterator in Object(arr))) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _e = void 0;\n\n  try {\n    for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) {\n        break;\n      }\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && null != _i.return) {\n        _i.return();\n      }\n    } finally {\n      if (_d) {\n        throw _e;\n      }\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) {\n    return arr;\n  }\n}\n\nvar hasIntl = \"undefined\" !== typeof Intl;\nvar MAX_LARGE_NUMBER_POWER = 4;\nvar DECIMAL_BASE = 10;\nvar NUMERIC_FORMATS = [\"currency\", \"fixedpoint\", \"exponential\", \"percent\", \"decimal\"];\nvar LargeNumberFormatPostfixes = {\n  1: \"K\",\n  2: \"M\",\n  3: \"B\",\n  4: \"T\"\n};\nvar LargeNumberFormatPowers = {\n  largenumber: \"auto\",\n  thousands: 1,\n  millions: 2,\n  billions: 3,\n  trillions: 4\n};\nvar numberLocalization = (0, _dependency_injector2.default)({\n  engine: function () {\n    return \"base\";\n  },\n  numericFormats: NUMERIC_FORMATS,\n  defaultLargeNumberFormatPostfixes: LargeNumberFormatPostfixes,\n  _parseNumberFormatString: function (formatType) {\n    var formatList;\n    var formatObject = {};\n\n    if (!formatType || \"string\" !== typeof formatType) {\n      return;\n    }\n\n    formatList = formatType.toLowerCase().split(\" \");\n    (0, _iterator.each)(formatList, function (index, value) {\n      if ((0, _array.inArray)(value, NUMERIC_FORMATS) > -1) {\n        formatObject.formatType = value;\n      } else {\n        if (value in LargeNumberFormatPowers) {\n          formatObject.power = LargeNumberFormatPowers[value];\n        }\n      }\n    });\n\n    if (formatObject.power && !formatObject.formatType) {\n      formatObject.formatType = \"fixedpoint\";\n    }\n\n    if (formatObject.formatType) {\n      return formatObject;\n    }\n  },\n  _calculateNumberPower: function (value, base, minPower, maxPower) {\n    var number = Math.abs(value);\n    var power = 0;\n\n    if (number > 1) {\n      while (number && number >= base && (void 0 === maxPower || power < maxPower)) {\n        power++;\n        number /= base;\n      }\n    } else {\n      if (number > 0 && number < 1) {\n        while (number < 1 && (void 0 === minPower || power > minPower)) {\n          power--;\n          number *= base;\n        }\n      }\n    }\n\n    return power;\n  },\n  _getNumberByPower: function (number, power, base) {\n    var result = number;\n\n    while (power > 0) {\n      result /= base;\n      power--;\n    }\n\n    while (power < 0) {\n      result *= base;\n      power++;\n    }\n\n    return result;\n  },\n  _formatNumber: function (value, formatObject, formatConfig) {\n    var powerPostfix;\n    var result;\n\n    if (\"auto\" === formatObject.power) {\n      formatObject.power = this._calculateNumberPower(value, 1e3, 0, MAX_LARGE_NUMBER_POWER);\n    }\n\n    if (formatObject.power) {\n      value = this._getNumberByPower(value, formatObject.power, 1e3);\n    }\n\n    powerPostfix = this.defaultLargeNumberFormatPostfixes[formatObject.power] || \"\";\n    result = this._formatNumberCore(value, formatObject.formatType, formatConfig);\n    result = result.replace(/(\\d|.$)(\\D*)$/, \"$1\" + powerPostfix + \"$2\");\n    return result;\n  },\n  _formatNumberExponential: function (value, formatConfig) {\n    var power = this._calculateNumberPower(value, DECIMAL_BASE);\n\n    var number = this._getNumberByPower(value, power, DECIMAL_BASE);\n\n    var powString;\n\n    if (void 0 === formatConfig.precision) {\n      formatConfig.precision = 1;\n    }\n\n    if (number.toFixed(formatConfig.precision || 0) >= DECIMAL_BASE) {\n      power++;\n      number /= DECIMAL_BASE;\n    }\n\n    powString = (power >= 0 ? \"+\" : \"\") + power.toString();\n    return this._formatNumberCore(number, \"fixedpoint\", formatConfig) + \"E\" + powString;\n  },\n  _addZeroes: function (value, precision) {\n    var multiplier = Math.pow(10, precision);\n    var sign = value < 0 ? \"-\" : \"\";\n    value = (Math.abs(value) * multiplier >>> 0) / multiplier;\n    var result = value.toString();\n\n    while (result.length < precision) {\n      result = \"0\" + result;\n    }\n\n    return sign + result;\n  },\n  _addGroupSeparators: function (value) {\n    var parts = value.toString().split(\".\");\n    return parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, (0, _config2.default)().thousandsSeparator) + (parts[1] ? (0, _config2.default)().decimalSeparator + parts[1] : \"\");\n  },\n  _formatNumberCore: function (value, format, formatConfig) {\n    if (\"exponential\" === format) {\n      return this._formatNumberExponential(value, formatConfig);\n    }\n\n    if (\"decimal\" !== format && null !== formatConfig.precision) {\n      formatConfig.precision = formatConfig.precision || 0;\n    }\n\n    if (\"percent\" === format) {\n      value = 100 * value;\n    }\n\n    if (void 0 !== formatConfig.precision) {\n      if (\"decimal\" === format) {\n        value = this._addZeroes(value, formatConfig.precision);\n      } else {\n        value = null === formatConfig.precision ? value.toPrecision() : (0, _utils.toFixed)(value, formatConfig.precision);\n      }\n    }\n\n    if (\"decimal\" !== format) {\n      value = this._addGroupSeparators(value);\n    } else {\n      value = value.toString().replace(\".\", (0, _config2.default)().decimalSeparator);\n    }\n\n    if (\"percent\" === format) {\n      value += \"%\";\n    }\n\n    return value;\n  },\n  _normalizeFormat: function (format) {\n    if (!format) {\n      return {};\n    }\n\n    if (\"function\" === typeof format) {\n      return format;\n    }\n\n    if (!(0, _type.isPlainObject)(format)) {\n      format = {\n        type: format\n      };\n    }\n\n    return format;\n  },\n  _getSeparators: function () {\n    return {\n      decimalSeparator: this.getDecimalSeparator(),\n      thousandsSeparator: this.getThousandsSeparator()\n    };\n  },\n  getThousandsSeparator: function () {\n    return this.format(1e4, \"fixedPoint\")[2];\n  },\n  getDecimalSeparator: function () {\n    return this.format(1.2, {\n      type: \"fixedPoint\",\n      precision: 1\n    })[1];\n  },\n  convertDigits: function (value, toStandard) {\n    var digits = this.format(90, \"decimal\");\n\n    if (\"string\" !== typeof value || \"0\" === digits[1]) {\n      return value;\n    }\n\n    var fromFirstDigit = toStandard ? digits[1] : \"0\";\n    var toFirstDigit = toStandard ? \"0\" : digits[1];\n    var fromLastDigit = toStandard ? digits[0] : \"9\";\n    var regExp = new RegExp(\"[\" + fromFirstDigit + \"-\" + fromLastDigit + \"]\", \"g\");\n    return value.replace(regExp, function (char) {\n      return String.fromCharCode(char.charCodeAt(0) + (toFirstDigit.charCodeAt(0) - fromFirstDigit.charCodeAt(0)));\n    });\n  },\n  getSign: function (text, format) {\n    if (\"-\" === text.replace(/[^0-9-]/g, \"\").charAt(0)) {\n      return -1;\n    }\n\n    if (!format) {\n      return 1;\n    }\n\n    var separators = this._getSeparators();\n\n    var regExp = new RegExp(\"[0-9\" + (0, _common.escapeRegExp)(separators.decimalSeparator + separators.thousandsSeparator) + \"]+\", \"g\");\n    var negativeEtalon = this.format(-1, format).replace(regExp, \"1\");\n    var cleanedText = text.replace(regExp, \"1\");\n    return cleanedText === negativeEtalon ? -1 : 1;\n  },\n  format: function (value, _format) {\n    if (\"number\" !== typeof value) {\n      return value;\n    }\n\n    if (\"number\" === typeof _format) {\n      return value;\n    }\n\n    _format = _format && _format.formatter || _format;\n\n    if (\"function\" === typeof _format) {\n      return _format(value);\n    }\n\n    _format = this._normalizeFormat(_format);\n\n    if (!_format.type) {\n      _format.type = \"decimal\";\n    }\n\n    var numberConfig = this._parseNumberFormatString(_format.type);\n\n    if (!numberConfig) {\n      return this.convertDigits(_number2.default.getFormatter(_format.type, this._getSeparators())(value));\n    }\n\n    return this._formatNumber(value, numberConfig, _format);\n  },\n  parse: function (text, format) {\n    if (!text) {\n      return;\n    }\n\n    if (format && format.parser) {\n      return format.parser(text);\n    }\n\n    text = this.convertDigits(text, true);\n\n    if (format && \"string\" !== typeof format) {\n      _errors2.default.log(\"W0011\");\n    }\n\n    var decimalSeparator = this.getDecimalSeparator();\n    var regExp = new RegExp(\"[^0-9\" + (0, _common.escapeRegExp)(decimalSeparator) + \"]\", \"g\");\n    var cleanedText = text.replace(regExp, \"\").replace(decimalSeparator, \".\").replace(/\\.$/g, \"\");\n\n    if (\".\" === cleanedText || \"\" === cleanedText) {\n      return null;\n    }\n\n    if (this._calcSignificantDigits(cleanedText) > 15) {\n      return NaN;\n    }\n\n    var parsed = +cleanedText;\n    return parsed * this.getSign(text, format);\n  },\n  _calcSignificantDigits: function (text) {\n    var _text$split = text.split(\".\"),\n        _text$split2 = _slicedToArray(_text$split, 2),\n        integer = _text$split2[0],\n        fractional = _text$split2[1];\n\n    var calcDigitsAfterLeadingZeros = function (digits) {\n      var index = -1;\n\n      for (var i = 0; i < digits.length; i++) {\n        if (\"0\" !== digits[i]) {\n          index = i;\n          break;\n        }\n      }\n\n      return index > -1 ? digits.length - index : 0;\n    };\n\n    var result = 0;\n\n    if (integer) {\n      result += calcDigitsAfterLeadingZeros(integer.split(\"\"));\n    }\n\n    if (fractional) {\n      result += calcDigitsAfterLeadingZeros(fractional.split(\"\").reverse());\n    }\n\n    return result;\n  }\n});\nnumberLocalization.inject(_currency2.default);\n\nif (hasIntl) {\n  numberLocalization.inject(_number4.default);\n}\n\nmodule.exports = numberLocalization;","map":null,"metadata":{},"sourceType":"script"}