{"ast":null,"code":"/**\r\n * DevExtreme (viz/series/points/label.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _format_helper = require(\"../../../format_helper\");\n\nvar _utils = require(\"../../core/utils\");\n\nvar _iterator = require(\"../../../core/utils/iterator\");\n\nvar _extend = require(\"../../../core/utils/extend\");\n\nvar _math = Math;\nvar _round = _math.round;\nvar _floor = _math.floor;\nvar _abs = _math.abs;\nvar CONNECTOR_LENGTH = 12;\nvar LABEL_BACKGROUND_PADDING_X = 8;\nvar LABEL_BACKGROUND_PADDING_Y = 4;\n\nfunction getClosestCoord(point, coords) {\n  var closestDistance = 1 / 0;\n  var closestCoord;\n  (0, _iterator.each)(coords, function (_, coord) {\n    var x = point[0] - coord[0];\n    var y = point[1] - coord[1];\n    var distance = x * x + y * y;\n\n    if (distance < closestDistance) {\n      closestDistance = distance;\n      closestCoord = coord;\n    }\n  });\n  return [_floor(closestCoord[0]), _floor(closestCoord[1])];\n}\n\nfunction getCrossCoord(rect, coord, indexOffset) {\n  return (coord - rect[0 + indexOffset]) / (rect[2 + indexOffset] - rect[0 + indexOffset]) * (rect[3 - indexOffset] - rect[1 - indexOffset]) + rect[1 - indexOffset];\n}\n\nvar barPointStrategy = {\n  isLabelInside: function (labelPoint, figure) {\n    var xc = labelPoint.x + labelPoint.width / 2;\n    var yc = labelPoint.y + labelPoint.height / 2;\n    return figure.x <= xc && xc <= figure.x + figure.width && figure.y <= yc && yc <= figure.y + figure.height;\n  },\n  prepareLabelPoints: function (bBox, rotatedBBox, isHorizontal, angle, figureCenter) {\n    var x1 = rotatedBBox.x;\n    var xc = x1 + rotatedBBox.width / 2;\n    var x2 = x1 + rotatedBBox.width - 1;\n    var y1 = rotatedBBox.y;\n    var yc = y1 + rotatedBBox.height / 2;\n    var y2 = y1 + rotatedBBox.height - 1;\n    var labelPoints;\n    var isRectangular = _abs(angle) % 90 === 0;\n\n    if (figureCenter[0] > x1 && figureCenter[0] < x2) {\n      if (isRectangular) {\n        labelPoints = [[figureCenter[0], _abs(figureCenter[1] - y1) < _abs(figureCenter[1] - y2) ? y1 : y2]];\n      } else {\n        labelPoints = [[figureCenter[0], getCrossCoord([x1, y1, x2, y2], figureCenter[0], 0)]];\n      }\n    } else {\n      if (figureCenter[1] > y1 && figureCenter[1] < y2) {\n        if (isRectangular) {\n          labelPoints = [[_abs(figureCenter[0] - x1) < _abs(figureCenter[0] - x2) ? x1 : x2, figureCenter[1]]];\n        } else {\n          labelPoints = [[getCrossCoord([x1, y1, x2, y2], figureCenter[1], 1), figureCenter[1]]];\n        }\n      } else {\n        if (isRectangular) {\n          labelPoints = [[x1, y1], [isHorizontal ? x1 : xc, isHorizontal ? yc : y1], [x2, y1], [x1, y2], [isHorizontal ? x2 : xc, isHorizontal ? yc : y2], [x2, y2]];\n        } else {\n          labelPoints = [[xc, yc]];\n        }\n      }\n    }\n\n    return labelPoints;\n  },\n  isHorizontal: function (bBox, figure) {\n    return bBox.x > figure.x + figure.width || bBox.x + bBox.width < figure.x;\n  },\n  getFigureCenter: function (figure) {\n    return [_floor(figure.x + figure.width / 2), _floor(figure.y + figure.height / 2)];\n  },\n  findFigurePoint: function (figure, labelPoint) {\n    var figureCenter = barPointStrategy.getFigureCenter(figure);\n    var point = getClosestCoord(labelPoint, [[figure.x, figureCenter[1]], [figureCenter[0], figure.y + figure.height], [figure.x + figure.width, figureCenter[1]], [figureCenter[0], figure.y]]);\n    return point;\n  },\n  adjustPoints: function (points) {\n    var lineIsVertical = _abs(points[1] - points[3]) <= 1;\n    var lineIsHorizontal = _abs(points[0] - points[2]) <= 1;\n\n    if (lineIsHorizontal) {\n      points[0] = points[2];\n    }\n\n    if (lineIsVertical) {\n      points[1] = points[3];\n    }\n\n    return points;\n  }\n};\nvar symbolPointStrategy = {\n  isLabelInside: function () {\n    return false;\n  },\n  prepareLabelPoints: barPointStrategy.prepareLabelPoints,\n  isHorizontal: function (bBox, figure) {\n    return bBox.x > figure.x + figure.r || bBox.x + bBox.width < figure.x - figure.r;\n  },\n  getFigureCenter: function (figure) {\n    return [figure.x, figure.y];\n  },\n  findFigurePoint: function (figure, labelPoint) {\n    var angle = Math.atan2(figure.y - labelPoint[1], labelPoint[0] - figure.x);\n    return [_round(figure.x + figure.r * Math.cos(angle)), _round(figure.y - figure.r * Math.sin(angle))];\n  },\n  adjustPoints: barPointStrategy.adjustPoints\n};\nvar piePointStrategy = {\n  isLabelInside: function (_0, _1, isOutside) {\n    return !isOutside;\n  },\n  prepareLabelPoints: function (bBox, rotatedBBox, isHorizontal, angle) {\n    var xl = bBox.x;\n    var xr = xl + bBox.width;\n\n    var xc = xl + _round(bBox.width / 2);\n\n    var yt = bBox.y;\n    var yb = yt + bBox.height;\n\n    var yc = yt + _round(bBox.height / 2);\n\n    var points = [[[xl, yt], [xr, yt]], [[xr, yt], [xr, yb]], [[xr, yb], [xl, yb]], [[xl, yb], [xl, yt]]];\n    var cosSin = (0, _utils.getCosAndSin)(angle);\n\n    if (0 === angle) {\n      points = isHorizontal ? [[xl, yc], [xr, yc]] : [[xc, yt], [xc, yb]];\n    } else {\n      points = points.map(function (pair) {\n        return pair.map(function (point) {\n          return [_round((point[0] - xc) * cosSin.cos + (point[1] - yc) * cosSin.sin + xc), _round(-(point[0] - xc) * cosSin.sin + (point[1] - yc) * cosSin.cos + yc)];\n        });\n      }).reduce(function (r, pair) {\n        var point1x = pair[0][0];\n        var point1y = pair[0][1];\n        var point2x = pair[1][0];\n        var point2y = pair[1][1];\n\n        if (isHorizontal) {\n          if (point1y >= yc && yc >= point2y || point1y <= yc && yc <= point2y) {\n            r.push([(yc - point1y) * (point2x - point1x) / (point2y - point1y) + point1x, yc]);\n          }\n        } else {\n          if (point1x >= xc && xc >= point2x || point1x <= xc && xc <= point2x) {\n            r.push([xc, (xc - point1x) * (point2y - point1y) / (point2x - point1x) + point1y]);\n          }\n        }\n\n        return r;\n      }, []);\n    }\n\n    return points;\n  },\n  isHorizontal: function (bBox, figure) {\n    return bBox.x > figure.x || figure.x > bBox.x + bBox.width;\n  },\n  getFigureCenter: symbolPointStrategy.getFigureCenter,\n  findFigurePoint: function (figure, labelPoint, isHorizontal) {\n    if (!isHorizontal) {\n      return [figure.x, figure.y];\n    }\n\n    var labelX = labelPoint[0];\n\n    var x = _round(figure.x + (figure.y - labelPoint[1]) / Math.tan((0, _utils.degreesToRadians)(figure.angle)));\n\n    var points = [figure.x, figure.y, x, labelPoint[1]];\n\n    if (!(figure.x <= x && x <= labelX) && !(labelX <= x && x <= figure.x)) {\n      if (_abs(figure.x - labelX) < CONNECTOR_LENGTH) {\n        points = [figure.x, figure.y];\n      } else {\n        if (figure.x <= labelX) {\n          points[2] = figure.x + CONNECTOR_LENGTH;\n        } else {\n          points[2] = figure.x - CONNECTOR_LENGTH;\n        }\n      }\n    }\n\n    return points;\n  },\n  adjustPoints: function (points) {\n    return points;\n  }\n};\n\nfunction selectStrategy(figure) {\n  return void 0 !== figure.angle && piePointStrategy || void 0 !== figure.r && symbolPointStrategy || barPointStrategy;\n}\n\nfunction disposeItem(obj, field) {\n  obj[field] && obj[field].dispose();\n  obj[field] = null;\n}\n\nfunction checkBackground(background) {\n  return background && (background.fill && \"none\" !== background.fill || background[\"stroke-width\"] > 0 && background.stroke && \"none\" !== background.stroke);\n}\n\nfunction checkConnector(connector) {\n  return connector && connector[\"stroke-width\"] > 0 && connector.stroke && \"none\" !== connector.stroke;\n}\n\nfunction formatText(data, options) {\n  var format = options.format;\n  data.valueText = (0, _format_helper.format)(data.value, format);\n  data.argumentText = (0, _format_helper.format)(data.argument, options.argumentFormat);\n\n  if (void 0 !== data.percent) {\n    data.percentText = (0, _format_helper.format)(data.percent, {\n      type: \"percent\",\n      precision: format && format.percentPrecision\n    });\n  }\n\n  if (void 0 !== data.total) {\n    data.totalText = (0, _format_helper.format)(data.total, format);\n  }\n\n  if (void 0 !== data.openValue) {\n    data.openValueText = (0, _format_helper.format)(data.openValue, format);\n  }\n\n  if (void 0 !== data.closeValue) {\n    data.closeValueText = (0, _format_helper.format)(data.closeValue, format);\n  }\n\n  if (void 0 !== data.lowValue) {\n    data.lowValueText = (0, _format_helper.format)(data.lowValue, format);\n  }\n\n  if (void 0 !== data.highValue) {\n    data.highValueText = (0, _format_helper.format)(data.highValue, format);\n  }\n\n  if (void 0 !== data.reductionValue) {\n    data.reductionValueText = (0, _format_helper.format)(data.reductionValue, format);\n  }\n\n  return options.customizeText ? options.customizeText.call(data, data) : data.valueText;\n}\n\nfunction Label(renderSettings) {\n  this._renderer = renderSettings.renderer;\n  this._container = renderSettings.labelsGroup;\n  this._point = renderSettings.point;\n  this._strategy = renderSettings.strategy;\n  this._rowCount = 1;\n}\n\nLabel.prototype = {\n  constructor: Label,\n  setColor: function (color) {\n    this._color = color;\n  },\n  setOptions: function (options) {\n    this._options = options;\n  },\n  setData: function (data) {\n    this._data = data;\n  },\n  setDataField: function (fieldName, fieldValue) {\n    this._data = this._data || {};\n    this._data[fieldName] = fieldValue;\n  },\n  getData: function () {\n    return this._data;\n  },\n  setFigureToDrawConnector: function (figure) {\n    this._figure = figure;\n  },\n  dispose: function () {\n    var that = this;\n    disposeItem(that, \"_group\");\n    that._data = that._options = that._textContent = that._visible = that._insideGroup = that._text = that._background = that._connector = that._figure = null;\n  },\n  _setVisibility: function (value, state) {\n    this._group && this._group.attr({\n      visibility: value\n    });\n    this._visible = state;\n  },\n  isVisible: function () {\n    return this._visible;\n  },\n  hide: function (holdInvisible) {\n    this._holdVisibility = !!holdInvisible;\n\n    this._hide();\n  },\n  _hide: function () {\n    this._setVisibility(\"hidden\", false);\n  },\n  show: function (holdVisible) {\n    var correctPosition = !this._drawn;\n\n    if (this._point.hasValue()) {\n      this._holdVisibility = !!holdVisible;\n\n      this._show();\n\n      correctPosition && this._point.correctLabelPosition(this);\n    }\n  },\n  _show: function () {\n    var that = this;\n    var renderer = that._renderer;\n    var container = that._container;\n    var options = that._options || {};\n    var text = that._textContent = formatText(that._data, that._options) || null;\n\n    if (text) {\n      if (!that._group) {\n        that._group = renderer.g().append(container);\n        that._insideGroup = renderer.g().append(that._group);\n        that._text = renderer.text(\"\", 0, 0).append(that._insideGroup);\n      }\n\n      that._text.css(options.attributes ? (0, _utils.patchFontOptions)(options.attributes.font) : {});\n\n      if (checkBackground(options.background)) {\n        that._background = that._background || renderer.rect().append(that._insideGroup).toBackground();\n\n        that._background.attr(options.background);\n\n        that._color && that._background.attr({\n          fill: that._color\n        });\n      } else {\n        disposeItem(that, \"_background\");\n      }\n\n      if (checkConnector(options.connector)) {\n        that._connector = that._connector || renderer.path([], \"line\").sharp().append(that._group).toBackground();\n\n        that._connector.attr(options.connector);\n\n        that._color && that._connector.attr({\n          stroke: that._color\n        });\n      } else {\n        disposeItem(that, \"_connector\");\n      }\n\n      that._text.attr({\n        text: text,\n        align: options.textAlignment,\n        \"class\": options.cssClass\n      });\n\n      that._updateBackground(that._text.getBBox());\n\n      that._setVisibility(\"visible\", true);\n\n      that._drawn = true;\n    } else {\n      that._hide();\n    }\n  },\n  _getLabelVisibility: function (isVisible) {\n    return this._holdVisibility ? this.isVisible() : isVisible;\n  },\n  draw: function (isVisible) {\n    if (this._getLabelVisibility(isVisible)) {\n      this._show();\n\n      this._point && this._point.correctLabelPosition(this);\n    } else {\n      this._drawn = false;\n\n      this._hide();\n    }\n\n    return this;\n  },\n  _updateBackground: function (bBox) {\n    var that = this;\n\n    if (that._background) {\n      bBox.x -= LABEL_BACKGROUND_PADDING_X;\n      bBox.y -= LABEL_BACKGROUND_PADDING_Y;\n      bBox.width += 2 * LABEL_BACKGROUND_PADDING_X;\n      bBox.height += 2 * LABEL_BACKGROUND_PADDING_Y;\n\n      that._background.attr(bBox);\n    }\n\n    that._bBoxWithoutRotation = (0, _extend.extend)({}, bBox);\n    var rotationAngle = that._options.rotationAngle || 0;\n\n    that._insideGroup.rotate(rotationAngle, bBox.x + bBox.width / 2, bBox.y + bBox.height / 2);\n\n    bBox = (0, _utils.rotateBBox)(bBox, [bBox.x + bBox.width / 2, bBox.y + bBox.height / 2], -rotationAngle);\n    that._bBox = bBox;\n  },\n  getFigureCenter: function () {\n    var figure = this._figure;\n    var strategy = this._strategy || selectStrategy(figure);\n    return strategy.getFigureCenter(figure);\n  },\n  _getConnectorPoints: function () {\n    var that = this;\n    var figure = that._figure;\n    var options = that._options;\n    var strategy = that._strategy || selectStrategy(figure);\n\n    var bBox = that._shiftBBox(that._bBoxWithoutRotation);\n\n    var rotatedBBox = that.getBoundingRect();\n    var labelPoint;\n    var points = [];\n    var isHorizontal;\n\n    if (!strategy.isLabelInside(bBox, figure, \"inside\" !== options.position)) {\n      isHorizontal = strategy.isHorizontal(bBox, figure);\n      var figureCenter = that.getFigureCenter();\n      points = strategy.prepareLabelPoints(bBox, rotatedBBox, isHorizontal, -options.rotationAngle || 0, figureCenter);\n      labelPoint = getClosestCoord(figureCenter, points);\n      points = strategy.findFigurePoint(figure, labelPoint, isHorizontal);\n      points = points.concat(labelPoint);\n    }\n\n    return strategy.adjustPoints(points);\n  },\n  fit: function (maxWidth) {\n    var padding = this._background ? 2 * LABEL_BACKGROUND_PADDING_X : 0;\n    var rowCountChanged = false;\n\n    if (this._text) {\n      var _this$_text$setMaxSiz = this._text.setMaxSize(maxWidth - padding, void 0, this._options),\n          rowCount = _this$_text$setMaxSiz.rowCount,\n          textIsEmpty = _this$_text$setMaxSiz.textIsEmpty;\n\n      if (0 === rowCount) {\n        rowCount = 1;\n      }\n\n      if (rowCount !== this._rowCount) {\n        rowCountChanged = true;\n        this._rowCount = rowCount;\n      }\n\n      textIsEmpty && disposeItem(this, \"_background\");\n    }\n\n    this._updateBackground(this._text.getBBox());\n\n    return rowCountChanged;\n  },\n  resetEllipsis: function () {\n    this._text && this._text.restoreText();\n\n    this._updateBackground(this._text.getBBox());\n  },\n  setTrackerData: function (point) {\n    this._text.data({\n      \"chart-data-point\": point\n    });\n\n    this._background && this._background.data({\n      \"chart-data-point\": point\n    });\n  },\n  hideInsideLabel: function (coords) {\n    return this._point.hideInsideLabel(this, coords);\n  },\n  getPoint: function () {\n    return this._point;\n  },\n  shift: function (x, y) {\n    var that = this;\n\n    if (that._textContent) {\n      that._insideGroup.attr({\n        translateX: that._x = _round(x - that._bBox.x),\n        translateY: that._y = _round(y - that._bBox.y)\n      });\n\n      if (that._connector) {\n        that._connector.attr({\n          points: that._getConnectorPoints()\n        });\n      }\n    }\n\n    return that;\n  },\n  getBoundingRect: function () {\n    return this._shiftBBox(this._bBox);\n  },\n  _shiftBBox: function (bBox) {\n    return this._textContent ? {\n      x: bBox.x + this._x,\n      y: bBox.y + this._y,\n      width: bBox.width,\n      height: bBox.height\n    } : {};\n  },\n  getLayoutOptions: function () {\n    var options = this._options;\n    return {\n      alignment: options.alignment,\n      background: checkBackground(options.background),\n      horizontalOffset: options.horizontalOffset,\n      verticalOffset: options.verticalOffset,\n      radialOffset: options.radialOffset,\n      position: options.position,\n      connectorOffset: (checkConnector(options.connector) ? CONNECTOR_LENGTH : 0) + (checkBackground(options.background) ? LABEL_BACKGROUND_PADDING_X : 0)\n    };\n  }\n};\nexports.Label = Label;","map":null,"metadata":{},"sourceType":"script"}