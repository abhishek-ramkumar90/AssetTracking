{"ast":null,"code":"/**\r\n * DevExtreme (viz/chart_components/tracker.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar domAdapter = require(\"../../core/dom_adapter\");\n\nvar eventsEngine = require(\"../../events/core/events_engine\");\n\nvar clickEvent = require(\"../../events/click\");\n\nvar extend = require(\"../../core/utils/extend\").extend;\n\nvar each = require(\"../../core/utils/iterator\").each;\n\nvar consts = require(\"../components/consts\");\n\nvar eventsConsts = consts.events;\n\nvar vizUtils = require(\"../core/utils\");\n\nvar pointerEvents = require(\"../../events/pointer\");\n\nvar holdEvent = require(\"../../events/hold\");\n\nvar addNamespace = require(\"../../events/utils\").addNamespace;\n\nvar isDefined = require(\"../../core/utils/type\").isDefined;\n\nvar _normalizeEnum = vizUtils.normalizeEnum;\nvar inCanvas = vizUtils.pointInCanvas;\nvar _floor = Math.floor;\nvar _each = each;\n\nvar _noop = require(\"../../core/utils/common\").noop;\n\nvar HOVER_STATE = consts.states.hoverMark;\nvar NORMAL_STATE = consts.states.normalMark;\nvar EVENT_NS = \"dxChartTracker\";\nvar DOT_EVENT_NS = \".\" + EVENT_NS;\nvar POINTER_ACTION = addNamespace([pointerEvents.down, pointerEvents.move], EVENT_NS);\nvar LEGEND_CLICK = \"legendClick\";\nvar SERIES_CLICK = \"seriesClick\";\nvar POINT_CLICK = \"pointClick\";\nvar POINT_DATA = \"chart-data-point\";\nvar SERIES_DATA = \"chart-data-series\";\nvar ARG_DATA = \"chart-data-argument\";\nvar DELAY = 100;\nvar NONE_MODE = \"none\";\nvar ALL_ARGUMENT_POINTS_MODE = \"allargumentpoints\";\nvar INCLUDE_POINTS_MODE = \"includepoints\";\nvar EXLUDE_POINTS_MODE = \"excludepoints\";\nvar LEGEND_HOVER_MODES = [INCLUDE_POINTS_MODE, EXLUDE_POINTS_MODE, NONE_MODE];\n\nfunction getData(event, dataKey) {\n  var target = event.target;\n  return (\"tspan\" === target.tagName ? target.parentNode : target)[dataKey];\n}\n\nfunction eventCanceled(event, target) {\n  return event.cancel || !target.getOptions();\n}\n\nfunction correctLegendHoverMode(mode) {\n  if (LEGEND_HOVER_MODES.indexOf(mode) > -1) {\n    return mode;\n  } else {\n    return INCLUDE_POINTS_MODE;\n  }\n}\n\nfunction correctHoverMode(target) {\n  var mode = target.getOptions().hoverMode;\n  return mode === NONE_MODE ? mode : ALL_ARGUMENT_POINTS_MODE;\n}\n\nvar baseTrackerPrototype = {\n  ctor: function (options) {\n    var that = this;\n    var data = {\n      tracker: that\n    };\n    that._renderer = options.renderer;\n    that._legend = options.legend;\n    that._tooltip = options.tooltip;\n    that._eventTrigger = options.eventTrigger;\n    that._seriesGroup = options.seriesGroup;\n    options.seriesGroup.off(DOT_EVENT_NS).on(addNamespace(eventsConsts.showPointTooltip, EVENT_NS), data, that._showPointTooltip).on(addNamespace(eventsConsts.hidePointTooltip, EVENT_NS), data, that._hidePointTooltip);\n\n    that._renderer.root.off(DOT_EVENT_NS).on(POINTER_ACTION, data, that._pointerHandler).on(addNamespace(clickEvent.name, EVENT_NS), data, that._clickHandler).on(addNamespace(holdEvent.name, EVENT_NS), {\n      timeout: 300\n    }, _noop);\n  },\n  update: function (options) {\n    this._chart = options.chart;\n  },\n  updateSeries: function (series, resetDecorations) {\n    var that = this;\n    var noHoveredSeries = !(series && series.some(function (s) {\n      return s === that.hoveredSeries;\n    }) || that._hoveredPoint && that._hoveredPoint.series);\n\n    if (that._storedSeries !== series) {\n      that._storedSeries = series || [];\n    }\n\n    if (noHoveredSeries) {\n      that._clean();\n\n      that._renderer.initHatching();\n    }\n\n    if (resetDecorations) {\n      that.clearSelection();\n\n      if (!noHoveredSeries) {\n        that._hideTooltip(that.pointAtShownTooltip);\n\n        that.clearHover();\n      }\n    }\n  },\n  setCanvases: function (mainCanvas, paneCanvases) {\n    this._mainCanvas = mainCanvas;\n    this._canvases = paneCanvases;\n  },\n  repairTooltip: function () {\n    var point = this.pointAtShownTooltip;\n\n    if (!point || !point.series || !point.isVisible()) {\n      this._hideTooltip(point, true);\n    } else {\n      this._showTooltip(point);\n    }\n  },\n  _setHoveredPoint: function (point) {\n    if (point === this._hoveredPoint) {\n      return;\n    }\n\n    this._releaseHoveredPoint();\n\n    point.hover();\n    this._hoveredPoint = point;\n  },\n  _releaseHoveredPoint: function () {\n    if (this._hoveredPoint && this._hoveredPoint.getOptions()) {\n      this._hoveredPoint.clearHover();\n\n      this._hoveredPoint = null;\n\n      if (this._tooltip.isEnabled()) {\n        this._hideTooltip(this._hoveredPoint);\n      }\n    }\n  },\n  _setHoveredSeries: function (series, mode) {\n    this._releaseHoveredSeries();\n\n    this._releaseHoveredPoint();\n\n    series.hover(mode);\n    this.hoveredSeries = series;\n  },\n  _releaseHoveredSeries: function (needSetHoverView, hoveredPoint) {\n    if (this.hoveredSeries) {\n      this.hoveredSeries.clearHover();\n      this.hoveredSeries = null;\n    }\n  },\n  clearSelection: function () {\n    this._storedSeries.forEach(function (series) {\n      if (series) {\n        series.clearSelection();\n        series.getPoints().forEach(function (point) {\n          point.clearSelection();\n        });\n      }\n    });\n  },\n  _clean: function () {\n    var that = this;\n    that.hoveredPoint = that.hoveredSeries = that._hoveredArgumentPoints = null;\n\n    that._hideTooltip(that.pointAtShownTooltip);\n  },\n  clearHover: function () {\n    this._resetHoveredArgument();\n\n    this._releaseHoveredSeries();\n\n    this._releaseHoveredPoint();\n  },\n  _hideTooltip: function (point, silent) {\n    var that = this;\n\n    if (!that._tooltip || point && that.pointAtShownTooltip !== point) {\n      return;\n    }\n\n    if (!silent && that.pointAtShownTooltip) {\n      that.pointAtShownTooltip = null;\n    }\n\n    that._tooltip.hide();\n  },\n  _showTooltip: function (point) {\n    var that = this;\n    var tooltipFormatObject;\n    var eventData;\n\n    if (point && point.getOptions()) {\n      tooltipFormatObject = point.getTooltipFormatObject(that._tooltip, that._tooltip.isShared() && that._chart.getStackedPoints(point));\n\n      if (!isDefined(tooltipFormatObject.valueText) && !tooltipFormatObject.points || !point.isVisible()) {\n        return;\n      }\n\n      if (!that.pointAtShownTooltip || that.pointAtShownTooltip !== point) {\n        eventData = {\n          target: point\n        };\n      }\n\n      var coords = point.getTooltipParams(that._tooltip.getLocation());\n\n      var rootOffset = that._renderer.getRootOffset();\n\n      coords.x += rootOffset.left;\n      coords.y += rootOffset.top;\n\n      if (!that._tooltip.show(tooltipFormatObject, coords, eventData)) {\n        return;\n      }\n\n      that.pointAtShownTooltip = point;\n    }\n  },\n  _showPointTooltip: function (event, point) {\n    var that = event.data.tracker;\n    var pointWithTooltip = that.pointAtShownTooltip;\n\n    if (pointWithTooltip && pointWithTooltip !== point) {\n      that._hideTooltip(pointWithTooltip);\n    }\n\n    that._showTooltip(point);\n  },\n  _hidePointTooltip: function (event, point) {\n    event.data.tracker._hideTooltip(point);\n  },\n  _enableOutHandler: function () {\n    if (this._outHandler) {\n      return;\n    }\n\n    var that = this;\n\n    var handler = function (e) {\n      var rootOffset = that._renderer.getRootOffset();\n\n      var x = _floor(e.pageX - rootOffset.left);\n\n      var y = _floor(e.pageY - rootOffset.top);\n\n      if (!inCanvas(that._mainCanvas, x, y)) {\n        that._pointerOut();\n\n        that._disableOutHandler();\n      }\n    };\n\n    eventsEngine.on(domAdapter.getDocument(), POINTER_ACTION, handler);\n    this._outHandler = handler;\n  },\n  _disableOutHandler: function () {\n    this._outHandler && eventsEngine.off(domAdapter.getDocument(), POINTER_ACTION, this._outHandler);\n    this._outHandler = null;\n  },\n  stopCurrentHandling: function () {\n    this._pointerOut(true);\n  },\n  _pointerOut: function (force) {\n    this.clearHover();\n    (force || this._tooltip.isEnabled()) && this._hideTooltip(this.pointAtShownTooltip);\n  },\n  _triggerLegendClick: function (eventArgs, elementClick) {\n    var eventTrigger = this._eventTrigger;\n    eventTrigger(LEGEND_CLICK, eventArgs, function () {\n      !eventCanceled(eventArgs.event, eventArgs.target) && eventTrigger(elementClick, eventArgs);\n    });\n  },\n  _hoverLegendItem: function (x, y) {\n    var that = this;\n\n    var item = that._legend.getItemByCoord(x, y);\n\n    var series;\n    var legendHoverMode = correctLegendHoverMode(that._legend.getOptions().hoverMode);\n\n    if (item) {\n      series = that._storedSeries[item.id];\n\n      if (!series.isHovered() || series.lastHoverMode !== legendHoverMode) {\n        that._setHoveredSeries(series, legendHoverMode);\n      }\n\n      that._tooltip.isEnabled() && that._hideTooltip(that.pointAtShownTooltip);\n    } else {\n      that.clearHover();\n    }\n  },\n  _hoverArgument: function (argument, argumentIndex) {\n    var that = this;\n\n    var hoverMode = that._getArgumentHoverMode();\n\n    if (isDefined(argument)) {\n      that._releaseHoveredPoint();\n\n      that._hoveredArgument = argument;\n      that._argumentIndex = argumentIndex;\n\n      that._notifySeries({\n        action: \"pointHover\",\n        notifyLegend: that._notifyLegendOnHoverArgument,\n        target: {\n          argument: argument,\n          fullState: HOVER_STATE,\n          argumentIndex: argumentIndex,\n          getOptions: function () {\n            return {\n              hoverMode: hoverMode\n            };\n          }\n        }\n      });\n    }\n  },\n  _resetHoveredArgument: function () {\n    var that = this;\n    var hoverMode;\n\n    if (isDefined(that._hoveredArgument)) {\n      hoverMode = that._getArgumentHoverMode();\n\n      that._notifySeries({\n        action: \"clearPointHover\",\n        notifyLegend: that._notifyLegendOnHoverArgument,\n        target: {\n          fullState: NORMAL_STATE,\n          argumentIndex: that._argumentIndex,\n          argument: that._hoveredArgument,\n          getOptions: function () {\n            return {\n              hoverMode: hoverMode\n            };\n          }\n        }\n      });\n\n      that._hoveredArgument = null;\n    }\n  },\n  _notifySeries: function (data) {\n    this._storedSeries.forEach(function (series) {\n      series.notify(data);\n    });\n  },\n  _pointerHandler: function (e) {\n    var that = e.data.tracker;\n\n    var rootOffset = that._renderer.getRootOffset();\n\n    var x = _floor(e.pageX - rootOffset.left);\n\n    var y = _floor(e.pageY - rootOffset.top);\n\n    var canvas = that._getCanvas(x, y);\n\n    var series = getData(e, SERIES_DATA);\n    var point = getData(e, POINT_DATA) || series && series.getPointByCoord(x, y);\n\n    if (point && !point.getMarkerVisibility()) {\n      point = void 0;\n    }\n\n    that._enableOutHandler();\n\n    if (that._legend.coordsIn(x, y)) {\n      that._hoverLegendItem(x, y);\n\n      return;\n    }\n\n    if (that.hoveredSeries && that.hoveredSeries !== that._stuckSeries) {\n      that._releaseHoveredSeries();\n    }\n\n    if (that._hoverArgumentAxis(x, y, e)) {\n      return;\n    }\n\n    if (that._isPointerOut(canvas, point)) {\n      that._pointerOut();\n    }\n\n    if (!canvas && !point) {\n      return;\n    }\n\n    if (series && !point) {\n      point = series.getNeighborPoint(x, y);\n\n      if (!that._stickyHovering && point && !point.coordsIn(x, y)) {\n        point = null;\n      }\n\n      if (series !== that.hoveredSeries) {\n        that._setTimeout(function () {\n          that._setHoveredSeries(series);\n\n          that._setStuckSeries(e, series, x, y);\n\n          that._pointerComplete(point, x, y);\n        }, series);\n\n        return;\n      }\n    } else {\n      if (point) {\n        if (e.type !== pointerEvents.move && \"touch\" !== e.pointerType) {\n          return;\n        }\n\n        if (that.hoveredSeries) {\n          that._setTimeout(function () {\n            that._pointerOnPoint(point, x, y, e);\n          }, point);\n        } else {\n          that._pointerOnPoint(point, x, y, e);\n        }\n\n        return;\n      } else {\n        if (that._setStuckSeries(e, void 0, x, y) && that._stickyHovering) {\n          series = that._stuckSeries;\n          point = series.getNeighborPoint(x, y);\n\n          that._releaseHoveredSeries();\n\n          point && point.getMarkerVisibility() && that._setHoveredPoint(point);\n        } else {\n          if (!that._stickyHovering) {\n            that._pointerOut();\n          }\n        }\n      }\n    }\n\n    that._pointerComplete(point, x, y);\n  },\n  _pointerOnPoint: function (point, x, y) {\n    this._resetHoveredArgument();\n\n    this._setHoveredPoint(point);\n\n    this._pointerComplete(point, x, y);\n  },\n  _pointerComplete: function (point) {\n    this.pointAtShownTooltip !== point && this._tooltip.isEnabled() && this._showTooltip(point);\n  },\n  _clickHandler: function (e) {\n    var that = e.data.tracker;\n\n    var rootOffset = that._renderer.getRootOffset();\n\n    var x = _floor(e.pageX - rootOffset.left);\n\n    var y = _floor(e.pageY - rootOffset.top);\n\n    var point = getData(e, POINT_DATA);\n    var series = that._stuckSeries || getData(e, SERIES_DATA) || point && point.series;\n    var axis = that._argumentAxis;\n\n    if (that._legend.coordsIn(x, y)) {\n      var item = that._legend.getItemByCoord(x, y);\n\n      if (item) {\n        that._legendClick(item, e);\n      }\n    } else {\n      if (axis && axis.coordsIn(x, y)) {\n        var argument = getData(e, ARG_DATA);\n\n        if (isDefined(argument)) {\n          that._eventTrigger(\"argumentAxisClick\", {\n            argument: argument,\n            event: e\n          });\n        }\n      } else {\n        if (series) {\n          point = point || series.getPointByCoord(x, y);\n\n          if (point && point.getMarkerVisibility()) {\n            that._pointClick(point, e);\n          } else {\n            getData(e, SERIES_DATA) && that._eventTrigger(SERIES_CLICK, {\n              target: series,\n              event: e\n            });\n          }\n        }\n      }\n    }\n  },\n  dispose: function () {\n    var that = this;\n\n    that._disableOutHandler();\n\n    that._renderer.root.off(DOT_EVENT_NS);\n\n    that._seriesGroup.off(DOT_EVENT_NS);\n  }\n};\n\nvar ChartTracker = function (options) {\n  this.ctor(options);\n};\n\nextend(ChartTracker.prototype, baseTrackerPrototype, {\n  _pointClick: function (point, event) {\n    var that = this;\n    var eventTrigger = that._eventTrigger;\n    var series = point.series;\n    eventTrigger(POINT_CLICK, {\n      target: point,\n      event: event\n    }, function () {\n      !eventCanceled(event, series) && eventTrigger(SERIES_CLICK, {\n        target: series,\n        event: event\n      });\n    });\n  },\n  update: function (options) {\n    var that = this;\n    baseTrackerPrototype.update.call(this, options);\n    that._argumentAxis = options.argumentAxis || {};\n    that._axisHoverEnabled = that._argumentAxis && _normalizeEnum(that._argumentAxis.getOptions().hoverMode) === ALL_ARGUMENT_POINTS_MODE;\n    that._rotated = options.rotated;\n    that._crosshair = options.crosshair;\n    that._stickyHovering = options.stickyHovering;\n  },\n  _getCanvas: function (x, y) {\n    var that = this;\n    var canvases = that._canvases || [];\n\n    for (var i = 0; i < canvases.length; i++) {\n      var c = canvases[i];\n\n      if (inCanvas(c, x, y)) {\n        return c;\n      }\n    }\n\n    return null;\n  },\n  _isPointerOut: function (canvas) {\n    return !canvas && this._stuckSeries;\n  },\n  _hideCrosshair: function () {\n    this._crosshair && this._crosshair.hide();\n  },\n  _moveCrosshair: function (point, x, y) {\n    if (point && this._crosshair && point.isVisible()) {\n      this._crosshair.show({\n        point: point,\n        x: x,\n        y: y\n      });\n    }\n  },\n  _clean: function () {\n    var that = this;\n\n    baseTrackerPrototype._clean.call(that);\n\n    that._resetTimer();\n\n    that._stuckSeries = null;\n  },\n  _getSeriesForShared: function (x, y) {\n    var that = this;\n    var points = [];\n    var point = null;\n    var distance = 1 / 0;\n\n    if (that._tooltip.isShared() && !that.hoveredSeries) {\n      _each(that._storedSeries, function (_, series) {\n        var point = series.getNeighborPoint(x, y);\n        point && points.push(point);\n      });\n\n      _each(points, function (_, p) {\n        var coords = p.getCrosshairData(x, y);\n        var d = vizUtils.getDistance(x, y, coords.x, coords.y);\n\n        if (d < distance) {\n          point = p;\n          distance = d;\n        }\n      });\n    }\n\n    return point && point.series;\n  },\n  _setTimeout: function (callback, keeper) {\n    var that = this;\n\n    if (that._timeoutKeeper !== keeper) {\n      that._resetTimer();\n\n      that._hoverTimeout = setTimeout(function () {\n        callback();\n        that._timeoutKeeper = null;\n      }, DELAY);\n      that._timeoutKeeper = keeper;\n    }\n  },\n  _resetTimer: function () {\n    clearTimeout(this._hoverTimeout);\n    this._timeoutKeeper = this._hoverTimeout = null;\n  },\n  _stopEvent: function (e) {\n    if (!isDefined(e.cancelable) || e.cancelable) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  },\n  _setStuckSeries: function (e, series, x, y) {\n    if (\"mouse\" !== e.pointerType) {\n      this._stuckSeries = null;\n    } else {\n      this._stuckSeries = series || this._stuckSeries || this._getSeriesForShared(x, y);\n    }\n\n    return !!this._stuckSeries;\n  },\n  _pointerOut: function () {\n    var that = this;\n    that._stuckSeries = null;\n\n    that._hideCrosshair();\n\n    that._resetTimer();\n\n    baseTrackerPrototype._pointerOut.apply(that, arguments);\n  },\n  _hoverArgumentAxis: function (x, y, e) {\n    var that = this;\n\n    that._resetHoveredArgument();\n\n    if (that._axisHoverEnabled && that._argumentAxis.coordsIn(x, y)) {\n      that._hoverArgument(getData(e, ARG_DATA));\n\n      return true;\n    }\n  },\n  _pointerComplete: function (point, x, y) {\n    var that = this;\n    that.hoveredSeries && that.hoveredSeries.updateHover(x, y);\n\n    that._resetTimer();\n\n    that._moveCrosshair(point, x, y);\n\n    baseTrackerPrototype._pointerComplete.call(that, point);\n  },\n  _legendClick: function (item, e) {\n    var series = this._storedSeries[item.id];\n\n    this._triggerLegendClick({\n      target: series,\n      event: e\n    }, SERIES_CLICK);\n  },\n  _hoverLegendItem: function (x, y) {\n    this._stuckSeries = null;\n\n    this._hideCrosshair();\n\n    baseTrackerPrototype._hoverLegendItem.call(this, x, y);\n  },\n  _pointerOnPoint: function (point, x, y, e) {\n    this._setStuckSeries(e, point.series, x, y);\n\n    this._releaseHoveredSeries();\n\n    baseTrackerPrototype._pointerOnPoint.call(this, point, x, y, e);\n  },\n  _notifyLegendOnHoverArgument: false,\n  _getArgumentHoverMode: function () {\n    return correctHoverMode(this._argumentAxis);\n  },\n  dispose: function () {\n    this._resetTimer();\n\n    baseTrackerPrototype.dispose.call(this);\n  }\n});\n\nvar PieTracker = function (options) {\n  this.ctor(options);\n};\n\nextend(PieTracker.prototype, baseTrackerPrototype, {\n  _isPointerOut: function (_, point) {\n    return !point;\n  },\n  _legendClick: function (item, e) {\n    var that = this;\n    var points = [];\n\n    that._storedSeries.forEach(function (s) {\n      return points.push.apply(points, s.getPointsByKeys(item.argument, item.argumentIndex));\n    });\n\n    that._eventTrigger(LEGEND_CLICK, {\n      target: item.argument,\n      points: points,\n      event: e\n    });\n  },\n  _pointClick: function (point, e) {\n    this._eventTrigger(POINT_CLICK, {\n      target: point,\n      event: e\n    });\n  },\n  _hoverLegendItem: function (x, y) {\n    var that = this;\n\n    var item = that._legend.getItemByCoord(x, y);\n\n    if (item && that._hoveredArgument !== item.argument) {\n      that._resetHoveredArgument();\n\n      that._hoverArgument(item.argument, item.argumentIndex);\n    } else {\n      if (!item) {\n        that.clearHover();\n      }\n    }\n  },\n  _getArgumentHoverMode: function () {\n    return correctHoverMode(this._legend);\n  },\n  _hoverArgumentAxis: _noop,\n  _setStuckSeries: _noop,\n  _getCanvas: _noop,\n  _notifyLegendOnHoverArgument: true\n});\nexports.ChartTracker = ChartTracker;\nexports.PieTracker = PieTracker;","map":null,"metadata":{},"sourceType":"script"}