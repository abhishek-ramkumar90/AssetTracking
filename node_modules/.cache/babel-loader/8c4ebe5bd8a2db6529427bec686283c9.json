{"ast":null,"code":"/**\r\n * DevExtreme (viz/series/points/base_point.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar mixins = {};\n\nvar statesConsts = require(\"../../components/consts\").states;\n\nvar symbolPoint = require(\"./symbol_point\");\n\nvar barPoint = require(\"./bar_point\");\n\nvar bubblePoint = require(\"./bubble_point\");\n\nvar piePoint = require(\"./pie_point\");\n\nvar rangeSymbolPoint = require(\"./range_symbol_point\");\n\nvar rangeBarPoint = require(\"./range_bar_point\");\n\nvar candlestickPoint = require(\"./candlestick_point\");\n\nvar stockPoint = require(\"./stock_point\");\n\nvar polarPoints = require(\"./polar_point\");\n\nvar _normalizeEnum = require(\"../../core/utils\").normalizeEnum;\n\nvar extend = require(\"../../../core/utils/extend\").extend;\n\nvar _extend = extend;\n\nvar _isDefined = require(\"../../../core/utils/type\").isDefined;\n\nvar _noop = require(\"../../../core/utils/common\").noop;\n\nvar SYMBOL_POINT = \"symbolPoint\";\nvar POLAR_SYMBOL_POINT = \"polarSymbolPoint\";\nvar BAR_POINT = \"barPoint\";\nvar POLAR_BAR_POINT = \"polarBarPoint\";\nvar PIE_POINT = \"piePoint\";\nvar SELECTED_STATE = statesConsts.selectedMark;\nvar HOVER_STATE = statesConsts.hoverMark;\nvar NORMAL_STATE = statesConsts.normalMark;\nvar HOVER = statesConsts.hover;\nvar NORMAL = statesConsts.normal;\nvar SELECTION = statesConsts.selection;\nvar pointTypes = {\n  chart: {\n    scatter: SYMBOL_POINT,\n    line: SYMBOL_POINT,\n    spline: SYMBOL_POINT,\n    stepline: SYMBOL_POINT,\n    stackedline: SYMBOL_POINT,\n    fullstackedline: SYMBOL_POINT,\n    stackedspline: SYMBOL_POINT,\n    fullstackedspline: SYMBOL_POINT,\n    stackedsplinearea: SYMBOL_POINT,\n    fullstackedsplinearea: SYMBOL_POINT,\n    area: SYMBOL_POINT,\n    splinearea: SYMBOL_POINT,\n    steparea: SYMBOL_POINT,\n    stackedarea: SYMBOL_POINT,\n    fullstackedarea: SYMBOL_POINT,\n    rangearea: \"rangeSymbolPoint\",\n    bar: BAR_POINT,\n    stackedbar: BAR_POINT,\n    fullstackedbar: BAR_POINT,\n    rangebar: \"rangeBarPoint\",\n    bubble: \"bubblePoint\",\n    stock: \"stockPoint\",\n    candlestick: \"candlestickPoint\"\n  },\n  pie: {\n    pie: PIE_POINT,\n    doughnut: PIE_POINT,\n    donut: PIE_POINT\n  },\n  polar: {\n    scatter: POLAR_SYMBOL_POINT,\n    line: POLAR_SYMBOL_POINT,\n    area: POLAR_SYMBOL_POINT,\n    bar: POLAR_BAR_POINT,\n    stackedbar: POLAR_BAR_POINT\n  }\n};\n\nfunction isNoneMode(mode) {\n  return \"none\" === _normalizeEnum(mode);\n}\n\nfunction Point(series, dataItem, options) {\n  this.fullState = NORMAL_STATE;\n  this.series = series;\n  this.update(dataItem, options);\n  this._viewCounters = {\n    hover: 0,\n    selection: 0\n  };\n  this._emptySettings = {\n    fill: null,\n    stroke: null,\n    dashStyle: null\n  };\n}\n\nexports.Point = Point;\nmixins.symbolPoint = symbolPoint;\nmixins.barPoint = barPoint;\nmixins.bubblePoint = bubblePoint;\nmixins.piePoint = piePoint;\nmixins.rangeSymbolPoint = rangeSymbolPoint;\nmixins.rangeBarPoint = rangeBarPoint;\nmixins.candlestickPoint = candlestickPoint;\nmixins.stockPoint = stockPoint;\nmixins.polarSymbolPoint = polarPoints.polarSymbolPoint;\nmixins.polarBarPoint = polarPoints.polarBarPoint;\nPoint.prototype = {\n  constructor: Point,\n  getColor: function () {\n    if (!this.hasValue() && !this._styles.usePointCustomOptions) {\n      this.series.customizePoint(this, this._dataItem);\n    }\n\n    return this._styles.normal.fill || this.series.getColor();\n  },\n  _getStyle: function () {\n    return this._styles[this._currentStyle || \"normal\"];\n  },\n  update: function (dataItem, options) {\n    this.updateOptions(options);\n    this.updateData(dataItem);\n  },\n  updateData: function (dataItem) {\n    var that = this;\n    var argumentWasChanged = that.argument !== dataItem.argument;\n    that.argument = that.initialArgument = that.originalArgument = dataItem.argument;\n    that.tag = dataItem.tag;\n    that.index = dataItem.index;\n    that._dataItem = dataItem;\n    that.data = dataItem.data;\n    that.lowError = dataItem.lowError;\n    that.highError = dataItem.highError;\n    that.aggregationInfo = dataItem.aggregationInfo;\n\n    that._updateData(dataItem, argumentWasChanged);\n\n    !that.hasValue() && that.setInvisibility();\n\n    that._fillStyle();\n\n    that._updateLabelData();\n  },\n  deleteMarker: function () {\n    var that = this;\n\n    if (that.graphic) {\n      that.graphic.dispose();\n    }\n\n    that.graphic = null;\n  },\n  draw: function (renderer, groups, animationEnabled, firstDrawing) {\n    var that = this;\n\n    if (that._needDeletingOnDraw || that.series.autoHidePointMarkers && !that.isSelected()) {\n      that.deleteMarker();\n      that._needDeletingOnDraw = false;\n    }\n\n    if (that._needClearingOnDraw) {\n      that.clearMarker();\n      that._needClearingOnDraw = false;\n    }\n\n    if (!that._hasGraphic()) {\n      that.getMarkerVisibility() && !that.series.autoHidePointMarkers && that._drawMarker(renderer, groups.markers, animationEnabled, firstDrawing);\n    } else {\n      that._updateMarker(animationEnabled, this._getStyle(), groups.markers);\n    }\n\n    that._drawLabel();\n\n    that._drawErrorBar(renderer, groups.errorBars, animationEnabled);\n\n    return that;\n  },\n  _getViewStyle: function () {\n    var state = NORMAL_STATE;\n    var fullState = this.fullState;\n    var styles = [NORMAL, HOVER, SELECTION, SELECTION];\n\n    if (this._viewCounters.hover) {\n      state |= HOVER_STATE;\n    }\n\n    if (this._viewCounters.selection) {\n      state |= SELECTED_STATE;\n    }\n\n    if (isNoneMode(this.getOptions().selectionMode)) {\n      fullState &= ~SELECTED_STATE;\n    }\n\n    if (isNoneMode(this.getOptions().hoverMode)) {\n      fullState &= ~HOVER_STATE;\n    }\n\n    state |= fullState;\n    return styles[state];\n  },\n  applyView: function (legendCallback) {\n    var style = this._getViewStyle();\n\n    var that = this;\n    that._currentStyle = style;\n\n    if (!that.graphic && that.series.autoHidePointMarkers && (style === SELECTION || style === HOVER)) {\n      that._drawMarker(that.series.getRenderer(), that.series.getMarkersGroup());\n    }\n\n    if (that.graphic) {\n      if (that.series.autoHidePointMarkers && style !== SELECTION && style !== HOVER) {\n        that.deleteMarker();\n      } else {\n        if (\"normal\" === style) {\n          that.clearMarker();\n        } else {\n          that.graphic.toForeground();\n        }\n\n        that._updateMarker(true, that._styles[style], void 0, legendCallback);\n      }\n    }\n  },\n  setView: function (style) {\n    this._viewCounters[style]++;\n    this.applyView();\n  },\n  resetView: function (style) {\n    var viewCounters = this._viewCounters;\n    --viewCounters[style];\n\n    if (viewCounters[style] < 0) {\n      viewCounters[style] = 0;\n    }\n\n    this.applyView();\n  },\n  releaseHoverState: function () {\n    var that = this;\n\n    if (that.graphic && !that.isSelected()) {\n      that.graphic.toBackground();\n    }\n  },\n  select: function () {\n    this.series.selectPoint(this);\n  },\n  clearSelection: function () {\n    this.series.deselectPoint(this);\n  },\n  hover: function () {\n    this.series.hoverPoint(this);\n  },\n  clearHover: function () {\n    this.series.clearPointHover();\n  },\n  showTooltip: function () {\n    this.series.showPointTooltip(this);\n  },\n  hideTooltip: function () {\n    this.series.hidePointTooltip(this);\n  },\n  _checkLabelsChanging: function (oldType, newType) {\n    var isNewRange = ~newType.indexOf(\"range\");\n    var isOldRange = ~oldType.indexOf(\"range\");\n    return isOldRange && !isNewRange || !isOldRange && isNewRange;\n  },\n  updateOptions: function (newOptions) {\n    if (!newOptions) {\n      return;\n    }\n\n    var that = this;\n    var oldOptions = that._options;\n    var widgetType = newOptions.widgetType;\n    var oldType = oldOptions && oldOptions.type;\n    var newType = newOptions.type;\n    var newPointTypeMixin = pointTypes[widgetType][newType];\n\n    if (oldType !== newType) {\n      that._needDeletingOnDraw = true;\n      that._needClearingOnDraw = false;\n\n      if (oldType) {\n        that._checkLabelsChanging(oldType, newType) && that.deleteLabel();\n\n        that._resetType(mixins[pointTypes[oldType]]);\n      }\n\n      that._setType(mixins[newPointTypeMixin]);\n    } else {\n      that._needDeletingOnDraw = that._checkSymbol(oldOptions, newOptions);\n      that._needClearingOnDraw = that._checkCustomize(oldOptions, newOptions);\n    }\n\n    that._options = newOptions;\n\n    that._fillStyle();\n\n    that._updateLabelOptions(newPointTypeMixin);\n  },\n  translate: function () {\n    if (this.hasValue()) {\n      this._translate();\n\n      this.translated = true;\n    }\n  },\n  _checkCustomize: function (oldOptions, newOptions) {\n    return oldOptions.styles.usePointCustomOptions && !newOptions.styles.usePointCustomOptions;\n  },\n  _getCustomLabelVisibility: function () {\n    return this._styles.useLabelCustomOptions ? !!this._options.label.visible : null;\n  },\n  getBoundingRect: function () {\n    return this._getGraphicBBox();\n  },\n  _resetType: function (methods) {\n    for (var methodName in methods) {\n      delete this[methodName];\n    }\n  },\n  _setType: function (methods) {\n    for (var methodName in methods) {\n      this[methodName] = methods[methodName];\n    }\n  },\n  isInVisibleArea: function () {\n    return this.inVisibleArea;\n  },\n  isSelected: function () {\n    return !!(this.fullState & SELECTED_STATE);\n  },\n  isHovered: function () {\n    return !!(this.fullState & HOVER_STATE);\n  },\n  getOptions: function () {\n    return this._options;\n  },\n  animate: function (complete, settings, partitionDuration) {\n    if (!this.graphic) {\n      complete && complete();\n      return;\n    }\n\n    this.graphic.animate(settings, {\n      partitionDuration: partitionDuration\n    }, complete);\n  },\n  getCoords: function (min) {\n    var that = this;\n\n    if (!min) {\n      return {\n        x: that.x,\n        y: that.y\n      };\n    }\n\n    if (!that._options.rotated) {\n      return {\n        x: that.x,\n        y: that.minY + (that.y - that.minY ? 0 : 1)\n      };\n    }\n\n    return {\n      x: that.minX - (that.x - that.minX ? 0 : 1),\n      y: that.y\n    };\n  },\n  getDefaultCoords: function () {\n    var that = this;\n    return !that._options.rotated ? {\n      x: that.x,\n      y: that.defaultY\n    } : {\n      x: that.defaultX,\n      y: that.y\n    };\n  },\n  setDefaultCoords: function () {\n    var coords = this.getDefaultCoords();\n    this.x = coords.x;\n    this.y = coords.y;\n  },\n  _getVisibleArea: function () {\n    return this.series.getVisibleArea();\n  },\n  _getArgTranslator: function () {\n    return this.series.getArgumentAxis().getTranslator();\n  },\n  _getValTranslator: function () {\n    return this.series.getValueAxis().getTranslator();\n  },\n  _calculateVisibility: function (x, y, width, height) {\n    var that = this;\n\n    var visibleArea = that._getVisibleArea();\n\n    var rotated = that._options.rotated;\n\n    if (visibleArea.minX > x + (width || 0) || visibleArea.maxX < x || visibleArea.minY > y + (height || 0) || visibleArea.maxY < y || rotated && _isDefined(width) && 0 !== width && (visibleArea.minX === x + width || visibleArea.maxX === x) || !rotated && _isDefined(height) && 0 !== height && (visibleArea.minY === y + height || visibleArea.maxY === y)) {\n      that.inVisibleArea = false;\n    } else {\n      that.inVisibleArea = true;\n    }\n  },\n  isArgumentCorrect: function () {\n    return this.series._argumentChecker(this.argument);\n  },\n  isValueCorrect: function () {\n    var valueChecker = this.series._valueChecker;\n    return valueChecker(this.getMinValue()) && valueChecker(this.getMaxValue());\n  },\n  hasValue: function () {\n    return null !== this.value && null !== this.minValue && this.isArgumentCorrect() && this.isValueCorrect();\n  },\n  hasCoords: _noop,\n  correctPosition: _noop,\n  correctRadius: _noop,\n  correctLabelRadius: _noop,\n  getCrosshairData: _noop,\n  getPointRadius: _noop,\n  _populatePointShape: _noop,\n  _checkSymbol: _noop,\n  getMarkerCoords: _noop,\n  hide: _noop,\n  show: _noop,\n  hideMarker: _noop,\n  setInvisibility: _noop,\n  clearVisibility: _noop,\n  isVisible: _noop,\n  resetCorrection: _noop,\n  correctValue: _noop,\n  resetValue: _noop,\n  setPercentValue: _noop,\n  correctCoordinates: _noop,\n  coordsIn: _noop,\n  getTooltipParams: _noop,\n  applyWordWrap: _noop,\n  setLabelTrackerData: _noop,\n  updateLabelCoord: _noop,\n  drawLabel: _noop,\n  correctLabelPosition: _noop,\n  getMinValue: _noop,\n  getMaxValue: _noop,\n  _drawErrorBar: _noop,\n  getMarkerVisibility: _noop,\n  dispose: function () {\n    var that = this;\n    that.deleteMarker();\n    that.deleteLabel();\n    that._errorBar && this._errorBar.dispose();\n    that._options = that._styles = that.series = that._errorBar = null;\n  },\n  getTooltipFormatObject: function (tooltip, stackPoints) {\n    var that = this;\n\n    var tooltipFormatObject = that._getFormatObject(tooltip);\n\n    var sharedTooltipValuesArray = [];\n    var tooltipStackPointsFormatObject = [];\n\n    if (stackPoints) {\n      stackPoints.forEach(function (point) {\n        if (!point.isVisible()) {\n          return;\n        }\n\n        var formatObject = point._getFormatObject(tooltip);\n\n        tooltipStackPointsFormatObject.push(formatObject);\n        sharedTooltipValuesArray.push(formatObject.seriesName + \": \" + formatObject.valueText);\n      });\n\n      _extend(tooltipFormatObject, {\n        points: tooltipStackPointsFormatObject,\n        valueText: sharedTooltipValuesArray.join(\"\\n\"),\n        stackName: that.series.getStackName() || null\n      });\n    }\n\n    var aggregationInfo = that.aggregationInfo;\n\n    if (aggregationInfo) {\n      var axis = that.series.getArgumentAxis();\n      var rangeText = axis.formatRange(aggregationInfo.intervalStart, aggregationInfo.intervalEnd, aggregationInfo.aggregationInterval);\n\n      if (rangeText) {\n        tooltipFormatObject.valueText += \"\\n\".concat(rangeText);\n      }\n    }\n\n    return tooltipFormatObject;\n  },\n  setHole: function (holeValue, position) {\n    var that = this;\n    var minValue = isFinite(that.minValue) ? that.minValue : 0;\n\n    if (_isDefined(holeValue)) {\n      if (\"left\" === position) {\n        that.leftHole = that.value - holeValue;\n        that.minLeftHole = minValue - holeValue;\n      } else {\n        that.rightHole = that.value - holeValue;\n        that.minRightHole = minValue - holeValue;\n      }\n    }\n  },\n  resetHoles: function () {\n    this.leftHole = null;\n    this.minLeftHole = null;\n    this.rightHole = null;\n    this.minRightHole = null;\n  },\n  getLabel: function () {\n    return this._label;\n  },\n  getLabels: function () {\n    return [this._label];\n  },\n  getCenterCoord: function () {\n    return {\n      x: this.x,\n      y: this.y\n    };\n  }\n};","map":null,"metadata":{},"sourceType":"script"}