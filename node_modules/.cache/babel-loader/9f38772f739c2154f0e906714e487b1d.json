{"ast":null,"code":"/**\r\n * DevExtreme (viz/core/renderers/renderer.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _renderer = require(\"../../../core/renderer\");\n\nvar _renderer2 = _interopRequireDefault(_renderer);\n\nvar _dom_adapter = require(\"../../../core/dom_adapter\");\n\nvar _dom_adapter2 = _interopRequireDefault(_dom_adapter);\n\nvar _window = require(\"../../../core/utils/window\");\n\nvar _window2 = _interopRequireDefault(_window);\n\nvar _call_once = require(\"../../../core/utils/call_once\");\n\nvar _call_once2 = _interopRequireDefault(_call_once);\n\nvar _events_engine = require(\"../../../events/core/events_engine\");\n\nvar _events_engine2 = _interopRequireDefault(_events_engine);\n\nvar _browser = require(\"../../../core/utils/browser\");\n\nvar _browser2 = _interopRequireDefault(_browser);\n\nvar _svg = require(\"../../../core/utils/svg\");\n\nvar _animation = require(\"./animation\");\n\nvar _animation2 = _interopRequireDefault(_animation);\n\nvar _utils = require(\"../utils\");\n\nvar _type = require(\"../../../core/utils/type\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) {\n    return;\n  }\n\n  if (\"string\" === typeof o) {\n    return _arrayLikeToArray(o, minLen);\n  }\n\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n\n  if (\"Object\" === n && o.constructor) {\n    n = o.constructor.name;\n  }\n\n  if (\"Map\" === n || \"Set\" === n) {\n    return Array.from(n);\n  }\n\n  if (\"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {\n    return _arrayLikeToArray(o, minLen);\n  }\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (null == len || len > arr.length) {\n    len = arr.length;\n  }\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (\"undefined\" === typeof Symbol || !(Symbol.iterator in Object(arr))) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _e = void 0;\n\n  try {\n    for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) {\n        break;\n      }\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && null != _i.return) {\n        _i.return();\n      }\n    } finally {\n      if (_d) {\n        throw _e;\n      }\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) {\n    return arr;\n  }\n}\n\nvar window = _window2.default.getWindow();\n\nvar max = Math.max,\n    min = Math.min,\n    floor = Math.floor,\n    round = Math.round,\n    sin = Math.sin,\n    cos = Math.cos,\n    abs = Math.abs,\n    PI = Math.PI;\nvar PI_DIV_180 = PI / 180;\nvar SHARPING_CORRECTION = .5;\nvar ARC_COORD_PREC = 5;\nvar pxAddingExceptions = {\n  \"column-count\": true,\n  \"fill-opacity\": true,\n  \"flex-grow\": true,\n  \"flex-shrink\": true,\n  \"font-weight\": true,\n  \"line-height\": true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  widows: true,\n  \"z-index\": true,\n  zoom: true\n};\nvar KEY_TEXT = \"text\";\nvar KEY_STROKE = \"stroke\";\nvar KEY_STROKE_WIDTH = \"stroke-width\";\nvar KEY_STROKE_OPACITY = \"stroke-opacity\";\nvar KEY_FONT_SIZE = \"font-size\";\nvar KEY_FONT_STYLE = \"font-style\";\nvar KEY_FONT_WEIGHT = \"font-weight\";\nvar KEY_TEXT_DECORATION = \"text-decoration\";\nvar KEY_TEXTS_ALIGNMENT = \"textsAlignment\";\nvar NONE = \"none\";\nvar DEFAULT_FONT_SIZE = 12;\nvar ELLIPSIS = \"...\";\n\nvar objectCreate = function () {\n  if (!Object.create) {\n    return function (proto) {\n      var F = function () {};\n\n      F.prototype = proto;\n      return new F();\n    };\n  } else {\n    return function (proto) {\n      return Object.create(proto);\n    };\n  }\n}();\n\nvar DEFAULTS = {\n  scaleX: 1,\n  scaleY: 1,\n  \"pointer-events\": null\n};\nvar getBackup = (0, _call_once2.default)(function () {\n  var backupContainer = _dom_adapter2.default.createElement(\"div\");\n\n  var backupCounter = 0;\n  backupContainer.style.left = \"-9999px\";\n  backupContainer.style.position = \"absolute\";\n  return {\n    backupContainer: backupContainer,\n    backupCounter: backupCounter\n  };\n});\n\nfunction backupRoot(root) {\n  if (0 === getBackup().backupCounter) {\n    _dom_adapter2.default.getBody().appendChild(getBackup().backupContainer);\n  }\n\n  ++getBackup().backupCounter;\n  root.append({\n    element: getBackup().backupContainer\n  });\n}\n\nfunction restoreRoot(root, container) {\n  root.append({\n    element: container\n  });\n  --getBackup().backupCounter;\n\n  if (0 === getBackup().backupCounter) {\n    _dom_adapter2.default.getBody().removeChild(getBackup().backupContainer);\n  }\n}\n\nvar getNextDefsSvgId = function () {\n  var numDefsSvgElements = 1;\n  return function () {\n    return \"DevExpress_\" + numDefsSvgElements++;\n  };\n}();\n\nfunction isObjectArgument(value) {\n  return value && \"string\" !== typeof value;\n}\n\nfunction createElement(tagName) {\n  return _dom_adapter2.default.createElementNS(\"http://www.w3.org/2000/svg\", tagName);\n}\n\nfunction getFuncIri(id, pathModified) {\n  return null !== id ? \"url(\" + (pathModified ? window.location.href.split(\"#\")[0] : \"\") + \"#\" + id + \")\" : id;\n}\n\nmodule.exports.getFuncIri = getFuncIri;\n\nfunction extend(target, source) {\n  var key;\n\n  for (key in source) {\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction roundValue(value, exp) {\n  value = value.toString().split(\"e\");\n  value = round(+(value[0] + \"e\" + (value[1] ? +value[1] + exp : exp)));\n  value = value.toString().split(\"e\");\n  return +(value[0] + \"e\" + (value[1] ? +value[1] - exp : -exp));\n}\n\nfunction getBoundingClientRect(element) {\n  var box;\n\n  try {\n    box = element.getBoundingClientRect();\n  } catch (e) {}\n\n  return box || {\n    left: 0,\n    top: 0\n  };\n}\n\nvar preserveAspectRatioMap = {\n  full: NONE,\n  lefttop: \"xMinYMin\",\n  leftcenter: \"xMinYMid\",\n  leftbottom: \"xMinYMax\",\n  centertop: \"xMidYMin\",\n  center: \"xMidYMid\",\n  centerbottom: \"xMidYMax\",\n  righttop: \"xMaxYMin\",\n  rightcenter: \"xMaxYMid\",\n  rightbottom: \"xMaxYMax\"\n};\n\nfunction processHatchingAttrs(element, attrs) {\n  if (attrs.hatching && \"none\" !== (0, _utils.normalizeEnum)(attrs.hatching.direction)) {\n    attrs = extend({}, attrs);\n    attrs.fill = element._hatching = element.renderer.lockHatching(attrs.fill, attrs.hatching, element._hatching);\n    delete attrs.hatching;\n  } else {\n    if (element._hatching) {\n      element.renderer.releaseHatching(element._hatching);\n      element._hatching = null;\n    }\n  }\n\n  return attrs;\n}\n\nmodule.exports.processHatchingAttrs = processHatchingAttrs;\n\nfunction normalizeArcParams(x, y, innerR, outerR, startAngle, endAngle) {\n  var isCircle;\n  var noArc = true;\n  var angleDiff = roundValue(endAngle, 3) - roundValue(startAngle, 3);\n\n  if (angleDiff) {\n    if (abs(angleDiff) % 360 === 0) {\n      startAngle = 0;\n      endAngle = 360;\n      isCircle = true;\n      endAngle -= .01;\n    }\n\n    if (startAngle > 360) {\n      startAngle %= 360;\n    }\n\n    if (endAngle > 360) {\n      endAngle %= 360;\n    }\n\n    if (startAngle > endAngle) {\n      startAngle -= 360;\n    }\n\n    noArc = false;\n  }\n\n  startAngle *= PI_DIV_180;\n  endAngle *= PI_DIV_180;\n  return [x, y, min(outerR, innerR), max(outerR, innerR), cos(startAngle), sin(startAngle), cos(endAngle), sin(endAngle), isCircle, floor(abs(endAngle - startAngle) / PI) % 2 ? \"1\" : \"0\", noArc];\n}\n\nvar buildArcPath = function (x, y, innerR, outerR, startAngleCos, startAngleSin, endAngleCos, endAngleSin, isCircle, longFlag) {\n  return [\"M\", (x + outerR * startAngleCos).toFixed(ARC_COORD_PREC), (y - outerR * startAngleSin).toFixed(ARC_COORD_PREC), \"A\", outerR.toFixed(ARC_COORD_PREC), outerR.toFixed(ARC_COORD_PREC), 0, longFlag, 0, (x + outerR * endAngleCos).toFixed(ARC_COORD_PREC), (y - outerR * endAngleSin).toFixed(ARC_COORD_PREC), isCircle ? \"M\" : \"L\", (x + innerR * endAngleCos).toFixed(5), (y - innerR * endAngleSin).toFixed(ARC_COORD_PREC), \"A\", innerR.toFixed(ARC_COORD_PREC), innerR.toFixed(ARC_COORD_PREC), 0, longFlag, 1, (x + innerR * startAngleCos).toFixed(ARC_COORD_PREC), (y - innerR * startAngleSin).toFixed(ARC_COORD_PREC), \"Z\"].join(\" \");\n};\n\nfunction buildPathSegments(points, type) {\n  var list = [[\"M\", 0, 0]];\n\n  switch (type) {\n    case \"line\":\n      list = buildLineSegments(points);\n      break;\n\n    case \"area\":\n      list = buildLineSegments(points, true);\n      break;\n\n    case \"bezier\":\n      list = buildCurveSegments(points);\n      break;\n\n    case \"bezierarea\":\n      list = buildCurveSegments(points, true);\n  }\n\n  return list;\n}\n\nfunction buildLineSegments(points, close) {\n  return buildSegments(points, buildSimpleLineSegment, close);\n}\n\nfunction buildCurveSegments(points, close) {\n  return buildSegments(points, buildSimpleCurveSegment, close);\n}\n\nfunction buildSegments(points, buildSimpleSegment, close) {\n  var i;\n  var ii;\n  var list = [];\n\n  if (points[0] && points[0].length) {\n    for (i = 0, ii = points.length; i < ii; ++i) {\n      buildSimpleSegment(points[i], close, list);\n    }\n  } else {\n    buildSimpleSegment(points, close, list);\n  }\n\n  return list;\n}\n\nfunction buildSimpleLineSegment(points, close, list) {\n  var i = 0;\n  var k0 = list.length;\n  var k = k0;\n  var ii = (points || []).length;\n\n  if (ii) {\n    if (void 0 !== points[0].x) {\n      for (; i < ii;) {\n        list[k++] = [\"L\", points[i].x, points[i++].y];\n      }\n    } else {\n      for (; i < ii;) {\n        list[k++] = [\"L\", points[i++], points[i++]];\n      }\n    }\n\n    list[k0][0] = \"M\";\n  } else {\n    list[k] = [\"M\", 0, 0];\n  }\n\n  close && list.push([\"Z\"]);\n  return list;\n}\n\nfunction buildSimpleCurveSegment(points, close, list) {\n  var i;\n  var k = list.length;\n  var ii = (points || []).length;\n\n  if (ii) {\n    if (void 0 !== points[0].x) {\n      list[k++] = [\"M\", points[0].x, points[0].y];\n\n      for (i = 1; i < ii;) {\n        list[k++] = [\"C\", points[i].x, points[i++].y, points[i].x, points[i++].y, points[i].x, points[i++].y];\n      }\n    } else {\n      list[k++] = [\"M\", points[0], points[1]];\n\n      for (i = 2; i < ii;) {\n        list[k++] = [\"C\", points[i++], points[i++], points[i++], points[i++], points[i++], points[i++]];\n      }\n    }\n  } else {\n    list[k] = [\"M\", 0, 0];\n  }\n\n  close && list.push([\"Z\"]);\n  return list;\n}\n\nfunction combinePathParam(segments) {\n  var d = [];\n  var k = 0;\n  var i;\n  var ii = segments.length;\n  var segment;\n  var j;\n  var jj;\n\n  for (i = 0; i < ii; ++i) {\n    segment = segments[i];\n\n    for (j = 0, jj = segment.length; j < jj; ++j) {\n      d[k++] = segment[j];\n    }\n  }\n\n  return d.join(\" \");\n}\n\nfunction compensateSegments(oldSegments, newSegments, type) {\n  var oldLength = oldSegments.length;\n  var newLength = newSegments.length;\n  var i;\n  var originalNewSegments;\n  var makeEqualSegments = type.indexOf(\"area\") !== -1 ? makeEqualAreaSegments : makeEqualLineSegments;\n\n  if (0 === oldLength) {\n    for (i = 0; i < newLength; i++) {\n      oldSegments.push(newSegments[i].slice(0));\n    }\n  } else {\n    if (oldLength < newLength) {\n      makeEqualSegments(oldSegments, newSegments, type);\n    } else {\n      if (oldLength > newLength) {\n        originalNewSegments = newSegments.slice(0);\n        makeEqualSegments(newSegments, oldSegments, type);\n      }\n    }\n  }\n\n  return originalNewSegments;\n}\n\nfunction prepareConstSegment(constSeg, type) {\n  var x = constSeg[constSeg.length - 2];\n  var y = constSeg[constSeg.length - 1];\n\n  switch (type) {\n    case \"line\":\n    case \"area\":\n      constSeg[0] = \"L\";\n      break;\n\n    case \"bezier\":\n    case \"bezierarea\":\n      constSeg[0] = \"C\";\n      constSeg[1] = constSeg[3] = constSeg[5] = x;\n      constSeg[2] = constSeg[4] = constSeg[6] = y;\n  }\n}\n\nfunction makeEqualLineSegments(short, long, type) {\n  var constSeg = short[short.length - 1].slice();\n  var i = short.length;\n  prepareConstSegment(constSeg, type);\n\n  for (; i < long.length; i++) {\n    short[i] = constSeg.slice(0);\n  }\n}\n\nfunction makeEqualAreaSegments(short, long, type) {\n  var i;\n  var head;\n  var shortLength = short.length;\n  var longLength = long.length;\n  var constsSeg1;\n  var constsSeg2;\n\n  if ((shortLength - 1) % 2 === 0 && (longLength - 1) % 2 === 0) {\n    i = (shortLength - 1) / 2 - 1;\n    head = short.slice(0, i + 1);\n    constsSeg1 = head[head.length - 1].slice(0);\n    constsSeg2 = short.slice(i + 1)[0].slice(0);\n    prepareConstSegment(constsSeg1, type);\n    prepareConstSegment(constsSeg2, type);\n\n    for (var j = i; j < (longLength - 1) / 2 - 1; j++) {\n      short.splice(j + 1, 0, constsSeg1);\n      short.splice(j + 3, 0, constsSeg2);\n    }\n  }\n}\n\nfunction baseCss(that, styles) {\n  var elemStyles = that._styles;\n  var str = \"\";\n  var key;\n  var value;\n  styles = styles || {};\n\n  for (key in styles) {\n    value = styles[key];\n\n    if ((0, _type.isDefined)(value)) {\n      value += \"number\" === typeof value && !pxAddingExceptions[key] ? \"px\" : \"\";\n      elemStyles[key] = \"\" !== value ? value : null;\n    }\n  }\n\n  for (key in elemStyles) {\n    value = elemStyles[key];\n\n    if (value) {\n      str += key + \":\" + value + \";\";\n    }\n  }\n\n  str && that.element.setAttribute(\"style\", str);\n  return that;\n}\n\nfunction fixFuncIri(wrapper, attribute) {\n  var element = wrapper.element;\n  var id = wrapper.attr(attribute);\n\n  if (id && id.indexOf(\"DevExpress\") !== -1) {\n    element.removeAttribute(attribute);\n    element.setAttribute(attribute, getFuncIri(id, wrapper.renderer.pathModified));\n  }\n}\n\nfunction baseAttr(that, attrs) {\n  attrs = attrs || {};\n  var settings = that._settings;\n  var attributes = {};\n  var key;\n  var value;\n  var elem = that.element;\n  var renderer = that.renderer;\n  var rtl = renderer.rtl;\n  var hasTransformations;\n  var recalculateDashStyle;\n  var sw;\n  var i;\n\n  if (!isObjectArgument(attrs)) {\n    if (attrs in settings) {\n      return settings[attrs];\n    }\n\n    if (attrs in DEFAULTS) {\n      return DEFAULTS[attrs];\n    }\n\n    return 0;\n  }\n\n  extend(attributes, attrs);\n\n  for (key in attributes) {\n    value = attributes[key];\n\n    if (void 0 === value) {\n      continue;\n    }\n\n    settings[key] = value;\n\n    if (\"align\" === key) {\n      key = \"text-anchor\";\n      value = {\n        left: rtl ? \"end\" : \"start\",\n        center: \"middle\",\n        right: rtl ? \"start\" : \"end\"\n      }[value] || null;\n    } else {\n      if (\"dashStyle\" === key) {\n        recalculateDashStyle = true;\n        continue;\n      } else {\n        if (key === KEY_STROKE_WIDTH) {\n          recalculateDashStyle = true;\n        } else {\n          if (value && (\"fill\" === key || \"clip-path\" === key || \"filter\" === key) && 0 === value.indexOf(\"DevExpress\")) {\n            that._addFixIRICallback();\n\n            value = getFuncIri(value, renderer.pathModified);\n          } else {\n            if (/^(translate(X|Y)|rotate[XY]?|scale(X|Y)|sharp|sharpDirection)$/i.test(key)) {\n              hasTransformations = true;\n              continue;\n            } else {\n              if (/^(x|y|d)$/i.test(key)) {\n                hasTransformations = true;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (null === value) {\n      elem.removeAttribute(key);\n    } else {\n      elem.setAttribute(key, value);\n    }\n  }\n\n  if (recalculateDashStyle && \"dashStyle\" in settings) {\n    value = settings.dashStyle;\n    sw = (\"_originalSW\" in that ? that._originalSW : settings[KEY_STROKE_WIDTH]) || 1;\n    key = \"stroke-dasharray\";\n    value = null === value ? \"\" : (0, _utils.normalizeEnum)(value);\n\n    if (\"\" === value || \"solid\" === value || value === NONE) {\n      that.element.removeAttribute(key);\n    } else {\n      value = value.replace(/longdash/g, \"8,3,\").replace(/dash/g, \"4,3,\").replace(/dot/g, \"1,3,\").replace(/,$/, \"\").split(\",\");\n      i = value.length;\n\n      while (i--) {\n        value[i] = parseInt(value[i]) * sw;\n      }\n\n      that.element.setAttribute(key, value.join(\",\"));\n    }\n  }\n\n  if (hasTransformations) {\n    that._applyTransformation();\n  }\n\n  return that;\n}\n\nfunction pathAttr(attrs) {\n  var that = this;\n  var segments;\n\n  if (isObjectArgument(attrs)) {\n    attrs = extend({}, attrs);\n    segments = attrs.segments;\n\n    if (\"points\" in attrs) {\n      segments = buildPathSegments(attrs.points, that.type);\n      delete attrs.points;\n    }\n\n    if (segments) {\n      attrs.d = combinePathParam(segments);\n      that.segments = segments;\n      delete attrs.segments;\n    }\n  }\n\n  return baseAttr(that, attrs);\n}\n\nfunction arcAttr(attrs) {\n  var settings = this._settings;\n  var x;\n  var y;\n  var innerRadius;\n  var outerRadius;\n  var startAngle;\n  var endAngle;\n\n  if (isObjectArgument(attrs)) {\n    attrs = extend({}, attrs);\n\n    if (\"x\" in attrs || \"y\" in attrs || \"innerRadius\" in attrs || \"outerRadius\" in attrs || \"startAngle\" in attrs || \"endAngle\" in attrs) {\n      settings.x = x = \"x\" in attrs ? attrs.x : settings.x;\n      delete attrs.x;\n      settings.y = y = \"y\" in attrs ? attrs.y : settings.y;\n      delete attrs.y;\n      settings.innerRadius = innerRadius = \"innerRadius\" in attrs ? attrs.innerRadius : settings.innerRadius;\n      delete attrs.innerRadius;\n      settings.outerRadius = outerRadius = \"outerRadius\" in attrs ? attrs.outerRadius : settings.outerRadius;\n      delete attrs.outerRadius;\n      settings.startAngle = startAngle = \"startAngle\" in attrs ? attrs.startAngle : settings.startAngle;\n      delete attrs.startAngle;\n      settings.endAngle = endAngle = \"endAngle\" in attrs ? attrs.endAngle : settings.endAngle;\n      delete attrs.endAngle;\n      attrs.d = buildArcPath.apply(null, normalizeArcParams(x, y, innerRadius, outerRadius, startAngle, endAngle));\n    }\n  }\n\n  return baseAttr(this, attrs);\n}\n\nfunction rectAttr(attrs) {\n  var that = this;\n  var x;\n  var y;\n  var width;\n  var height;\n  var sw;\n  var maxSW;\n  var newSW;\n\n  if (isObjectArgument(attrs)) {\n    attrs = extend({}, attrs);\n\n    if (void 0 !== attrs.x || void 0 !== attrs.y || void 0 !== attrs.width || void 0 !== attrs.height || void 0 !== attrs[KEY_STROKE_WIDTH]) {\n      void 0 !== attrs.x ? x = that._originalX = attrs.x : x = that._originalX || 0;\n      void 0 !== attrs.y ? y = that._originalY = attrs.y : y = that._originalY || 0;\n      void 0 !== attrs.width ? width = that._originalWidth = attrs.width : width = that._originalWidth || 0;\n      void 0 !== attrs.height ? height = that._originalHeight = attrs.height : height = that._originalHeight || 0;\n      void 0 !== attrs[KEY_STROKE_WIDTH] ? sw = that._originalSW = attrs[KEY_STROKE_WIDTH] : sw = that._originalSW;\n      maxSW = ~~((width < height ? width : height) / 2);\n      newSW = (sw || 0) < maxSW ? sw || 0 : maxSW;\n      attrs.x = x + newSW / 2;\n      attrs.y = y + newSW / 2;\n      attrs.width = width - newSW;\n      attrs.height = height - newSW;\n      ((sw || 0) !== newSW || !(0 === newSW && void 0 === sw)) && (attrs[KEY_STROKE_WIDTH] = newSW);\n    }\n\n    if (\"sharp\" in attrs) {\n      delete attrs.sharp;\n    }\n  }\n\n  return baseAttr(that, attrs);\n}\n\nfunction textAttr(attrs) {\n  var that = this;\n  var settings;\n  var isResetRequired;\n  var wasStroked;\n  var isStroked;\n\n  if (!isObjectArgument(attrs)) {\n    return baseAttr(that, attrs);\n  }\n\n  attrs = extend({}, attrs);\n  settings = that._settings;\n  wasStroked = (0, _type.isDefined)(settings[KEY_STROKE]) && (0, _type.isDefined)(settings[KEY_STROKE_WIDTH]);\n\n  if (void 0 !== attrs[KEY_TEXT]) {\n    settings[KEY_TEXT] = attrs[KEY_TEXT];\n    delete attrs[KEY_TEXT];\n    isResetRequired = true;\n  }\n\n  if (void 0 !== attrs[KEY_STROKE]) {\n    settings[KEY_STROKE] = attrs[KEY_STROKE];\n    delete attrs[KEY_STROKE];\n  }\n\n  if (void 0 !== attrs[KEY_STROKE_WIDTH]) {\n    settings[KEY_STROKE_WIDTH] = attrs[KEY_STROKE_WIDTH];\n    delete attrs[KEY_STROKE_WIDTH];\n  }\n\n  if (void 0 !== attrs[KEY_STROKE_OPACITY]) {\n    settings[KEY_STROKE_OPACITY] = attrs[KEY_STROKE_OPACITY];\n    delete attrs[KEY_STROKE_OPACITY];\n  }\n\n  if (void 0 !== attrs[KEY_TEXTS_ALIGNMENT]) {\n    alignTextNodes(that, attrs[KEY_TEXTS_ALIGNMENT]);\n    delete attrs[KEY_TEXTS_ALIGNMENT];\n  }\n\n  isStroked = (0, _type.isDefined)(settings[KEY_STROKE]) && (0, _type.isDefined)(settings[KEY_STROKE_WIDTH]);\n  baseAttr(that, attrs);\n  isResetRequired = isResetRequired || isStroked !== wasStroked && settings[KEY_TEXT];\n\n  if (isResetRequired) {\n    createTextNodes(that, settings.text, isStroked);\n    that._hasEllipsis = false;\n  }\n\n  if (isResetRequired || void 0 !== attrs.x || void 0 !== attrs.y) {\n    locateTextNodes(that);\n  }\n\n  if (isStroked) {\n    strokeTextNodes(that);\n  }\n\n  return that;\n}\n\nfunction textCss(styles) {\n  styles = styles || {};\n  baseCss(this, styles);\n\n  if (KEY_FONT_SIZE in styles) {\n    locateTextNodes(this);\n  }\n\n  return this;\n}\n\nfunction orderHtmlTree(list, line, node, parentStyle, parentClassName) {\n  var style;\n  var realStyle;\n  var i;\n  var ii;\n  var nodes;\n\n  if (void 0 !== node.wholeText) {\n    list.push({\n      value: node.wholeText,\n      style: parentStyle,\n      className: parentClassName,\n      line: line,\n      height: parentStyle[KEY_FONT_SIZE] || 0\n    });\n  } else {\n    if (\"BR\" === node.tagName) {\n      ++line;\n    } else {\n      if (_dom_adapter2.default.isElementNode(node)) {\n        extend(style = {}, parentStyle);\n\n        switch (node.tagName) {\n          case \"B\":\n          case \"STRONG\":\n            style[KEY_FONT_WEIGHT] = \"bold\";\n            break;\n\n          case \"I\":\n          case \"EM\":\n            style[KEY_FONT_STYLE] = \"italic\";\n            break;\n\n          case \"U\":\n            style[KEY_TEXT_DECORATION] = \"underline\";\n        }\n\n        realStyle = node.style;\n        realStyle.color && (style.fill = realStyle.color);\n        realStyle.fontSize && (style[KEY_FONT_SIZE] = realStyle.fontSize);\n        realStyle.fontStyle && (style[KEY_FONT_STYLE] = realStyle.fontStyle);\n        realStyle.fontWeight && (style[KEY_FONT_WEIGHT] = realStyle.fontWeight);\n        realStyle.textDecoration && (style[KEY_TEXT_DECORATION] = realStyle.textDecoration);\n\n        for (i = 0, nodes = node.childNodes, ii = nodes.length; i < ii; ++i) {\n          line = orderHtmlTree(list, line, nodes[i], style, node.className || parentClassName);\n        }\n      }\n    }\n  }\n\n  return line;\n}\n\nfunction adjustLineHeights(items) {\n  var i;\n  var ii;\n  var currentItem = items[0];\n  var item;\n\n  for (i = 1, ii = items.length; i < ii; ++i) {\n    item = items[i];\n\n    if (item.line === currentItem.line) {\n      currentItem.height = maxLengthFontSize(currentItem.height, item.height);\n      currentItem.inherits = currentItem.inherits || 0 === parseFloat(item.height);\n      item.height = NaN;\n    } else {\n      currentItem = item;\n    }\n  }\n}\n\nfunction removeExtraAttrs(html) {\n  var findTagAttrs = /(?:(<[a-z0-9]+\\s*))([\\s\\S]*?)(>|\\/>)/gi;\n  var findStyleAndClassAttrs = /(style|class)\\s*=\\s*([\"'])(?:(?!\\2).)*\\2\\s?/gi;\n  return html.replace(findTagAttrs, function (allTagAttrs, p1, p2, p3) {\n    p2 = (p2 && p2.match(findStyleAndClassAttrs) || []).map(function (str) {\n      return str;\n    }).join(\" \");\n    return p1 + p2 + p3;\n  });\n}\n\nfunction parseHTML(text) {\n  var items = [];\n\n  var div = _dom_adapter2.default.createElement(\"div\");\n\n  div.innerHTML = text.replace(/\\r/g, \"\").replace(/\\n/g, \"<br/>\");\n  orderHtmlTree(items, 0, div, {}, \"\");\n  adjustLineHeights(items);\n  return items;\n}\n\nfunction parseMultiline(text) {\n  var texts = text.replace(/\\r/g, \"\").split(/\\n/g);\n  var i = 0;\n  var items = [];\n\n  for (; i < texts.length; i++) {\n    items.push({\n      value: texts[i].trim(),\n      height: 0,\n      line: i\n    });\n  }\n\n  return items;\n}\n\nfunction createTspans(items, element, fieldName) {\n  var i;\n  var ii;\n  var item;\n\n  for (i = 0, ii = items.length; i < ii; ++i) {\n    item = items[i];\n    item[fieldName] = createElement(\"tspan\");\n    item[fieldName].appendChild(_dom_adapter2.default.createTextNode(item.value));\n    item.style && baseCss({\n      element: item[fieldName],\n      _styles: {}\n    }, item.style);\n    item.className && item[fieldName].setAttribute(\"class\", item.className);\n    element.appendChild(item[fieldName]);\n  }\n}\n\nfunction restoreText() {\n  if (this._hasEllipsis) {\n    this.attr({\n      text: this._settings.text\n    });\n  }\n}\n\nfunction applyEllipsis(maxWidth) {\n  var that = this;\n  var lines;\n  var hasEllipsis = false;\n  var i;\n  var ii;\n  var lineParts;\n  var j;\n  var jj;\n  var text;\n  var ellipsis;\n  var ellipsisWidth;\n  restoreText.call(that);\n  ellipsis = that.renderer.text(ELLIPSIS).attr(that._styles).append(that.renderer.root);\n  ellipsisWidth = ellipsis.getBBox().width;\n\n  if (that._getElementBBox().width > maxWidth) {\n    if (maxWidth - ellipsisWidth < 0) {\n      maxWidth = 0;\n    } else {\n      maxWidth -= ellipsisWidth;\n    }\n\n    lines = prepareLines(that.element, that._texts, maxWidth);\n\n    for (i = 0, ii = lines.length; i < ii; ++i) {\n      lineParts = lines[i].parts;\n\n      if (1 === lines[i].commonLength) {\n        continue;\n      }\n\n      for (j = 0, jj = lineParts.length; j < jj; ++j) {\n        text = lineParts[j];\n\n        if ((0, _type.isDefined)(text.endIndex)) {\n          setNewText(text, text.endIndex);\n          hasEllipsis = true;\n        } else {\n          if (text.startBox > maxWidth) {\n            removeTextSpan(text);\n          }\n        }\n      }\n    }\n  }\n\n  ellipsis.remove();\n  that._hasEllipsis = hasEllipsis;\n  return hasEllipsis;\n}\n\nfunction cloneAndRemoveAttrs(node) {\n  var clone;\n\n  if (node) {\n    clone = node.cloneNode();\n    clone.removeAttribute(\"y\");\n    clone.removeAttribute(\"x\");\n  }\n\n  return clone || node;\n}\n\nfunction detachAndStoreTitleElements(element) {\n  var titleElements = _dom_adapter2.default.querySelectorAll(element, \"title\");\n\n  for (var i = 0; i < titleElements.length; i++) {\n    element.removeChild(titleElements[i]);\n  }\n\n  return function () {\n    for (var _i = 0; _i < titleElements.length; _i++) {\n      element.appendChild(titleElements[_i]);\n    }\n  };\n}\n\nfunction setMaxSize(maxWidth, maxHeight) {\n  var options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};\n  var that = this;\n  var lines = [];\n  var textChanged = false;\n  var textIsEmpty = false;\n  var ellipsis;\n  var ellipsisWidth;\n  var ellipsisMaxWidth = maxWidth;\n  restoreText.call(that);\n  var restoreTitleElement = detachAndStoreTitleElements(this.element);\n  ellipsis = that.renderer.text(ELLIPSIS).attr(that._styles).append(that.renderer.root);\n  ellipsisWidth = ellipsis.getBBox().width;\n\n  var _that$_getElementBBox = that._getElementBBox(),\n      width = _that$_getElementBBox.width,\n      height = _that$_getElementBBox.height;\n\n  if ((width || height) && (width > maxWidth || maxHeight && height > maxHeight)) {\n    if (maxWidth - ellipsisWidth < 0) {\n      ellipsisMaxWidth = 0;\n    } else {\n      ellipsisMaxWidth -= ellipsisWidth;\n    }\n\n    lines = applyOverflowRules(that.element, that._texts, maxWidth, ellipsisMaxWidth, options, maxHeight);\n    lines = setMaxHeight(lines, ellipsisMaxWidth, options, maxHeight, parseFloat(this._getLineHeight()));\n    this._texts = lines.reduce(function (texts, line) {\n      return texts.concat(line.parts);\n    }, []).filter(function (t) {\n      return \"\" !== t.value;\n    }).map(function (t) {\n      t.stroke && t.tspan.parentNode.appendChild(t.stroke);\n      return t;\n    }).map(function (t) {\n      t.tspan.parentNode.appendChild(t.tspan);\n      return t;\n    });\n    !this._texts.length && (this._texts = null);\n    textChanged = true;\n\n    if (this._texts) {\n      locateTextNodes(this);\n    } else {\n      this.element.textContent = \"\";\n      textIsEmpty = true;\n    }\n  }\n\n  ellipsis.remove();\n  that._hasEllipsis = textChanged;\n  restoreTitleElement();\n  return {\n    rowCount: lines.length,\n    textChanged: textChanged,\n    textIsEmpty: textIsEmpty\n  };\n}\n\nfunction getIndexForEllipsis(text, maxWidth, startBox, endBox) {\n  var k;\n  var kk;\n\n  if (startBox <= maxWidth && endBox > maxWidth) {\n    for (k = 1, kk = text.value.length; k <= kk; ++k) {\n      if (startBox + text.tspan.getSubStringLength(0, k) > maxWidth) {\n        return k - 1;\n      }\n    }\n  }\n}\n\nfunction getTextWidth(text) {\n  return text.value.length ? text.tspan.getSubStringLength(0, text.value.length) : 0;\n}\n\nfunction prepareLines(element, texts, maxWidth) {\n  var lines = [];\n  var i;\n  var ii;\n  var text;\n  var startBox;\n  var endBox;\n\n  if (texts) {\n    for (i = 0, ii = texts.length; i < ii; ++i) {\n      text = texts[i];\n\n      if (!lines[text.line]) {\n        text.startBox = startBox = 0;\n        lines.push({\n          commonLength: text.value.length,\n          parts: [text]\n        });\n      } else {\n        text.startBox = startBox;\n        lines[text.line].parts.push(text);\n        lines[text.line].commonLength += text.value.length;\n      }\n\n      endBox = startBox + text.tspan.getSubStringLength(0, text.value.length);\n      text.endIndex = getIndexForEllipsis(text, maxWidth, startBox, endBox);\n      startBox = endBox;\n    }\n  } else {\n    text = {\n      value: element.textContent,\n      tspan: element\n    };\n    text.startBox = startBox = 0;\n    endBox = startBox + getTextWidth(text);\n    text.endIndex = getIndexForEllipsis(text, maxWidth, startBox, endBox);\n    lines = [{\n      commonLength: element.textContent.length,\n      parts: [text]\n    }];\n  }\n\n  return lines;\n}\n\nfunction getSpaceBreakIndex(text, maxWidth) {\n  var initialIndices = text.startBox > 0 ? [0] : [];\n  var spaceIndices = text.value.split(\"\").reduce(function (indices, char, index) {\n    if (\" \" === char) {\n      indices.push(index);\n    }\n\n    return indices;\n  }, initialIndices);\n  var spaceIndex = 0;\n\n  while (void 0 !== spaceIndices[spaceIndex + 1] && text.startBox + text.tspan.getSubStringLength(0, spaceIndices[spaceIndex + 1]) < maxWidth) {\n    spaceIndex++;\n  }\n\n  return spaceIndices[spaceIndex];\n}\n\nfunction getWordBreakIndex(text, maxWidth) {\n  for (var i = 0; i < text.value.length - 1; i++) {\n    if (text.startBox + text.tspan.getSubStringLength(0, i + 1) > maxWidth) {\n      return i;\n    }\n  }\n}\n\nfunction getEllipsisString(ellipsisMaxWidth, _ref) {\n  var hideOverflowEllipsis = _ref.hideOverflowEllipsis;\n  return hideOverflowEllipsis && 0 === ellipsisMaxWidth ? \"\" : ELLIPSIS;\n}\n\nfunction setEllipsis(text, ellipsisMaxWidth, options) {\n  var ellipsis = getEllipsisString(ellipsisMaxWidth, options);\n\n  if (text.value.length && text.tspan.parentNode) {\n    for (var i = text.value.length - 1; i >= 1; i--) {\n      if (text.startBox + text.tspan.getSubStringLength(0, i) < ellipsisMaxWidth) {\n        setNewText(text, i, ellipsis);\n        break;\n      } else {\n        if (1 === i) {\n          setNewText(text, 0, ellipsis);\n        }\n      }\n    }\n  }\n}\n\nfunction wordWrap(text, maxWidth, ellipsisMaxWidth, options) {\n  var wholeText = text.value;\n  var breakIndex;\n\n  if (\"none\" !== options.wordWrap) {\n    breakIndex = \"normal\" === options.wordWrap ? getSpaceBreakIndex(text, maxWidth) : getWordBreakIndex(text, maxWidth);\n  }\n\n  var restLines = [];\n  var restText;\n\n  if (isFinite(breakIndex)) {\n    setNewText(text, breakIndex, \"\");\n    var newTextOffset = \" \" === wholeText[breakIndex] ? 1 : 0;\n    var restString = wholeText.slice(breakIndex + newTextOffset);\n\n    if (restString.length) {\n      var restTspan = cloneAndRemoveAttrs(text.tspan);\n      restTspan.textContent = restString;\n      text.tspan.parentNode.appendChild(restTspan);\n      restText = extend(extend({}, text), {\n        value: restString,\n        startBox: 0,\n        height: 0,\n        tspan: restTspan,\n        stroke: cloneAndRemoveAttrs(text.stroke),\n        endBox: restTspan.getSubStringLength(0, restString.length)\n      });\n      restText.stroke && (restText.stroke.textContent = restString);\n\n      if (restText.endBox > maxWidth) {\n        restLines = wordWrap(restText, maxWidth, ellipsisMaxWidth, options);\n\n        if (!restLines.length) {\n          return [];\n        }\n      }\n    }\n  }\n\n  if (text.value.length) {\n    if (\"ellipsis\" === options.textOverflow && text.tspan.getSubStringLength(0, text.value.length) > maxWidth) {\n      setEllipsis(text, ellipsisMaxWidth, options);\n    }\n\n    if (\"hide\" === options.textOverflow && text.tspan.getSubStringLength(0, text.value.length) > maxWidth) {\n      return [];\n    }\n  } else {\n    text.tspan.parentNode.removeChild(text.tspan);\n  }\n\n  var parts = [];\n\n  if (restText) {\n    parts.push(restText);\n  }\n\n  return [{\n    commonLength: wholeText.length,\n    parts: parts\n  }].concat(restLines);\n}\n\nfunction calculateLineHeight(line, lineHeight) {\n  return line.parts.reduce(function (height, text) {\n    return max(height, getItemLineHeight(text, lineHeight));\n  }, 0);\n}\n\nfunction setMaxHeight(lines, ellipsisMaxWidth, options, maxHeight, lineHeight) {\n  var textOverflow = options.textOverflow;\n\n  if (!isFinite(maxHeight) || 0 === Number(maxHeight) || \"none\" === textOverflow) {\n    return lines;\n  }\n\n  var result = lines.reduce(function (_ref2, l, index, arr) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n        lines = _ref3[0],\n        commonHeight = _ref3[1];\n\n    var height = calculateLineHeight(l, lineHeight);\n    commonHeight += height;\n\n    if (commonHeight < maxHeight) {\n      lines.push(l);\n    } else {\n      l.parts.forEach(function (item) {\n        removeTextSpan(item);\n      });\n\n      if (\"ellipsis\" === textOverflow) {\n        var prevLine = arr[index - 1];\n\n        if (prevLine) {\n          var text = prevLine.parts[prevLine.parts.length - 1];\n\n          if (!text.hasEllipsis) {\n            if (0 === ellipsisMaxWidth || text.endBox < ellipsisMaxWidth) {\n              setNewText(text, text.value.length, getEllipsisString(ellipsisMaxWidth, options));\n            } else {\n              setEllipsis(text, ellipsisMaxWidth, options);\n            }\n          }\n        }\n      }\n    }\n\n    return [lines, commonHeight];\n  }, [[], 0]);\n\n  if (\"hide\" === textOverflow && result[1] > maxHeight) {\n    result[0].forEach(function (l) {\n      l.parts.forEach(function (item) {\n        removeTextSpan(item);\n      });\n    });\n    return [];\n  }\n\n  return result[0];\n}\n\nfunction applyOverflowRules(element, texts, maxWidth, ellipsisMaxWidth, options) {\n  if (!texts) {\n    var textValue = element.textContent;\n    var text = {\n      value: textValue,\n      height: 0,\n      line: 0\n    };\n    element.textContent = \"\";\n    createTspans([text], element, \"tspan\");\n    texts = [text];\n  }\n\n  return texts.reduce(function (_ref4, text) {\n    var _ref5 = _slicedToArray(_ref4, 5),\n        lines = _ref5[0],\n        startBox = _ref5[1],\n        endBox = _ref5[2],\n        stop = _ref5[3],\n        lineNumber = _ref5[4];\n\n    var line = lines[lines.length - 1];\n\n    if (stop) {\n      return [lines, startBox, endBox, stop];\n    }\n\n    if (!line || text.line !== lineNumber) {\n      text.startBox = startBox = 0;\n      lines.push({\n        commonLength: text.value.length,\n        parts: [text]\n      });\n    } else {\n      text.startBox = startBox;\n\n      if (startBox > ellipsisMaxWidth && \"none\" === options.wordWrap && \"ellipsis\" === options.textOverflow) {\n        removeTextSpan(text);\n        return [lines, startBox, endBox, stop, lineNumber];\n      }\n\n      line.parts.push(text);\n      line.commonLength += text.value.length;\n    }\n\n    text.endBox = endBox = startBox + getTextWidth(text);\n    startBox = endBox;\n\n    if ((0, _type.isDefined)(maxWidth) && endBox > maxWidth) {\n      var wordWrapLines = wordWrap(text, maxWidth, ellipsisMaxWidth, options);\n\n      if (!wordWrapLines.length) {\n        lines = [];\n        stop = true;\n      } else {\n        lines = lines.concat(wordWrapLines.filter(function (l) {\n          return l.parts.length > 0;\n        }));\n      }\n    }\n\n    return [lines, startBox, endBox, stop, text.line];\n  }, [[], 0, 0, false, 0])[0];\n}\n\nfunction setNewText(text, index) {\n  var insertString = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ELLIPSIS;\n  var newText = text.value.substr(0, index) + insertString;\n  text.value = text.tspan.textContent = newText;\n  text.stroke && (text.stroke.textContent = newText);\n\n  if (insertString === ELLIPSIS) {\n    text.hasEllipsis = true;\n  }\n}\n\nfunction removeTextSpan(text) {\n  text.tspan.parentNode && text.tspan.parentNode.removeChild(text.tspan);\n  text.stroke && text.stroke.parentNode && text.stroke.parentNode.removeChild(text.stroke);\n}\n\nfunction createTextNodes(wrapper, text, isStroked) {\n  var items;\n  var parsedHtml;\n  wrapper._texts = null;\n  wrapper.clear();\n\n  if (null === text) {\n    return;\n  }\n\n  text = \"\" + text;\n\n  if (!wrapper.renderer.encodeHtml && (/<[a-z][\\s\\S]*>/i.test(text) || text.indexOf(\"&\") !== -1)) {\n    parsedHtml = removeExtraAttrs(text);\n    items = parseHTML(parsedHtml);\n  } else {\n    if (/\\n/g.test(text)) {\n      items = parseMultiline(text);\n    } else {\n      if (isStroked) {\n        items = [{\n          value: text.trim(),\n          height: 0\n        }];\n      }\n    }\n  }\n\n  if (items) {\n    if (items.length) {\n      wrapper._texts = items;\n\n      if (isStroked) {\n        createTspans(items, wrapper.element, KEY_STROKE);\n      }\n\n      createTspans(items, wrapper.element, \"tspan\");\n    }\n  } else {\n    wrapper.element.appendChild(_dom_adapter2.default.createTextNode(text));\n  }\n}\n\nfunction setTextNodeAttribute(item, name, value) {\n  item.tspan.setAttribute(name, value);\n  item.stroke && item.stroke.setAttribute(name, value);\n}\n\nfunction getItemLineHeight(item, defaultValue) {\n  return item.inherits ? maxLengthFontSize(item.height, defaultValue) : item.height || defaultValue;\n}\n\nfunction locateTextNodes(wrapper) {\n  if (!wrapper._texts) {\n    return;\n  }\n\n  var items = wrapper._texts;\n  var x = wrapper._settings.x;\n\n  var lineHeight = wrapper._getLineHeight();\n\n  var i;\n  var ii;\n  var item = items[0];\n  setTextNodeAttribute(item, \"x\", x);\n  setTextNodeAttribute(item, \"y\", wrapper._settings.y);\n\n  for (i = 1, ii = items.length; i < ii; ++i) {\n    item = items[i];\n\n    if (parseFloat(item.height) >= 0) {\n      setTextNodeAttribute(item, \"x\", x);\n      var height = getItemLineHeight(item, lineHeight);\n      setTextNodeAttribute(item, \"dy\", height);\n    }\n  }\n}\n\nfunction alignTextNodes(wrapper, alignment) {\n  if (!wrapper._texts || \"center\" === alignment) {\n    return;\n  }\n\n  var items = wrapper._texts;\n  var direction = \"left\" === alignment ? -1 : 1;\n  var maxTextWidth = Math.max.apply(Math, items.map(function (t) {\n    return getTextWidth(t);\n  }));\n\n  for (var i = 0; i < items.length; i++) {\n    var item = items[i];\n    var textWidth = getTextWidth(item);\n\n    if (0 !== maxTextWidth && maxTextWidth !== textWidth) {\n      setTextNodeAttribute(item, \"dx\", direction * round((maxTextWidth - textWidth) / 2 * 10) / 10);\n    }\n  }\n}\n\nfunction maxLengthFontSize(fontSize1, fontSize2) {\n  var parsedHeight1 = parseFloat(fontSize1);\n  var parsedHeight2 = parseFloat(fontSize2);\n  var height1 = parsedHeight1 || DEFAULT_FONT_SIZE;\n  var height2 = parsedHeight2 || DEFAULT_FONT_SIZE;\n  return height1 > height2 ? !isNaN(parsedHeight1) ? fontSize1 : height1 : !isNaN(parsedHeight2) ? fontSize2 : height2;\n}\n\nfunction strokeTextNodes(wrapper) {\n  if (!wrapper._texts) {\n    return;\n  }\n\n  var items = wrapper._texts;\n  var stroke = wrapper._settings[KEY_STROKE];\n  var strokeWidth = wrapper._settings[KEY_STROKE_WIDTH];\n  var strokeOpacity = wrapper._settings[KEY_STROKE_OPACITY] || 1;\n  var tspan;\n  var i;\n  var ii;\n\n  for (i = 0, ii = items.length; i < ii; ++i) {\n    tspan = items[i].stroke;\n    tspan.setAttribute(KEY_STROKE, stroke);\n    tspan.setAttribute(KEY_STROKE_WIDTH, strokeWidth);\n    tspan.setAttribute(KEY_STROKE_OPACITY, strokeOpacity);\n    tspan.setAttribute(\"stroke-linejoin\", \"round\");\n  }\n}\n\nfunction baseAnimate(that, params, options, complete) {\n  options = options || {};\n  var key;\n  var value;\n  var renderer = that.renderer;\n  var settings = that._settings;\n  var animationParams = {};\n  var defaults = {\n    translateX: 0,\n    translateY: 0,\n    scaleX: 1,\n    scaleY: 1,\n    rotate: 0,\n    rotateX: 0,\n    rotateY: 0\n  };\n\n  if (complete) {\n    options.complete = complete;\n  }\n\n  if (renderer.animationEnabled()) {\n    for (key in params) {\n      value = params[key];\n\n      if (/^(translate(X|Y)|rotate[XY]?|scale(X|Y))$/i.test(key)) {\n        animationParams.transform = animationParams.transform || {\n          from: {},\n          to: {}\n        };\n        animationParams.transform.from[key] = key in settings ? Number(settings[key].toFixed(3)) : defaults[key];\n        animationParams.transform.to[key] = value;\n      } else {\n        if (\"arc\" === key || \"segments\" === key) {\n          animationParams[key] = value;\n        } else {\n          animationParams[key] = {\n            from: key in settings ? settings[key] : parseFloat(that.element.getAttribute(key) || 0),\n            to: value\n          };\n        }\n      }\n    }\n\n    renderer.animateElement(that, animationParams, extend(extend({}, renderer._animation), options));\n  } else {\n    options.step && options.step.call(that, 1, 1);\n    options.complete && options.complete.call(that);\n    that.attr(params);\n  }\n\n  return that;\n}\n\nfunction pathAnimate(params, options, complete) {\n  var that = this;\n  var curSegments = that.segments || [];\n  var newSegments;\n  var endSegments;\n\n  if (that.renderer.animationEnabled() && \"points\" in params) {\n    newSegments = buildPathSegments(params.points, that.type);\n    endSegments = compensateSegments(curSegments, newSegments, that.type);\n    params.segments = {\n      from: curSegments,\n      to: newSegments,\n      end: endSegments\n    };\n    delete params.points;\n  }\n\n  return baseAnimate(that, params, options, complete);\n}\n\nfunction arcAnimate(params, options, complete) {\n  var that = this;\n  var settings = that._settings;\n  var arcParams = {\n    from: {},\n    to: {}\n  };\n\n  if (that.renderer.animationEnabled() && (\"x\" in params || \"y\" in params || \"innerRadius\" in params || \"outerRadius\" in params || \"startAngle\" in params || \"endAngle\" in params)) {\n    arcParams.from.x = settings.x || 0;\n    arcParams.from.y = settings.y || 0;\n    arcParams.from.innerRadius = settings.innerRadius || 0;\n    arcParams.from.outerRadius = settings.outerRadius || 0;\n    arcParams.from.startAngle = settings.startAngle || 0;\n    arcParams.from.endAngle = settings.endAngle || 0;\n    arcParams.to.x = \"x\" in params ? params.x : settings.x;\n    delete params.x;\n    arcParams.to.y = \"y\" in params ? params.y : settings.y;\n    delete params.y;\n    arcParams.to.innerRadius = \"innerRadius\" in params ? params.innerRadius : settings.innerRadius;\n    delete params.innerRadius;\n    arcParams.to.outerRadius = \"outerRadius\" in params ? params.outerRadius : settings.outerRadius;\n    delete params.outerRadius;\n    arcParams.to.startAngle = \"startAngle\" in params ? params.startAngle : settings.startAngle;\n    delete params.startAngle;\n    arcParams.to.endAngle = \"endAngle\" in params ? params.endAngle : settings.endAngle;\n    delete params.endAngle;\n    params.arc = arcParams;\n  }\n\n  return baseAnimate(that, params, options, complete);\n}\n\nfunction buildLink(target, parameters) {\n  var obj = {\n    is: false,\n    name: parameters.name || parameters,\n    after: parameters.after\n  };\n\n  if (target) {\n    obj.to = target;\n  } else {\n    obj.virtual = true;\n  }\n\n  return obj;\n}\n\nfunction SvgElement(renderer, tagName, type) {\n  var that = this;\n  that.renderer = renderer;\n  that.element = createElement(tagName);\n  that._settings = {};\n  that._styles = {};\n\n  if (\"path\" === tagName) {\n    that.type = type || \"line\";\n  }\n}\n\nfunction removeFuncIriCallback(callback) {\n  fixFuncIriCallbacks.remove(callback);\n}\n\nexports.SvgElement = SvgElement;\nSvgElement.prototype = {\n  constructor: SvgElement,\n  _getJQElement: function () {\n    return this._$element || (this._$element = (0, _renderer2.default)(this.element));\n  },\n  _addFixIRICallback: function () {\n    var that = this;\n\n    var fn = function () {\n      fixFuncIri(that, \"fill\");\n      fixFuncIri(that, \"clip-path\");\n      fixFuncIri(that, \"filter\");\n    };\n\n    that.element._fixFuncIri = fn;\n    fn.renderer = that.renderer;\n    fixFuncIriCallbacks.add(fn);\n\n    that._addFixIRICallback = function () {};\n  },\n  _clearChildrenFuncIri: function () {\n    var clearChildren = function clearChildren(element) {\n      var i;\n\n      for (i = 0; i < element.childNodes.length; i++) {\n        removeFuncIriCallback(element.childNodes[i]._fixFuncIri);\n        clearChildren(element.childNodes[i]);\n      }\n    };\n\n    clearChildren(this.element);\n  },\n  dispose: function () {\n    removeFuncIriCallback(this.element._fixFuncIri);\n\n    this._clearChildrenFuncIri();\n\n    this._getJQElement().remove();\n\n    return this;\n  },\n  append: function (parent) {\n    (parent || this.renderer.root).element.appendChild(this.element);\n    return this;\n  },\n  remove: function () {\n    var element = this.element;\n    element.parentNode && element.parentNode.removeChild(element);\n    return this;\n  },\n  enableLinks: function () {\n    this._links = [];\n    return this;\n  },\n  virtualLink: function (parameters) {\n    linkItem({\n      _link: buildLink(null, parameters)\n    }, this);\n    return this;\n  },\n  linkAfter: function (name) {\n    this._linkAfter = name;\n    return this;\n  },\n  linkOn: function (target, parameters) {\n    this._link = buildLink(target, parameters);\n    linkItem(this, target);\n    return this;\n  },\n  linkOff: function () {\n    unlinkItem(this);\n    this._link = null;\n    return this;\n  },\n  linkAppend: function () {\n    var link = this._link;\n    var items = link.to._links;\n    var i;\n    var next;\n\n    for (i = link.i + 1; (next = items[i]) && !next._link.is; ++i) {}\n\n    this._insert(link.to, next);\n\n    link.is = true;\n    return this;\n  },\n  _insert: function (parent, next) {\n    parent.element.insertBefore(this.element, next ? next.element : null);\n  },\n  linkRemove: function () {\n    this.remove();\n    this._link.is = false;\n    return this;\n  },\n  clear: function () {\n    this._clearChildrenFuncIri();\n\n    this._getJQElement().empty();\n\n    return this;\n  },\n  toBackground: function () {\n    var elem = this.element;\n    var parent = elem.parentNode;\n    parent && parent.insertBefore(elem, parent.firstChild);\n    return this;\n  },\n  toForeground: function () {\n    var elem = this.element;\n    var parent = elem.parentNode;\n    parent && parent.appendChild(elem);\n    return this;\n  },\n  attr: function (attrs) {\n    return baseAttr(this, attrs);\n  },\n  smartAttr: function (attrs) {\n    return this.attr(processHatchingAttrs(this, attrs));\n  },\n  css: function (styles) {\n    return baseCss(this, styles);\n  },\n  animate: function (params, options, complete) {\n    return baseAnimate(this, params, options, complete);\n  },\n  sharp: function (pos, sharpDirection) {\n    return this.attr({\n      sharp: pos || true,\n      sharpDirection: sharpDirection\n    });\n  },\n  _applyTransformation: function () {\n    var tr = this._settings;\n    var scaleXDefined;\n    var scaleYDefined;\n    var rotateX;\n    var rotateY;\n    var transformations = [];\n    var sharpMode = tr.sharp;\n    var trDirection = tr.sharpDirection || 1;\n    var strokeOdd = tr[KEY_STROKE_WIDTH] % 2;\n    var correctionX = strokeOdd && (\"h\" === sharpMode || true === sharpMode) ? SHARPING_CORRECTION * trDirection : 0;\n    var correctionY = strokeOdd && (\"v\" === sharpMode || true === sharpMode) ? SHARPING_CORRECTION * trDirection : 0;\n    transformations.push(\"translate(\" + ((tr.translateX || 0) + correctionX) + \",\" + ((tr.translateY || 0) + correctionY) + \")\");\n\n    if (tr.rotate) {\n      if (\"rotateX\" in tr) {\n        rotateX = tr.rotateX;\n      } else {\n        rotateX = tr.x;\n      }\n\n      if (\"rotateY\" in tr) {\n        rotateY = tr.rotateY;\n      } else {\n        rotateY = tr.y;\n      }\n\n      transformations.push(\"rotate(\" + tr.rotate + \",\" + (rotateX || 0) + \",\" + (rotateY || 0) + \")\");\n    }\n\n    scaleXDefined = (0, _type.isDefined)(tr.scaleX);\n    scaleYDefined = (0, _type.isDefined)(tr.scaleY);\n\n    if (scaleXDefined || scaleYDefined) {\n      transformations.push(\"scale(\" + (scaleXDefined ? tr.scaleX : 1) + \",\" + (scaleYDefined ? tr.scaleY : 1) + \")\");\n    }\n\n    if (transformations.length) {\n      this.element.setAttribute(\"transform\", transformations.join(\" \"));\n    }\n  },\n  move: function (x, y, animate, animOptions) {\n    var obj = {};\n    (0, _type.isDefined)(x) && (obj.translateX = x);\n    (0, _type.isDefined)(y) && (obj.translateY = y);\n\n    if (!animate) {\n      this.attr(obj);\n    } else {\n      this.animate(obj, animOptions);\n    }\n\n    return this;\n  },\n  rotate: function (angle, x, y, animate, animOptions) {\n    var obj = {\n      rotate: angle || 0\n    };\n    (0, _type.isDefined)(x) && (obj.rotateX = x);\n    (0, _type.isDefined)(y) && (obj.rotateY = y);\n\n    if (!animate) {\n      this.attr(obj);\n    } else {\n      this.animate(obj, animOptions);\n    }\n\n    return this;\n  },\n  _getElementBBox: function () {\n    var elem = this.element;\n    var bBox;\n\n    try {\n      bBox = elem.getBBox && elem.getBBox();\n    } catch (e) {}\n\n    return bBox || {\n      x: 0,\n      y: 0,\n      width: elem.offsetWidth || 0,\n      height: elem.offsetHeight || 0\n    };\n  },\n  getBBox: function () {\n    var transformation = this._settings;\n\n    var bBox = this._getElementBBox();\n\n    if (transformation.rotate) {\n      bBox = (0, _utils.rotateBBox)(bBox, [(\"rotateX\" in transformation ? transformation.rotateX : transformation.x) || 0, (\"rotateY\" in transformation ? transformation.rotateY : transformation.y) || 0], -transformation.rotate);\n    } else {\n      bBox = (0, _utils.normalizeBBox)(bBox);\n    }\n\n    return bBox;\n  },\n  markup: function () {\n    return (0, _svg.getSvgMarkup)(this.element);\n  },\n  getOffset: function () {\n    return this._getJQElement().offset();\n  },\n  stopAnimation: function (disableComplete) {\n    var animation = this.animation;\n    animation && animation.stop(disableComplete);\n    return this;\n  },\n  setTitle: function (text) {\n    var titleElem = createElement(\"title\");\n    titleElem.textContent = text || \"\";\n    this.element.appendChild(titleElem);\n  },\n  data: function (obj, val) {\n    var elem = this.element;\n    var key;\n\n    if (void 0 !== val) {\n      elem[obj] = val;\n    } else {\n      for (key in obj) {\n        elem[key] = obj[key];\n      }\n    }\n\n    return this;\n  },\n  on: function () {\n    var args = [this._getJQElement()];\n    args.push.apply(args, arguments);\n\n    _events_engine2.default.on.apply(_events_engine2.default, args);\n\n    return this;\n  },\n  off: function () {\n    var args = [this._getJQElement()];\n    args.push.apply(args, arguments);\n\n    _events_engine2.default.off.apply(_events_engine2.default, args);\n\n    return this;\n  },\n  trigger: function () {\n    var args = [this._getJQElement()];\n    args.push.apply(args, arguments);\n\n    _events_engine2.default.trigger.apply(_events_engine2.default, args);\n\n    return this;\n  }\n};\n\nfunction PathSvgElement(renderer, type) {\n  SvgElement.call(this, renderer, \"path\", type);\n}\n\nexports.PathSvgElement = PathSvgElement;\nPathSvgElement.prototype = objectCreate(SvgElement.prototype);\nextend(PathSvgElement.prototype, {\n  constructor: PathSvgElement,\n  attr: pathAttr,\n  animate: pathAnimate\n});\n\nfunction ArcSvgElement(renderer) {\n  SvgElement.call(this, renderer, \"path\", \"arc\");\n}\n\nexports.ArcSvgElement = ArcSvgElement;\nArcSvgElement.prototype = objectCreate(SvgElement.prototype);\nextend(ArcSvgElement.prototype, {\n  constructor: ArcSvgElement,\n  attr: arcAttr,\n  animate: arcAnimate\n});\n\nfunction RectSvgElement(renderer) {\n  SvgElement.call(this, renderer, \"rect\");\n}\n\nexports.RectSvgElement = RectSvgElement;\nRectSvgElement.prototype = objectCreate(SvgElement.prototype);\nextend(RectSvgElement.prototype, {\n  constructor: RectSvgElement,\n  attr: rectAttr\n});\n\nfunction TextSvgElement(renderer) {\n  SvgElement.call(this, renderer, \"text\");\n  this.css({\n    \"white-space\": \"pre\"\n  });\n}\n\nexports.TextSvgElement = TextSvgElement;\nTextSvgElement.prototype = objectCreate(SvgElement.prototype);\nextend(TextSvgElement.prototype, {\n  constructor: TextSvgElement,\n  attr: textAttr,\n  css: textCss,\n  applyEllipsis: applyEllipsis,\n  setMaxSize: setMaxSize,\n  restoreText: restoreText,\n  _getLineHeight: function () {\n    return !isNaN(parseFloat(this._styles[KEY_FONT_SIZE])) ? this._styles[KEY_FONT_SIZE] : DEFAULT_FONT_SIZE;\n  }\n});\n\nfunction updateIndexes(items, k) {\n  var i;\n  var item;\n\n  for (i = k; item = items[i]; ++i) {\n    item._link.i = i;\n  }\n}\n\nfunction linkItem(target, container) {\n  var items = container._links;\n  var key = target._link.after = target._link.after || container._linkAfter;\n  var i;\n  var item;\n\n  if (key) {\n    for (i = 0; (item = items[i]) && item._link.name !== key; ++i) {}\n\n    if (item) {\n      for (++i; (item = items[i]) && item._link.after === key; ++i) {}\n    }\n  } else {\n    i = items.length;\n  }\n\n  items.splice(i, 0, target);\n  updateIndexes(items, i);\n}\n\nfunction unlinkItem(target) {\n  var i;\n  var items = target._link.to._links;\n\n  for (i = 0; items[i] !== target; ++i) {}\n\n  items.splice(i, 1);\n  updateIndexes(items, i);\n}\n\nfunction Renderer(options) {\n  var that = this;\n  that.root = that._createElement(\"svg\", {\n    xmlns: \"http://www.w3.org/2000/svg\",\n    version: \"1.1\",\n    fill: NONE,\n    stroke: NONE,\n    \"stroke-width\": 0\n  }).attr({\n    \"class\": options.cssClass\n  }).css({\n    \"line-height\": \"normal\",\n    \"-ms-user-select\": NONE,\n    \"-moz-user-select\": NONE,\n    \"-webkit-user-select\": NONE,\n    \"-webkit-tap-highlight-color\": \"rgba(0, 0, 0, 0)\",\n    display: \"block\",\n    overflow: \"hidden\"\n  });\n\n  that._init();\n\n  that.pathModified = !!options.pathModified;\n  that._$container = (0, _renderer2.default)(options.container);\n  that.root.append({\n    element: options.container\n  });\n  that.fixPlacement();\n  that._locker = 0;\n  that._backed = false;\n}\n\nexports.Renderer = Renderer;\nRenderer.prototype = {\n  constructor: Renderer,\n  _init: function () {\n    var that = this;\n    that._defs = that._createElement(\"defs\").append(that.root);\n    that._animationController = new _animation2.default.AnimationController(that.root.element);\n    that._animation = {\n      enabled: true,\n      duration: 1e3,\n      easing: \"easeOutCubic\"\n    };\n  },\n  fixPlacement: function () {\n    if (!_browser2.default.mozilla && !_browser2.default.msie) {\n      return;\n    }\n\n    var box = getBoundingClientRect(this._$container.get(0));\n    var dx = roundValue(box.left % 1, 2);\n    var dy = roundValue(box.top % 1, 2);\n\n    if (_browser2.default.msie) {\n      this.root.css({\n        transform: \"translate(\" + -dx + \"px,\" + -dy + \"px)\"\n      });\n    } else {\n      if (_browser2.default.mozilla) {\n        this.root.move(-dx, -dy);\n      }\n    }\n  },\n  removePlacementFix: function () {\n    if (!_browser2.default.mozilla && !_browser2.default.msie) {\n      return;\n    }\n\n    if (_browser2.default.msie) {\n      this.root.css({\n        transform: \"\"\n      });\n    } else {\n      if (_browser2.default.mozilla) {\n        this.root.attr({\n          transform: null\n        });\n      }\n    }\n  },\n  setOptions: function (options) {\n    var that = this;\n    that.rtl = !!options.rtl;\n    that.encodeHtml = !!options.encodeHtml;\n    that.updateAnimationOptions(options.animation || {});\n    that.root.attr({\n      direction: that.rtl ? \"rtl\" : \"ltr\"\n    });\n    return that;\n  },\n  _createElement: function (tagName, attr, type) {\n    var elem = new exports.SvgElement(this, tagName, type);\n    attr && elem.attr(attr);\n    return elem;\n  },\n  lock: function () {\n    var that = this;\n\n    if (0 === that._locker) {\n      that._backed = !that._$container.is(\":visible\");\n\n      if (that._backed) {\n        backupRoot(that.root);\n      }\n    }\n\n    ++that._locker;\n    return that;\n  },\n  unlock: function () {\n    var that = this;\n    --that._locker;\n\n    if (0 === that._locker) {\n      if (that._backed) {\n        restoreRoot(that.root, that._$container[0]);\n        that.fixPlacement();\n      }\n\n      that._backed = false;\n    }\n\n    return that;\n  },\n  resize: function (width, height) {\n    if (width >= 0 && height >= 0) {\n      this.root.attr({\n        width: width,\n        height: height\n      });\n    }\n\n    return this;\n  },\n  dispose: function () {\n    var that = this;\n    var key;\n    that.root.dispose();\n\n    that._defs.dispose();\n\n    that._animationController.dispose();\n\n    fixFuncIriCallbacks.removeByRenderer(that);\n\n    for (key in that) {\n      that[key] = null;\n    }\n\n    return that;\n  },\n  animationEnabled: function () {\n    return !!this._animation.enabled;\n  },\n  updateAnimationOptions: function (newOptions) {\n    extend(this._animation, newOptions);\n    return this;\n  },\n  stopAllAnimations: function (lock) {\n    this._animationController[lock ? \"lock\" : \"stop\"]();\n\n    return this;\n  },\n  animateElement: function (element, params, options) {\n    this._animationController.animateElement(element, params, options);\n\n    return this;\n  },\n  svg: function () {\n    this.removePlacementFix();\n    var markup = this.root.markup();\n    this.fixPlacement();\n    return markup;\n  },\n  getRootOffset: function () {\n    return this.root.getOffset();\n  },\n  onEndAnimation: function (endAnimation) {\n    this._animationController.onEndAnimation(endAnimation);\n  },\n  rect: function (x, y, width, height) {\n    var elem = new exports.RectSvgElement(this);\n    return elem.attr({\n      x: x || 0,\n      y: y || 0,\n      width: width || 0,\n      height: height || 0\n    });\n  },\n  simpleRect: function () {\n    return this._createElement(\"rect\");\n  },\n  circle: function (x, y, r) {\n    return this._createElement(\"circle\", {\n      cx: x || 0,\n      cy: y || 0,\n      r: r || 0\n    });\n  },\n  g: function () {\n    return this._createElement(\"g\");\n  },\n  image: function image(x, y, w, h, href, location) {\n    var image = this._createElement(\"image\", {\n      x: x || 0,\n      y: y || 0,\n      width: w || 0,\n      height: h || 0,\n      preserveAspectRatio: preserveAspectRatioMap[(0, _utils.normalizeEnum)(location)] || NONE\n    });\n\n    image.element.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", href || \"\");\n    return image;\n  },\n  path: function (points, type) {\n    var elem = new exports.PathSvgElement(this, type);\n    return elem.attr({\n      points: points || []\n    });\n  },\n  arc: function (x, y, innerRadius, outerRadius, startAngle, endAngle) {\n    var elem = new exports.ArcSvgElement(this);\n    return elem.attr({\n      x: x || 0,\n      y: y || 0,\n      innerRadius: innerRadius || 0,\n      outerRadius: outerRadius || 0,\n      startAngle: startAngle || 0,\n      endAngle: endAngle || 0\n    });\n  },\n  text: function (_text, x, y) {\n    var elem = new exports.TextSvgElement(this);\n    return elem.attr({\n      text: _text,\n      x: x || 0,\n      y: y || 0\n    });\n  },\n  linearGradient: function (stops) {\n    var gradient;\n    var id = getNextDefsSvgId();\n    var that = this;\n    gradient = that._createElement(\"linearGradient\", {\n      id: id\n    }).append(that._defs);\n    gradient.id = id;\n    stops.forEach(function (stop) {\n      that._createElement(\"stop\", {\n        offset: stop.offset,\n        \"stop-color\": stop[\"stop-color\"]\n      }).append(gradient);\n    });\n    return gradient;\n  },\n  pattern: function pattern(color, hatching, _id) {\n    hatching = hatching || {};\n    var that = this;\n    var id;\n    var d;\n    var pattern;\n    var rect;\n    var path;\n    var step = hatching.step || 6;\n    var stepTo2 = step / 2;\n    var stepBy15 = 1.5 * step;\n    id = _id || getNextDefsSvgId();\n    d = \"right\" === (0, _utils.normalizeEnum)(hatching.direction) ? \"M \" + stepTo2 + \" \" + -stepTo2 + \" L \" + -stepTo2 + \" \" + stepTo2 + \" M 0 \" + step + \" L \" + step + \" 0 M \" + stepBy15 + \" \" + stepTo2 + \" L \" + stepTo2 + \" \" + stepBy15 : \"M 0 0 L \" + step + \" \" + step + \" M \" + -stepTo2 + \" \" + stepTo2 + \" L \" + stepTo2 + \" \" + stepBy15 + \" M \" + stepTo2 + \" \" + -stepTo2 + \" L \" + stepBy15 + \" \" + stepTo2;\n    pattern = that._createElement(\"pattern\", {\n      id: id,\n      width: step,\n      height: step,\n      patternUnits: \"userSpaceOnUse\"\n    }).append(that._defs);\n    pattern.id = id;\n    rect = that.rect(0, 0, step, step).attr({\n      fill: color,\n      opacity: hatching.opacity\n    }).append(pattern);\n    path = new exports.PathSvgElement(this).attr({\n      d: d,\n      \"stroke-width\": hatching.width || 1,\n      stroke: color\n    }).append(pattern);\n    return pattern;\n  },\n  _getPointsWithYOffset: function (points, offset) {\n    return points.map(function (point, index) {\n      if (index % 2 !== 0) {\n        return point + offset;\n      }\n\n      return point;\n    });\n  },\n  clipShape: function (method, methodArgs) {\n    var that = this;\n    var id = getNextDefsSvgId();\n\n    var clipPath = that._createElement(\"clipPath\", {\n      id: id\n    }).append(that._defs);\n\n    var shape = method.apply(that, methodArgs).append(clipPath);\n    shape.id = id;\n\n    shape.remove = function () {\n      throw \"Not implemented\";\n    };\n\n    shape.dispose = function () {\n      clipPath.dispose();\n      clipPath = null;\n      return this;\n    };\n\n    return shape;\n  },\n  clipRect: function (x, y, width, height) {\n    return this.clipShape(this.rect, arguments);\n  },\n  clipCircle: function (x, y, radius) {\n    return this.clipShape(this.circle, arguments);\n  },\n  shadowFilter: function (x, y, width, height, offsetX, offsetY, blur, color, opacity) {\n    var that = this;\n    var id = getNextDefsSvgId();\n\n    var filter = that._createElement(\"filter\", {\n      id: id,\n      x: x || 0,\n      y: y || 0,\n      width: width || 0,\n      height: height || 0\n    }).append(that._defs);\n\n    var gaussianBlur = that._createElement(\"feGaussianBlur\", {\n      \"in\": \"SourceGraphic\",\n      result: \"gaussianBlurResult\",\n      stdDeviation: blur || 0\n    }).append(filter);\n\n    var offset = that._createElement(\"feOffset\", {\n      \"in\": \"gaussianBlurResult\",\n      result: \"offsetResult\",\n      dx: offsetX || 0,\n      dy: offsetY || 0\n    }).append(filter);\n\n    var flood = that._createElement(\"feFlood\", {\n      result: \"floodResult\",\n      \"flood-color\": color || \"\",\n      \"flood-opacity\": opacity\n    }).append(filter);\n\n    var composite = that._createElement(\"feComposite\", {\n      \"in\": \"floodResult\",\n      in2: \"offsetResult\",\n      operator: \"in\",\n      result: \"compositeResult\"\n    }).append(filter);\n\n    var finalComposite = that._createElement(\"feComposite\", {\n      \"in\": \"SourceGraphic\",\n      in2: \"compositeResult\",\n      operator: \"over\"\n    }).append(filter);\n\n    filter.id = id;\n    filter.gaussianBlur = gaussianBlur;\n    filter.offset = offset;\n    filter.flood = flood;\n    filter.composite = composite;\n    filter.finalComposite = finalComposite;\n\n    filter.attr = function (attrs) {\n      var that = this;\n      var filterAttrs = {};\n      var offsetAttrs = {};\n      var floodAttrs = {};\n      \"x\" in attrs && (filterAttrs.x = attrs.x);\n      \"y\" in attrs && (filterAttrs.y = attrs.y);\n      \"width\" in attrs && (filterAttrs.width = attrs.width);\n      \"height\" in attrs && (filterAttrs.height = attrs.height);\n      baseAttr(that, filterAttrs);\n      \"blur\" in attrs && that.gaussianBlur.attr({\n        stdDeviation: attrs.blur\n      });\n      \"offsetX\" in attrs && (offsetAttrs.dx = attrs.offsetX);\n      \"offsetY\" in attrs && (offsetAttrs.dy = attrs.offsetY);\n      that.offset.attr(offsetAttrs);\n      \"color\" in attrs && (floodAttrs[\"flood-color\"] = attrs.color);\n      \"opacity\" in attrs && (floodAttrs[\"flood-opacity\"] = attrs.opacity);\n      that.flood.attr(floodAttrs);\n      return that;\n    };\n\n    return filter;\n  },\n  brightFilter: function (type, slope) {\n    var that = this;\n    var id = getNextDefsSvgId();\n\n    var filter = that._createElement(\"filter\", {\n      id: id\n    }).append(that._defs);\n\n    var componentTransferElement = that._createElement(\"feComponentTransfer\").append(filter);\n\n    var attrs = {\n      type: type,\n      slope: slope\n    };\n    filter.id = id;\n\n    that._createElement(\"feFuncR\", attrs).append(componentTransferElement);\n\n    that._createElement(\"feFuncG\", attrs).append(componentTransferElement);\n\n    that._createElement(\"feFuncB\", attrs).append(componentTransferElement);\n\n    return filter;\n  },\n  getGrayScaleFilter: function () {\n    if (this._grayScaleFilter) {\n      return this._grayScaleFilter;\n    }\n\n    var that = this;\n    var id = getNextDefsSvgId();\n\n    var filter = that._createElement(\"filter\", {\n      id: id\n    }).append(that._defs);\n\n    that._createElement(\"feColorMatrix\").attr({\n      type: \"matrix\",\n      values: \"0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 0.6 0\"\n    }).append(filter);\n\n    filter.id = id;\n    that._grayScaleFilter = filter;\n    return filter;\n  },\n  initHatching: function () {\n    var storage = this._hatchingStorage = this._hatchingStorage || {\n      byHash: {},\n      baseId: getNextDefsSvgId()\n    };\n    var byHash = storage.byHash;\n    var name;\n\n    for (name in byHash) {\n      byHash[name].pattern.dispose();\n    }\n\n    storage.byHash = {};\n    storage.refToHash = {};\n    storage.nextId = 0;\n  },\n  lockHatching: function (color, hatching, ref) {\n    var storage = this._hatchingStorage;\n    var hash = getHatchingHash(color, hatching);\n    var storageItem;\n    var pattern;\n\n    if (storage.refToHash[ref] !== hash) {\n      if (ref) {\n        this.releaseHatching(ref);\n      }\n\n      storageItem = storage.byHash[hash];\n\n      if (!storageItem) {\n        pattern = this.pattern(color, hatching, storage.baseId + \"-hatching-\" + storage.nextId++);\n        storageItem = storage.byHash[hash] = {\n          pattern: pattern,\n          count: 0\n        };\n        storage.refToHash[pattern.id] = hash;\n      }\n\n      ++storageItem.count;\n      ref = storageItem.pattern.id;\n    }\n\n    return ref;\n  },\n  releaseHatching: function (ref) {\n    var storage = this._hatchingStorage;\n    var hash = storage.refToHash[ref];\n    var storageItem = storage.byHash[hash];\n\n    if (storageItem && 0 === --storageItem.count) {\n      storageItem.pattern.dispose();\n      delete storage.byHash[hash];\n      delete storage.refToHash[ref];\n    }\n  }\n};\n\nfunction getHatchingHash(color, hatching) {\n  return \"@\" + color + \"::\" + hatching.step + \":\" + hatching.width + \":\" + hatching.opacity + \":\" + hatching.direction;\n}\n\nvar fixFuncIriCallbacks = function () {\n  var callbacks = [];\n  return {\n    add: function (fn) {\n      callbacks.push(fn);\n    },\n    remove: function (fn) {\n      callbacks = callbacks.filter(function (el) {\n        return el !== fn;\n      });\n    },\n    removeByRenderer: function (renderer) {\n      callbacks = callbacks.filter(function (el) {\n        return el.renderer !== renderer;\n      });\n    },\n    fire: function () {\n      callbacks.forEach(function (fn) {\n        fn();\n      });\n    }\n  };\n}();\n\nexports.refreshPaths = function () {\n  fixFuncIriCallbacks.fire();\n};","map":null,"metadata":{},"sourceType":"script"}