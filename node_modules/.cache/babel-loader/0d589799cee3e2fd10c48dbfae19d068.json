{"ast":null,"code":"/**\r\n * DevExtreme (viz/core/tooltip.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _dom_adapter = require(\"../../core/dom_adapter\");\n\nvar _dom_adapter2 = _interopRequireDefault(_dom_adapter);\n\nvar _window = require(\"../../core/utils/window\");\n\nvar _window2 = _interopRequireDefault(_window);\n\nvar _inflector = require(\"../../core/utils/inflector\");\n\nvar _inflector2 = _interopRequireDefault(_inflector);\n\nvar _renderer = require(\"../../core/renderer\");\n\nvar _renderer2 = _interopRequireDefault(_renderer);\n\nvar _renderer3 = require(\"./renderers/renderer\");\n\nvar _renderer4 = _interopRequireDefault(_renderer3);\n\nvar _type = require(\"../../core/utils/type\");\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _extend = require(\"../../core/utils/extend\");\n\nvar _utils = require(\"./utils\");\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _format_helper = require(\"../../format_helper\");\n\nvar _plaque = require(\"./plaque\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar mathCeil = Math.ceil;\nvar mathMax = Math.max;\nvar mathMin = Math.min;\n\nvar window = _window2.default.getWindow();\n\nvar DEFAULT_HTML_GROUP_WIDTH = 3e3;\n\nfunction hideElement($element) {\n  $element.css({\n    left: \"-9999px\"\n  }).detach();\n}\n\nfunction getSpecialFormatOptions(options, specialFormat) {\n  var result = options;\n\n  switch (specialFormat) {\n    case \"argument\":\n      result = {\n        format: options.argumentFormat\n      };\n      break;\n\n    case \"percent\":\n      result = {\n        format: {\n          type: \"percent\",\n          precision: options.format && options.format.percentPrecision\n        }\n      };\n  }\n\n  return result;\n}\n\nfunction Tooltip(params) {\n  var that = this;\n  var renderer;\n  var root;\n  that._eventTrigger = params.eventTrigger;\n  that._widgetRoot = params.widgetRoot;\n  that._widget = params.widget;\n  that._wrapper = (0, _renderer2.default)(\"<div>\").css({\n    position: \"absolute\",\n    overflow: \"hidden\",\n    pointerEvents: \"none\"\n  }).addClass(params.cssClass);\n  that._renderer = renderer = new _renderer4.default.Renderer({\n    pathModified: params.pathModified,\n    container: that._wrapper[0]\n  });\n  root = renderer.root;\n  root.attr({\n    \"pointer-events\": \"none\"\n  });\n  that._text = renderer.text(void 0, 0, 0);\n  that._textGroupHtml = (0, _renderer2.default)(\"<div>\").css({\n    position: \"absolute\",\n    padding: 0,\n    margin: 0,\n    border: \"0px solid transparent\"\n  }).appendTo(that._wrapper);\n  that._textHtml = (0, _renderer2.default)(\"<div>\").css({\n    position: \"relative\",\n    display: \"inline-block\",\n    padding: 0,\n    margin: 0,\n    border: \"0px solid transparent\"\n  }).appendTo(that._textGroupHtml);\n}\n\nTooltip.prototype = {\n  constructor: Tooltip,\n  dispose: function () {\n    this._wrapper.remove();\n\n    this._renderer.dispose();\n\n    this._options = this._widgetRoot = null;\n  },\n  _getContainer: function () {\n    var options = this._options;\n    var container = (0, _renderer2.default)(this._widgetRoot).closest(options.container);\n\n    if (0 === container.length) {\n      container = (0, _renderer2.default)(options.container);\n    }\n\n    return (container.length ? container : (0, _renderer2.default)(\"body\")).get(0);\n  },\n  setTemplate: function (contentTemplate) {\n    var that = this;\n    that._template = contentTemplate ? that._widget._getTemplate(contentTemplate) : null;\n  },\n  setOptions: function (options) {\n    var _this = this;\n\n    options = options || {};\n    var that = this;\n    that._options = options;\n    that._textFontStyles = _utils2.default.patchFontOptions(options.font);\n    that._textFontStyles.color = options.font.color;\n\n    that._wrapper.css({\n      zIndex: options.zIndex\n    });\n\n    that._customizeTooltip = options.customizeTooltip;\n    var textGroupHtml = that._textGroupHtml;\n    var textHtml = that._textHtml;\n\n    if (this.plaque) {\n      this.plaque.clear();\n    }\n\n    this.setTemplate(options.contentTemplate);\n\n    var drawTooltip = function (tooltip, group) {\n      var state = tooltip._state;\n      var template = tooltip._template;\n      var useTemplate = template && !state.formatObject.skipTemplate;\n\n      if (state.html || useTemplate) {\n        if (!state.isRendered) {\n          if (useTemplate) {\n            template.render({\n              model: state.formatObject,\n              container: textHtml\n            });\n            state.html = textHtml.html();\n\n            if (!state.html) {\n              _this.plaque.clear();\n\n              return;\n            }\n          } else {\n            that._text.attr({\n              text: \"\"\n            });\n\n            textHtml.html(state.html);\n          }\n\n          textGroupHtml.css({\n            color: state.textColor,\n            width: DEFAULT_HTML_GROUP_WIDTH\n          });\n          state.isRendered = true;\n        }\n      } else {\n        that._text.css({\n          fill: state.textColor\n        }).attr({\n          text: state.text,\n          \"class\": options.cssClass\n        }).append(group.attr({\n          align: options.textAlignment\n        }));\n      }\n\n      tooltip.plaque.customizeCloud({\n        fill: state.color,\n        stroke: state.borderColor\n      });\n    };\n\n    this.plaque = new _plaque.Plaque({\n      opacity: that._options.opacity,\n      color: that._options.color,\n      border: that._options.border,\n      paddingLeftRight: that._options.paddingLeftRight,\n      paddingTopBottom: that._options.paddingTopBottom,\n      arrowLength: that._options.arrowLength,\n      arrowWidth: 20,\n      shadow: that._options.shadow,\n      cornerRadius: that._options.cornerRadius\n    }, that, that._renderer.root, drawTooltip, true, function (tooltip, g) {\n      var state = tooltip._state;\n\n      if (state.html) {\n        var bBox;\n        var getComputedStyle = window.getComputedStyle;\n\n        if (getComputedStyle) {\n          bBox = getComputedStyle(textHtml.get(0));\n          bBox = {\n            x: 0,\n            y: 0,\n            width: mathCeil(parseFloat(bBox.width)),\n            height: mathCeil(parseFloat(bBox.height))\n          };\n        } else {\n          bBox = textHtml.get(0).getBoundingClientRect();\n          bBox = {\n            x: 0,\n            y: 0,\n            width: mathCeil(bBox.width ? bBox.width : bBox.right - bBox.left),\n            height: mathCeil(bBox.height ? bBox.height : bBox.bottom - bBox.top)\n          };\n        }\n\n        return bBox;\n      }\n\n      return g.getBBox();\n    }, function (tooltip, g, x, y) {\n      var state = tooltip._state;\n\n      if (state.html) {\n        that._textGroupHtml.css({\n          left: x,\n          top: y\n        });\n      } else {\n        g.move(x, y);\n      }\n    });\n    return that;\n  },\n  setRendererOptions: function (options) {\n    this._renderer.setOptions(options);\n\n    this._textGroupHtml.css({\n      direction: options.rtl ? \"rtl\" : \"ltr\"\n    });\n\n    return this;\n  },\n  render: function () {\n    var that = this;\n    hideElement(that._wrapper);\n    var normalizedCSS = {};\n\n    for (var name in that._textFontStyles) {\n      normalizedCSS[_inflector2.default.camelize(name)] = that._textFontStyles[name];\n    }\n\n    that._textGroupHtml.css(normalizedCSS);\n\n    that._text.css(that._textFontStyles);\n\n    that._eventData = null;\n    return that;\n  },\n  update: function (options) {\n    return this.setOptions(options).render();\n  },\n  _prepare: function (formatObject, state) {\n    var customizeTooltip = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this._customizeTooltip;\n    var options = this._options;\n    var customize = {};\n\n    if (_type2.default.isFunction(customizeTooltip)) {\n      customize = customizeTooltip.call(formatObject, formatObject);\n      customize = _type2.default.isPlainObject(customize) ? customize : {};\n\n      if (\"text\" in customize) {\n        state.text = _type2.default.isDefined(customize.text) ? String(customize.text) : \"\";\n      }\n\n      if (\"html\" in customize) {\n        state.html = _type2.default.isDefined(customize.html) ? String(customize.html) : \"\";\n      }\n    }\n\n    if (!(\"text\" in state) && !(\"html\" in state)) {\n      state.text = formatObject.valueText || formatObject.description || \"\";\n    }\n\n    state.color = customize.color || options.color;\n    state.borderColor = customize.borderColor || (options.border || {}).color;\n    state.textColor = customize.fontColor || (options.font || {}).color;\n    return !!state.text || !!state.html || !!this._template;\n  },\n  show: function (formatObject, params, eventData, customizeTooltip) {\n    var that = this;\n    var state = {\n      formatObject: formatObject\n    };\n\n    if (!that._prepare(formatObject, state, customizeTooltip)) {\n      return false;\n    }\n\n    that._state = state;\n\n    that._wrapper.appendTo(that._getContainer());\n\n    that._clear();\n\n    this.plaque.clear().draw((0, _extend.extend)({}, that._options, {\n      canvas: that._getCanvas()\n    }, state, {\n      x: params.x,\n      y: params.y,\n      offset: params.offset\n    }));\n    that.moveWrapper();\n    that._eventData && that._eventTrigger(\"tooltipHidden\", that._eventData);\n    that._eventData = eventData;\n\n    that._eventTrigger(\"tooltipShown\", that._eventData);\n\n    return true;\n  },\n  hide: function () {\n    var that = this;\n    hideElement(that._wrapper);\n\n    if (that._eventData) {\n      that._eventTrigger(\"tooltipHidden\", that._eventData);\n\n      that._clear();\n\n      that._eventData = null;\n    }\n  },\n  _clear: function () {\n    this._textHtml.empty();\n  },\n  move: function (x, y, offset) {\n    this.plaque.draw({\n      x: x,\n      y: y,\n      offset: offset,\n      canvas: this._getCanvas()\n    });\n    this.moveWrapper();\n  },\n  moveWrapper: function () {\n    var that = this;\n    var plaqueBBox = this.plaque.getBBox();\n\n    that._renderer.resize(plaqueBBox.width, plaqueBBox.height);\n\n    var offset = that._wrapper.css({\n      left: 0,\n      top: 0\n    }).offset();\n\n    var left = plaqueBBox.x;\n    var top = plaqueBBox.y;\n\n    that._wrapper.css({\n      left: left - offset.left,\n      top: top - offset.top\n    });\n\n    this.plaque.moveRoot(-left, -top);\n\n    if (this._state.html) {\n      that._textHtml.css({\n        left: -left,\n        top: -top\n      });\n\n      that._textGroupHtml.css({\n        width: plaqueBBox.width\n      });\n    }\n  },\n  formatValue: function (value, _specialFormat) {\n    var options = _specialFormat ? getSpecialFormatOptions(this._options, _specialFormat) : this._options;\n    return (0, _format_helper.format)(value, options.format);\n  },\n  getLocation: function () {\n    return _utils2.default.normalizeEnum(this._options.location);\n  },\n  isEnabled: function () {\n    return !!this._options.enabled;\n  },\n  isShared: function () {\n    return !!this._options.shared;\n  },\n  _getCanvas: function () {\n    var container = this._getContainer();\n\n    var containerBox = container.getBoundingClientRect();\n\n    var html = _dom_adapter2.default.getDocumentElement();\n\n    var document = _dom_adapter2.default.getDocument();\n\n    var left = window.pageXOffset || html.scrollLeft || 0;\n    var top = window.pageYOffset || html.scrollTop || 0;\n    var box = {\n      left: left,\n      top: top,\n      width: html.clientWidth + left || 0,\n      height: mathMax(document.body.scrollHeight, html.scrollHeight, document.body.offsetHeight, html.offsetHeight, document.body.clientHeight, html.clientHeight) || 0,\n      right: 0,\n      bottom: 0\n    };\n\n    if (container !== _dom_adapter2.default.getBody()) {\n      left = mathMax(box.left, box.left + containerBox.left);\n      top = mathMax(box.top, box.top + containerBox.top);\n      box.width = mathMin(containerBox.width, box.width) + left + box.left;\n      box.height = mathMin(containerBox.height, box.height) + top + box.top;\n      box.left = left;\n      box.top = top;\n    }\n\n    return box;\n  }\n};\nexports.Tooltip = Tooltip;\nexports.plugin = {\n  name: \"tooltip\",\n  init: function () {\n    this._initTooltip();\n  },\n  dispose: function () {\n    this._disposeTooltip();\n  },\n  members: {\n    _initTooltip: function () {\n      this._tooltip = new exports.Tooltip({\n        cssClass: this._rootClassPrefix + \"-tooltip\",\n        eventTrigger: this._eventTrigger,\n        pathModified: this.option(\"pathModified\"),\n        widgetRoot: this.element(),\n        widget: this\n      });\n    },\n    _disposeTooltip: function () {\n      this._tooltip.dispose();\n\n      this._tooltip = null;\n    },\n    _setTooltipRendererOptions: function () {\n      this._tooltip.setRendererOptions(this._getRendererOptions());\n    },\n    _setTooltipOptions: function () {\n      this._tooltip.update(this._getOption(\"tooltip\"));\n    }\n  },\n  extenders: {\n    _stopCurrentHandling: function () {\n      this._tooltip && this._tooltip.hide();\n    }\n  },\n  customize: function (constructor) {\n    var proto = constructor.prototype;\n    proto._eventsMap.onTooltipShown = {\n      name: \"tooltipShown\"\n    };\n    proto._eventsMap.onTooltipHidden = {\n      name: \"tooltipHidden\"\n    };\n    constructor.addChange({\n      code: \"TOOLTIP_RENDERER\",\n      handler: function () {\n        this._setTooltipRendererOptions();\n      },\n      isThemeDependent: true,\n      isOptionChange: true\n    });\n    constructor.addChange({\n      code: \"TOOLTIP\",\n      handler: function () {\n        this._setTooltipOptions();\n      },\n      isThemeDependent: true,\n      isOptionChange: true,\n      option: \"tooltip\"\n    });\n  },\n  fontFields: [\"tooltip.font\"]\n};","map":null,"metadata":{},"sourceType":"script"}