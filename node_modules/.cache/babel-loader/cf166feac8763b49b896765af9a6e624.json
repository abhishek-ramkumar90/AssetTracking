{"ast":null,"code":"/**\r\n * DevExtreme (viz/components/chart_theme_manager.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar noop = require(\"../../core/utils/common\").noop;\n\nvar typeUtils = require(\"../../core/utils/type\");\n\nvar extend = require(\"../../core/utils/extend\").extend;\n\nvar BaseThemeManager = require(\"../core/base_theme_manager\").BaseThemeManager;\n\nvar _isString = typeUtils.isString;\nvar _isDefined = typeUtils.isDefined;\n\nvar _normalizeEnum = require(\"../core/utils\").normalizeEnum;\n\nvar ThemeManager = BaseThemeManager.inherit(function () {\n  var ctor = function (params) {\n    var that = this;\n    that.callBase.apply(that, arguments);\n    var options = params.options || {};\n    that._userOptions = options;\n    that._mergeAxisTitleOptions = [];\n    that._multiPieColors = {};\n    that._callback = noop;\n  };\n\n  var dispose = function () {\n    var that = this;\n    that.palette && that.palette.dispose();\n    that.palette = that._userOptions = that._mergedSettings = that._multiPieColors = null;\n    return that.callBase.apply(that, arguments);\n  };\n\n  var resetPalette = function () {\n    this.palette.reset();\n    this._multiPieColors = {};\n  };\n\n  var processTitleOptions = function (options) {\n    return _isString(options) ? {\n      text: options\n    } : options;\n  };\n\n  var processAxisOptions = function (axisOptions) {\n    if (!axisOptions) {\n      return {};\n    }\n\n    axisOptions = extend(true, {}, axisOptions);\n    axisOptions.title = processTitleOptions(axisOptions.title);\n\n    if (\"logarithmic\" === axisOptions.type && axisOptions.logarithmBase <= 0 || axisOptions.logarithmBase && !typeUtils.isNumeric(axisOptions.logarithmBase)) {\n      axisOptions.logarithmBase = void 0;\n      axisOptions.logarithmBaseError = true;\n    }\n\n    if (axisOptions.label) {\n      if (axisOptions.label.alignment) {\n        axisOptions.label.userAlignment = true;\n      }\n    }\n\n    return axisOptions;\n  };\n\n  var applyParticularAxisOptions = function (name, userOptions, rotated) {\n    var theme = this._theme;\n    var position = !(rotated ^ \"valueAxis\" === name) ? \"horizontalAxis\" : \"verticalAxis\";\n    var processedUserOptions = processAxisOptions(userOptions, name);\n    var commonAxisSettings = processAxisOptions(this._userOptions.commonAxisSettings, name);\n    var mergeOptions = extend(true, {}, theme.commonAxisSettings, theme[position], theme[name], commonAxisSettings, processedUserOptions);\n    mergeOptions.workWeek = processedUserOptions.workWeek || theme[name].workWeek;\n    mergeOptions.forceUserTickInterval |= _isDefined(processedUserOptions.tickInterval) && !_isDefined(processedUserOptions.axisDivisionFactor);\n    return mergeOptions;\n  };\n\n  var mergeOptions = function (name, userOptions) {\n    userOptions = userOptions || this._userOptions[name];\n    var theme = this._theme[name];\n    var result = this._mergedSettings[name];\n\n    if (result) {\n      return result;\n    }\n\n    if (typeUtils.isPlainObject(theme) && typeUtils.isPlainObject(userOptions)) {\n      result = extend(true, {}, theme, userOptions);\n    } else {\n      result = _isDefined(userOptions) ? userOptions : theme;\n    }\n\n    this._mergedSettings[name] = result;\n    return result;\n  };\n\n  var applyParticularTheme = {\n    base: mergeOptions,\n    argumentAxis: applyParticularAxisOptions,\n    valueAxisRangeSelector: function () {\n      return mergeOptions.call(this, \"valueAxis\");\n    },\n    valueAxis: applyParticularAxisOptions,\n    series: function (name, userOptions, seriesCount) {\n      var that = this;\n      var theme = that._theme;\n      var userCommonSettings = that._userOptions.commonSeriesSettings || {};\n      var themeCommonSettings = theme.commonSeriesSettings;\n\n      var widgetType = that._themeSection.split(\".\").slice(-1)[0];\n\n      var type = _normalizeEnum(userOptions.type || userCommonSettings.type || themeCommonSettings.type || \"pie\" === widgetType && theme.type);\n\n      var settings;\n      var palette = that.palette;\n      var isBar = ~type.indexOf(\"bar\");\n      var isLine = ~type.indexOf(\"line\");\n      var isArea = ~type.indexOf(\"area\");\n      var isBubble = \"bubble\" === type;\n      var mainSeriesColor;\n      var resolveLabelsOverlapping = that.getOptions(\"resolveLabelsOverlapping\");\n      var containerBackgroundColor = that.getOptions(\"containerBackgroundColor\");\n      var seriesTemplate = applyParticularTheme.seriesTemplate.call(this);\n      var seriesVisibility;\n\n      if (isBar || isBubble) {\n        userOptions = extend(true, {}, userCommonSettings, userCommonSettings[type], userOptions);\n        seriesVisibility = userOptions.visible;\n        userCommonSettings = {\n          type: {}\n        };\n        extend(true, userOptions, userOptions.point);\n        userOptions.visible = seriesVisibility;\n      }\n\n      settings = extend(true, {\n        aggregation: {}\n      }, themeCommonSettings, themeCommonSettings[type], userCommonSettings, userCommonSettings[type], userOptions);\n      settings.aggregation.enabled = \"chart\" === widgetType && normalizeAggregationEnabled(settings.aggregation, that.getOptions(\"useAggregation\"));\n      settings.type = type;\n      settings.widgetType = widgetType;\n      settings.containerBackgroundColor = containerBackgroundColor;\n\n      if (\"pie\" !== widgetType) {\n        mainSeriesColor = settings.color || palette.getNextColor(seriesCount);\n      } else {\n        mainSeriesColor = function (argument, index, count) {\n          var cat = \"\".concat(argument, \"-\").concat(index);\n\n          if (!that._multiPieColors[cat]) {\n            that._multiPieColors[cat] = palette.getNextColor(count);\n          }\n\n          return that._multiPieColors[cat];\n        };\n      }\n\n      settings.mainSeriesColor = mainSeriesColor;\n      settings.resolveLabelsOverlapping = resolveLabelsOverlapping;\n\n      if (settings.label && (isLine || isArea && \"rangearea\" !== type || \"scatter\" === type)) {\n        settings.label.position = \"outside\";\n      }\n\n      if (seriesTemplate) {\n        settings.nameField = seriesTemplate.nameField;\n      }\n\n      return settings;\n    },\n    animation: function (name) {\n      var userOptions = this._userOptions[name];\n      userOptions = typeUtils.isPlainObject(userOptions) ? userOptions : _isDefined(userOptions) ? {\n        enabled: !!userOptions\n      } : {};\n      return mergeOptions.call(this, name, userOptions);\n    },\n    seriesTemplate: function () {\n      var value = mergeOptions.call(this, \"seriesTemplate\");\n\n      if (value) {\n        value.nameField = value.nameField || \"series\";\n      }\n\n      return value;\n    },\n    zoomAndPan: function () {\n      function parseOption(option) {\n        option = _normalizeEnum(option);\n        var pan = \"pan\" === option || \"both\" === option;\n        var zoom = \"zoom\" === option || \"both\" === option;\n        return {\n          pan: pan,\n          zoom: zoom,\n          none: !pan && !zoom\n        };\n      }\n\n      var userOptions = this._userOptions.zoomAndPan;\n\n      if (!_isDefined(userOptions)) {\n        var zoomingMode = _normalizeEnum(this.getOptions(\"zoomingMode\"));\n\n        var scrollingMode = _normalizeEnum(this.getOptions(\"scrollingMode\"));\n\n        var allowZoom = [\"all\", \"mouse\", \"touch\"].indexOf(zoomingMode) !== -1;\n        var allowScroll = [\"all\", \"mouse\", \"touch\"].indexOf(scrollingMode) !== -1;\n        userOptions = {\n          argumentAxis: allowZoom && allowScroll ? \"both\" : allowZoom ? \"zoom\" : allowScroll ? \"pan\" : \"none\",\n          allowMouseWheel: \"all\" === zoomingMode || \"mouse\" === zoomingMode,\n          allowTouchGestures: \"all\" === zoomingMode || \"touch\" === zoomingMode || \"all\" === scrollingMode || \"touch\" === scrollingMode\n        };\n      }\n\n      var options = mergeOptions.call(this, \"zoomAndPan\", userOptions);\n      return {\n        valueAxis: parseOption(options.valueAxis),\n        argumentAxis: parseOption(options.argumentAxis),\n        dragToZoom: !!options.dragToZoom,\n        dragBoxStyle: {\n          \"class\": \"dxc-shutter\",\n          fill: options.dragBoxStyle.color,\n          opacity: options.dragBoxStyle.opacity\n        },\n        panKey: options.panKey,\n        allowMouseWheel: !!options.allowMouseWheel,\n        allowTouchGestures: !!options.allowTouchGestures\n      };\n    }\n  };\n\n  var normalizeAggregationEnabled = function (aggregation, useAggregation) {\n    return !!(!_isDefined(aggregation.enabled) ? useAggregation : aggregation.enabled);\n  };\n\n  return {\n    _themeSection: \"chart\",\n    ctor: ctor,\n    dispose: dispose,\n    resetPalette: resetPalette,\n    getOptions: function (name) {\n      return (applyParticularTheme[name] || applyParticularTheme.base).apply(this, arguments);\n    },\n    refresh: function () {\n      this._mergedSettings = {};\n      return this.callBase.apply(this, arguments);\n    },\n    _initializeTheme: function () {\n      var that = this;\n      that.callBase.apply(that, arguments);\n      that.updatePalette();\n    },\n    resetOptions: function (name) {\n      this._mergedSettings[name] = null;\n    },\n    update: function (options) {\n      this._userOptions = options;\n    },\n    updatePalette: function () {\n      var that = this;\n      that.palette = that.createPalette(that.getOptions(\"palette\"), {\n        useHighlight: true,\n        extensionMode: that.getOptions(\"paletteExtensionMode\")\n      });\n    }\n  };\n}());\nexports.ThemeManager = ThemeManager;","map":null,"metadata":{},"sourceType":"script"}