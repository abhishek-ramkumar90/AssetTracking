{"ast":null,"code":"/**\r\n * DevExtreme (viz/chart_components/layout_manager.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar extend = require(\"../../core/utils/extend\").extend;\n\nvar layoutElementModule = require(\"../core/layout_element\");\n\nvar _isNumber = require(\"../../core/utils/type\").isNumeric;\n\nvar _min = Math.min;\nvar _max = Math.max;\nvar _floor = Math.floor;\nvar _sqrt = Math.sqrt;\n\nvar consts = require(\"../components/consts\");\n\nvar RADIAL_LABEL_INDENT = consts.radialLabelIndent;\n\nfunction getNearestCoord(firstCoord, secondCoord, pointCenterCoord) {\n  var nearestCoord;\n\n  if (pointCenterCoord < firstCoord) {\n    nearestCoord = firstCoord;\n  } else {\n    if (secondCoord < pointCenterCoord) {\n      nearestCoord = secondCoord;\n    } else {\n      nearestCoord = pointCenterCoord;\n    }\n  }\n\n  return nearestCoord;\n}\n\nfunction getLabelLayout(point) {\n  if (point._label.isVisible() && \"inside\" !== point._label.getLayoutOptions().position) {\n    return point._label.getBoundingRect();\n  }\n}\n\nfunction getPieRadius(series, paneCenterX, paneCenterY, accessibleRadius, minR) {\n  series.some(function (singleSeries) {\n    return singleSeries.getVisiblePoints().reduce(function (radiusIsFound, point) {\n      var labelBBox = getLabelLayout(point);\n\n      if (labelBBox) {\n        var xCoords = getNearestCoord(labelBBox.x, labelBBox.x + labelBBox.width, paneCenterX);\n        var yCoords = getNearestCoord(labelBBox.y, labelBBox.y + labelBBox.height, paneCenterY);\n        accessibleRadius = _min(_max(getLengthFromCenter(xCoords, yCoords, paneCenterX, paneCenterY) - RADIAL_LABEL_INDENT, minR), accessibleRadius);\n        radiusIsFound = true;\n      }\n\n      return radiusIsFound;\n    }, false);\n  });\n  return accessibleRadius;\n}\n\nfunction getSizeLabels(series) {\n  return series.reduce(function (res, singleSeries) {\n    var maxWidth = singleSeries.getVisiblePoints().reduce(function (width, point) {\n      var labelBBox = getLabelLayout(point);\n\n      if (labelBBox && labelBBox.width > width) {\n        width = labelBBox.width;\n      }\n\n      return width;\n    }, 0);\n    var rWidth = maxWidth;\n\n    if (maxWidth) {\n      res.outerLabelsCount++;\n\n      if (res.outerLabelsCount > 1) {\n        maxWidth += consts.pieLabelSpacing;\n      }\n\n      rWidth += consts.pieLabelSpacing;\n    }\n\n    res.sizes.push(maxWidth);\n    res.rSizes.push(rWidth);\n    res.common += maxWidth;\n    return res;\n  }, {\n    sizes: [],\n    rSizes: [],\n    common: 0,\n    outerLabelsCount: 0\n  });\n}\n\nfunction correctLabelRadius(labelSizes, radius, series, canvas, averageWidthLabels, centerX) {\n  var curRadius;\n  var i;\n  var runningWidth = 0;\n  var sizes = labelSizes.sizes;\n  var rSizes = labelSizes.rSizes;\n\n  for (i = 0; i < series.length; i++) {\n    if (0 === sizes[i]) {\n      curRadius && (curRadius += rSizes[i - 1]);\n      continue;\n    }\n\n    curRadius = _floor(curRadius ? curRadius + rSizes[i - 1] : radius);\n    series[i].correctLabelRadius(curRadius);\n    runningWidth += averageWidthLabels || sizes[i];\n    rSizes[i] = averageWidthLabels || rSizes[i];\n    series[i].setVisibleArea({\n      left: _floor(centerX - radius - runningWidth),\n      right: _floor(canvas.width - (centerX + radius + runningWidth)),\n      top: canvas.top,\n      bottom: canvas.bottom,\n      width: canvas.width,\n      height: canvas.height\n    });\n  }\n}\n\nfunction getLengthFromCenter(x, y, paneCenterX, paneCenterY) {\n  return _sqrt((x - paneCenterX) * (x - paneCenterX) + (y - paneCenterY) * (y - paneCenterY));\n}\n\nfunction getInnerRadius(series) {\n  var innerRadius;\n\n  if (\"pie\" === series.type) {\n    innerRadius = 0;\n  } else {\n    innerRadius = _isNumber(series.innerRadius) ? Number(series.innerRadius) : .5;\n    innerRadius = innerRadius < .2 ? .2 : innerRadius;\n    innerRadius = innerRadius > .8 ? .8 : innerRadius;\n  }\n\n  return innerRadius;\n}\n\nvar inverseAlign = {\n  left: \"right\",\n  right: \"left\",\n  top: \"bottom\",\n  bottom: \"top\",\n  center: \"center\"\n};\n\nfunction downSize(canvas, layoutOptions) {\n  canvas[layoutOptions.cutLayoutSide] += \"horizontal\" === layoutOptions.cutSide ? layoutOptions.width : layoutOptions.height;\n}\n\nfunction getOffset(layoutOptions, offsets) {\n  var side = layoutOptions.cutLayoutSide;\n  var offset = {\n    horizontal: 0,\n    vertical: 0\n  };\n\n  switch (side) {\n    case \"top\":\n    case \"left\":\n      offset[layoutOptions.cutSide] = -offsets[side];\n      break;\n\n    case \"bottom\":\n    case \"right\":\n      offset[layoutOptions.cutSide] = offsets[side];\n  }\n\n  return offset;\n}\n\nfunction LayoutManager() {}\n\nfunction toLayoutElementCoords(canvas) {\n  return new layoutElementModule.WrapperLayoutElement(null, {\n    x: canvas.left,\n    y: canvas.top,\n    width: canvas.width - canvas.left - canvas.right,\n    height: canvas.height - canvas.top - canvas.bottom\n  });\n}\n\nfunction getAverageLabelWidth(centerX, radius, canvas, sizeLabels) {\n  return (centerX - radius - RADIAL_LABEL_INDENT - canvas.left) / sizeLabels.outerLabelsCount;\n}\n\nfunction getFullRadiusWithLabels(centerX, canvas, sizeLabels) {\n  return centerX - canvas.left - (sizeLabels.outerLabelsCount > 0 ? sizeLabels.common + RADIAL_LABEL_INDENT : 0);\n}\n\nfunction correctAvailableRadius(availableRadius, canvas, series, minR, paneCenterX, paneCenterY) {\n  var sizeLabels = getSizeLabels(series);\n  var averageWidthLabels;\n  var fullRadiusWithLabels = getFullRadiusWithLabels(paneCenterX, canvas, sizeLabels);\n\n  if (fullRadiusWithLabels < minR) {\n    availableRadius = minR;\n    averageWidthLabels = getAverageLabelWidth(paneCenterX, availableRadius, canvas, sizeLabels);\n  } else {\n    availableRadius = _min(getPieRadius(series, paneCenterX, paneCenterY, availableRadius, minR), fullRadiusWithLabels);\n  }\n\n  correctLabelRadius(sizeLabels, availableRadius + RADIAL_LABEL_INDENT, series, canvas, averageWidthLabels, paneCenterX);\n  return availableRadius;\n}\n\nLayoutManager.prototype = {\n  constructor: LayoutManager,\n  setOptions: function (options) {\n    this._options = options;\n  },\n  applyPieChartSeriesLayout: function (canvas, series, hideLayoutLabels) {\n    var paneSpaceHeight = canvas.height - canvas.top - canvas.bottom;\n    var paneSpaceWidth = canvas.width - canvas.left - canvas.right;\n    var paneCenterX = paneSpaceWidth / 2 + canvas.left;\n    var paneCenterY = paneSpaceHeight / 2 + canvas.top;\n    var piePercentage = this._options.piePercentage;\n    var availableRadius;\n    var minR;\n\n    if (_isNumber(piePercentage)) {\n      availableRadius = minR = piePercentage * _min(canvas.height, canvas.width) / 2;\n    } else {\n      availableRadius = _min(paneSpaceWidth, paneSpaceHeight) / 2;\n      minR = this._options.minPiePercentage * availableRadius;\n    }\n\n    if (!hideLayoutLabels) {\n      availableRadius = correctAvailableRadius(availableRadius, canvas, series, minR, paneCenterX, paneCenterY);\n    }\n\n    return {\n      centerX: _floor(paneCenterX),\n      centerY: _floor(paneCenterY),\n      radiusInner: _floor(availableRadius * getInnerRadius(series[0])),\n      radiusOuter: _floor(availableRadius)\n    };\n  },\n  applyEqualPieChartLayout: function (series, layout) {\n    var radius = layout.radius;\n    return {\n      centerX: _floor(layout.x),\n      centerY: _floor(layout.y),\n      radiusInner: _floor(radius * getInnerRadius(series[0])),\n      radiusOuter: _floor(radius)\n    };\n  },\n  correctPieLabelRadius: function (series, layout, canvas) {\n    var sizeLabels = getSizeLabels(series);\n    var averageWidthLabels;\n    var radius = layout.radiusOuter + RADIAL_LABEL_INDENT;\n    var availableLabelWidth = layout.centerX - canvas.left - radius;\n\n    if (sizeLabels.common + RADIAL_LABEL_INDENT > availableLabelWidth) {\n      averageWidthLabels = getAverageLabelWidth(layout.centerX, layout.radiusOuter, canvas, sizeLabels);\n    }\n\n    correctLabelRadius(sizeLabels, radius, series, canvas, averageWidthLabels, layout.centerX);\n  },\n  needMoreSpaceForPanesCanvas: function (panes, rotated, fixedSizeCallback) {\n    var options = this._options;\n    var width = options.width;\n    var height = options.height;\n    var piePercentage = options.piePercentage;\n\n    var percentageIsValid = _isNumber(piePercentage);\n\n    var needHorizontalSpace = 0;\n    var needVerticalSpace = 0;\n    panes.forEach(function (pane) {\n      var paneCanvas = pane.canvas;\n      var minSize = percentageIsValid ? _min(paneCanvas.width, paneCanvas.height) * piePercentage : void 0;\n      var paneSized = fixedSizeCallback ? fixedSizeCallback(pane) : {\n        width: false,\n        height: false\n      };\n      var needPaneHorizontalSpace = !paneSized.width ? (percentageIsValid ? minSize : width) - (paneCanvas.width - paneCanvas.left - paneCanvas.right) : 0;\n      var needPaneVerticalSpace = !paneSized.height ? (percentageIsValid ? minSize : height) - (paneCanvas.height - paneCanvas.top - paneCanvas.bottom) : 0;\n\n      if (rotated) {\n        needHorizontalSpace += needPaneHorizontalSpace > 0 ? needPaneHorizontalSpace : 0;\n        needVerticalSpace = _max(needPaneVerticalSpace > 0 ? needPaneVerticalSpace : 0, needVerticalSpace);\n      } else {\n        needHorizontalSpace = _max(needPaneHorizontalSpace > 0 ? needPaneHorizontalSpace : 0, needHorizontalSpace);\n        needVerticalSpace += needPaneVerticalSpace > 0 ? needPaneVerticalSpace : 0;\n      }\n    });\n    return needHorizontalSpace > 0 || needVerticalSpace > 0 ? {\n      width: needHorizontalSpace,\n      height: needVerticalSpace\n    } : false;\n  },\n  layoutElements: function (elements, canvas, funcAxisDrawer, panes, rotated) {\n    this._elements = elements;\n\n    this._probeDrawing(canvas);\n\n    this._drawElements(canvas);\n\n    funcAxisDrawer();\n\n    this._processAdaptiveLayout(panes, rotated, canvas, funcAxisDrawer);\n\n    this._positionElements(canvas);\n  },\n  _processAdaptiveLayout: function (panes, rotated, canvas, funcAxisDrawer) {\n    var that = this;\n    var size = that.needMoreSpaceForPanesCanvas(panes, rotated);\n    var items = this._elements;\n\n    if (!size) {\n      return;\n    }\n\n    function processCanvases(item, layoutOptions, side) {\n      if (!item.getLayoutOptions()[side]) {\n        canvas[layoutOptions.cutLayoutSide] -= layoutOptions[side];\n        size[side] = size[side] - layoutOptions[side];\n      }\n    }\n\n    items.slice().reverse().forEach(function (item) {\n      var layoutOptions = item.getLayoutOptions();\n      var needRedraw = false;\n      var sizeObject;\n      var cutSide;\n\n      if (!layoutOptions) {\n        return;\n      }\n\n      sizeObject = extend({}, layoutOptions);\n      needRedraw = \"vertical\" === layoutOptions.cutSide && size.width < 0 || \"horizontal\" === layoutOptions.cutSide && size.height < 0 || \"vertical\" === layoutOptions.cutSide && size.height > 0 || \"horizontal\" === layoutOptions.cutSide && size.width > 0;\n      cutSide = \"horizontal\" === layoutOptions.cutSide ? \"width\" : \"height\";\n\n      if (needRedraw) {\n        var width = sizeObject.width - size.width;\n        var height = sizeObject.height - size.height;\n\n        if (\"height\" === cutSide && size.width < 0) {\n          width = canvas.width - canvas.left - canvas.right;\n        }\n\n        if (\"width\" === cutSide && size.height < 0) {\n          height = canvas.height - canvas.top - canvas.bottom;\n        }\n\n        item.draw(width, height);\n      }\n\n      processCanvases(item, layoutOptions, cutSide);\n    });\n    funcAxisDrawer(size);\n  },\n  _probeDrawing: function (canvas) {\n    var that = this;\n\n    this._elements.forEach(function (item) {\n      var layoutOptions = item.getLayoutOptions();\n      var sizeObject;\n\n      if (!layoutOptions) {\n        return;\n      }\n\n      sizeObject = {\n        width: canvas.width - canvas.left - canvas.right,\n        height: canvas.height - canvas.top - canvas.bottom\n      };\n\n      if (\"vertical\" === layoutOptions.cutSide) {\n        sizeObject.height -= that._options.height;\n      } else {\n        sizeObject.width -= that._options.width;\n      }\n\n      item.probeDraw(sizeObject.width, sizeObject.height);\n      downSize(canvas, item.getLayoutOptions());\n    });\n  },\n  _drawElements: function (canvas) {\n    this._elements.slice().reverse().forEach(function (item) {\n      var layoutOptions = item.getLayoutOptions();\n      var sizeObject;\n      var cutSide;\n      var length;\n\n      if (!layoutOptions) {\n        return;\n      }\n\n      sizeObject = {\n        width: canvas.width - canvas.left - canvas.right,\n        height: canvas.height - canvas.top - canvas.bottom\n      };\n      cutSide = layoutOptions.cutSide;\n      length = \"horizontal\" === cutSide ? \"width\" : \"height\";\n      sizeObject[length] = layoutOptions[length];\n      item.draw(sizeObject.width, sizeObject.height);\n    });\n  },\n  _positionElements: function (canvas) {\n    var offsets = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n\n    this._elements.slice().reverse().forEach(function (item) {\n      var layoutOptions = item.getLayoutOptions();\n      var position;\n      var cutSide;\n      var my;\n\n      if (!layoutOptions) {\n        return;\n      }\n\n      position = layoutOptions.position;\n      cutSide = layoutOptions.cutSide;\n      my = {\n        horizontal: position.horizontal,\n        vertical: position.vertical\n      };\n      my[cutSide] = inverseAlign[my[cutSide]];\n      item.position({\n        of: toLayoutElementCoords(canvas),\n        my: my,\n        at: position,\n        offset: getOffset(layoutOptions, offsets)\n      });\n      offsets[layoutOptions.cutLayoutSide] += layoutOptions[\"horizontal\" === layoutOptions.cutSide ? \"width\" : \"height\"];\n    });\n  }\n};\nexports.LayoutManager = LayoutManager;","map":null,"metadata":{},"sourceType":"script"}