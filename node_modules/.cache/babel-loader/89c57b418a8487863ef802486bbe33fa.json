{"ast":null,"code":"/**\r\n * DevExtreme (viz/core/layout.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _normalizeEnum = require(\"./utils\").normalizeEnum;\n\nvar _min = Math.min;\nvar _max = Math.max;\nvar _round = Math.round;\nvar ALIGN_START = 0;\nvar ALIGN_MIDDLE = 1;\nvar ALIGN_END = 2;\nvar horizontalAlignmentMap = {\n  left: ALIGN_START,\n  center: ALIGN_MIDDLE,\n  right: ALIGN_END\n};\nvar verticalAlignmentMap = {\n  top: ALIGN_START,\n  center: ALIGN_MIDDLE,\n  bottom: ALIGN_END\n};\nvar sideMap = {\n  horizontal: 0,\n  vertical: 1\n};\nvar slicersMap = {};\nvar BBOX_CEIL_CORRECTION = 2;\n\nslicersMap[ALIGN_START] = function (a, b, size) {\n  return [a, _min(b, a + size)];\n};\n\nslicersMap[ALIGN_MIDDLE] = function (a, b, size) {\n  return [_max(a, (a + b - size) / 2), _min(b, (a + b + size) / 2)];\n};\n\nslicersMap[ALIGN_END] = function (a, b, size) {\n  return [_max(a, b - size), b];\n};\n\nfunction pickValue(value, map, defaultValue) {\n  var val = _normalizeEnum(value);\n\n  return val in map ? map[val] : defaultValue;\n}\n\nfunction normalizeLayoutOptions(options) {\n  var side = pickValue(options.side, sideMap, 1);\n  var alignment = [pickValue(options.horizontalAlignment, horizontalAlignmentMap, ALIGN_MIDDLE), pickValue(options.verticalAlignment, verticalAlignmentMap, ALIGN_START)];\n  return {\n    side: side,\n    primary: bringToEdge(alignment[side]),\n    secondary: alignment[1 - side],\n    weak: options.weak,\n    priority: options.priority || 0,\n    header: options.header,\n    position: options.position\n  };\n}\n\nfunction bringToEdge(primary) {\n  return primary < 2 ? 0 : 2;\n}\n\nfunction getConjugateSide(side) {\n  return 1 - side;\n}\n\nfunction getSlice(alignment, a, b, size) {\n  return slicersMap[alignment](a, b, size);\n}\n\nfunction getShrink(alignment, size) {\n  return (alignment > 0 ? -1 : 1) * size;\n}\n\nfunction processForward(item, rect, minSize) {\n  var side = item.side;\n  var size = item.element.measure([rect[2] - rect[0], rect[3] - rect[1]]);\n  var minSide = \"indside\" === item.position ? 0 : minSize[side];\n  var isValid = size[side] < rect[2 + side] - rect[side] - minSide;\n\n  if (isValid) {\n    if (\"inside\" !== item.position) {\n      rect[item.primary + side] += getShrink(item.primary, size[side]);\n    }\n\n    item.size = size;\n  }\n\n  return isValid;\n}\n\nfunction processRectBackward(item, rect, alignmentRect) {\n  var primarySide = item.side;\n  var secondarySide = getConjugateSide(primarySide);\n  var itemRect = [];\n  var secondary = getSlice(item.secondary, alignmentRect[secondarySide], alignmentRect[2 + secondarySide], item.size[secondarySide]);\n  itemRect[primarySide] = _round(itemRect[2 + primarySide] = rect[item.primary + primarySide] + (\"inside\" === item.position ? getShrink(item.primary, item.size[primarySide]) : 0));\n  itemRect[item.primary + primarySide] = _round(rect[item.primary + primarySide] - getShrink(item.primary, item.size[primarySide]));\n\n  if (\"inside\" !== item.position) {\n    rect[item.primary + primarySide] = itemRect[item.primary + primarySide];\n  }\n\n  itemRect[secondarySide] = _round(secondary[0]);\n  itemRect[2 + secondarySide] = _round(secondary[1]);\n  return itemRect;\n}\n\nfunction processBackward(item, rect, alignmentRect, fitRect, size, targetRect) {\n  var itemRect = processRectBackward(item, rect, alignmentRect);\n  var itemFitRect = processRectBackward(item, fitRect, fitRect);\n\n  if (size[item.side] > 0) {\n    size[item.side] -= item.size[item.side];\n    targetRect[item.primary + item.side] = itemRect[item.primary + item.side];\n    item.element.freeSpace();\n  } else {\n    item.element.move(itemRect, itemFitRect);\n  }\n}\n\nfunction Layout() {\n  this._targets = [];\n}\n\nLayout.prototype = {\n  constructor: Layout,\n  dispose: function () {\n    this._targets = null;\n  },\n  add: function (target) {\n    this._targets.push(target);\n  },\n  forward: function (targetRect, minSize) {\n    var rect = targetRect.slice();\n    var targets = createTargets(this._targets);\n    var i;\n    var ii = targets.length;\n    var cache = [];\n\n    for (i = 0; i < ii; ++i) {\n      if (processForward(targets[i], rect, minSize)) {\n        cache.push(targets[i]);\n      } else {\n        targets[i].element.freeSpace();\n      }\n    }\n\n    this._cache = cache.reverse();\n    return rect;\n  },\n  backward: function (targetRect, alignmentRect) {\n    var size = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [0, 0];\n    var backwardRect = targetRect.slice();\n    var fitRect = targetRect.slice();\n    var targets = this._cache;\n    var targetSide = 0;\n    var target;\n    var i;\n    var ii = targets.length;\n\n    for (i = 0; i < ii; ++i) {\n      target = targets[i];\n\n      if (target.side !== targetSide) {\n        backwardRect = targetRect.slice();\n      }\n\n      processBackward(target, backwardRect, alignmentRect, fitRect, size, targetRect);\n      targetSide = target.side;\n    }\n\n    return size;\n  }\n};\n\nfunction createTargets(targets) {\n  var i;\n  var ii = targets.length;\n  var collection = [];\n  var layout;\n\n  for (i = 0; i < ii; ++i) {\n    layout = targets[i].layoutOptions();\n\n    if (layout) {\n      layout = normalizeLayoutOptions(layout);\n      layout.element = targets[i];\n      collection.push(layout);\n    }\n  }\n\n  collection.sort(function (a, b) {\n    return b.side - a.side || a.priority - b.priority;\n  });\n  collection = processWeakItems(collection);\n  return collection;\n}\n\nfunction processWeakItems(collection) {\n  var weakItem = collection.filter(function (item) {\n    return true === item.weak;\n  })[0];\n  var headerItem;\n\n  if (weakItem) {\n    headerItem = collection.filter(function (item) {\n      return weakItem.primary === item.primary && item.side === weakItem.side && item !== weakItem;\n    })[0];\n  }\n\n  if (weakItem && headerItem) {\n    return [makeHeader(headerItem, weakItem)].concat(collection.filter(function (item) {\n      return !(item === headerItem || item === weakItem);\n    }));\n  }\n\n  return collection;\n}\n\nfunction processBackwardHeaderRect(element, rect) {\n  var rectCopy = rect.slice();\n  var itemRect = processRectBackward(element, rectCopy, rectCopy);\n  itemRect[element.side] = rect[element.side];\n  itemRect[2 + element.side] = rect[2 + element.side];\n  return itemRect;\n}\n\nfunction makeHeader(header, weakElement) {\n  var side = header.side;\n  var primary = header.primary;\n  var secondary = header.secondary;\n  return {\n    side: side,\n    primary: primary,\n    secondary: secondary,\n    priority: 0,\n    element: {\n      measure: function (targetSize) {\n        var result = targetSize.slice();\n        var weakSize = weakElement.element.measure(targetSize.slice());\n        targetSize[primary] -= weakSize[primary];\n        var headerSize = header.element.measure(targetSize.slice());\n        result[side] = weakSize[side] = headerSize[side] = Math.max(headerSize[side], weakSize[side]);\n        weakElement.size = weakSize;\n        header.size = headerSize;\n        return result;\n      },\n      move: function (rect, fitRect) {\n        if (fitRect[2] - fitRect[0] < header.size[0] + weakElement.size[0] - BBOX_CEIL_CORRECTION) {\n          this.freeSpace();\n          return;\n        }\n\n        var weakRect = processBackwardHeaderRect(weakElement, fitRect, fitRect);\n        fitRect[2 + weakElement.primary] = weakRect[weakElement.primary];\n        var headerFitReact = processBackwardHeaderRect(header, fitRect, fitRect);\n\n        if (fitRect[2 + weakElement.primary] < rect[2 + weakElement.primary] && header.size[header.primary] > rect[2 + header.primary] - rect[header.primary]) {\n          rect[2 + weakElement.primary] = fitRect[2 + weakElement.primary];\n        }\n\n        var headerRect = processBackwardHeaderRect(header, rect, rect);\n\n        if (headerRect[2 + weakElement.primary] > fitRect[2 + weakElement.primary]) {\n          rect[2 + weakElement.primary] = fitRect[2 + weakElement.primary];\n          headerRect = processBackwardHeaderRect(header, rect, rect);\n        }\n\n        weakElement.element.move(weakRect);\n        header.element.move(headerRect, headerFitReact);\n      },\n      freeSpace: function () {\n        header.element.freeSpace();\n        weakElement.element.freeSpace();\n      }\n    }\n  };\n}\n\nmodule.exports = Layout;","map":null,"metadata":{},"sourceType":"script"}