{"ast":null,"code":"/**\r\n * DevExtreme (viz/series/points/candlestick_point.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _extend = require(\"../../../core/utils/extend\").extend;\n\nvar symbolPoint = require(\"./symbol_point\");\n\nvar barPoint = require(\"./bar_point\");\n\nvar _math = Math;\nvar _abs = _math.abs;\nvar _min = _math.min;\nvar _max = _math.max;\nvar _round = _math.round;\nvar DEFAULT_FINANCIAL_TRACKER_MARGIN = 2;\nmodule.exports = _extend({}, barPoint, {\n  _getContinuousPoints: function (openCoord, closeCoord) {\n    var that = this;\n    var x = that.x;\n    var createPoint = that._options.rotated ? function (x, y) {\n      return [y, x];\n    } : function (x, y) {\n      return [x, y];\n    };\n    var width = that.width;\n    var highCoord = that.highY;\n    var max = _abs(highCoord - openCoord) < _abs(highCoord - closeCoord) ? openCoord : closeCoord;\n    var min = max === closeCoord ? openCoord : closeCoord;\n    var points;\n\n    if (min === max) {\n      points = [].concat(createPoint(x, that.highY)).concat(createPoint(x, that.lowY)).concat(createPoint(x, that.closeY)).concat(createPoint(x - width / 2, that.closeY)).concat(createPoint(x + width / 2, that.closeY)).concat(createPoint(x, that.closeY));\n    } else {\n      points = [].concat(createPoint(x, that.highY)).concat(createPoint(x, max)).concat(createPoint(x + width / 2, max)).concat(createPoint(x + width / 2, min)).concat(createPoint(x, min)).concat(createPoint(x, that.lowY)).concat(createPoint(x, min)).concat(createPoint(x - width / 2, min)).concat(createPoint(x - width / 2, max)).concat(createPoint(x, max));\n    }\n\n    return points;\n  },\n  _getCrockPoints: function (y) {\n    var that = this;\n    var x = that.x;\n    var createPoint = that._options.rotated ? function (x, y) {\n      return [y, x];\n    } : function (x, y) {\n      return [x, y];\n    };\n    return [].concat(createPoint(x, that.highY)).concat(createPoint(x, that.lowY)).concat(createPoint(x, y)).concat(createPoint(x - that.width / 2, y)).concat(createPoint(x + that.width / 2, y)).concat(createPoint(x, y));\n  },\n  _getPoints: function () {\n    var that = this;\n    var points;\n    var closeCoord = that.closeY;\n    var openCoord = that.openY;\n\n    if (null !== closeCoord && null !== openCoord) {\n      points = that._getContinuousPoints(openCoord, closeCoord);\n    } else {\n      if (openCoord === closeCoord) {\n        points = [that.x, that.highY, that.x, that.lowY];\n      } else {\n        points = that._getCrockPoints(null !== openCoord ? openCoord : closeCoord);\n      }\n    }\n\n    return points;\n  },\n  getColor: function () {\n    var that = this;\n    return that._isReduction ? that._options.reduction.color : that._styles.normal.stroke || that.series.getColor();\n  },\n  _drawMarkerInGroup: function (group, attributes, renderer) {\n    var that = this;\n    that.graphic = renderer.path(that._getPoints(), \"area\").attr({\n      \"stroke-linecap\": \"square\"\n    }).attr(attributes).data({\n      \"chart-data-point\": that\n    }).sharp().append(group);\n  },\n  _fillStyle: function () {\n    var that = this;\n    var styles = that._options.styles;\n\n    if (that._isReduction && that._isPositive) {\n      that._styles = styles.reductionPositive;\n    } else {\n      if (that._isReduction) {\n        that._styles = styles.reduction;\n      } else {\n        if (that._isPositive) {\n          that._styles = styles.positive;\n        } else {\n          that._styles = styles;\n        }\n      }\n    }\n  },\n  _getMinTrackerWidth: function () {\n    return 2 + 2 * this._styles.normal[\"stroke-width\"];\n  },\n  correctCoordinates: function (correctOptions) {\n    var minWidth = this._getMinTrackerWidth();\n\n    var maxWidth = 10;\n    var width = correctOptions.width;\n    width = width < minWidth ? minWidth : width > maxWidth ? maxWidth : width;\n    this.width = width + width % 2;\n    this.xCorrection = correctOptions.offset;\n  },\n  _getMarkerGroup: function (group) {\n    var that = this;\n    var markerGroup;\n\n    if (that._isReduction && that._isPositive) {\n      markerGroup = group.reductionPositiveMarkersGroup;\n    } else {\n      if (that._isReduction) {\n        markerGroup = group.reductionMarkersGroup;\n      } else {\n        if (that._isPositive) {\n          markerGroup = group.defaultPositiveMarkersGroup;\n        } else {\n          markerGroup = group.defaultMarkersGroup;\n        }\n      }\n    }\n\n    return markerGroup;\n  },\n  _drawMarker: function (renderer, group) {\n    this._drawMarkerInGroup(this._getMarkerGroup(group), this._getStyle(), renderer);\n  },\n  _getSettingsForTracker: function () {\n    var that = this;\n    var highY = that.highY;\n    var lowY = that.lowY;\n    var rotated = that._options.rotated;\n    var x;\n    var y;\n    var width;\n    var height;\n\n    if (highY === lowY) {\n      highY = rotated ? highY + DEFAULT_FINANCIAL_TRACKER_MARGIN : highY - DEFAULT_FINANCIAL_TRACKER_MARGIN;\n      lowY = rotated ? lowY - DEFAULT_FINANCIAL_TRACKER_MARGIN : lowY + DEFAULT_FINANCIAL_TRACKER_MARGIN;\n    }\n\n    if (rotated) {\n      x = _min(lowY, highY);\n      y = that.x - that.width / 2;\n      width = _abs(lowY - highY);\n      height = that.width;\n    } else {\n      x = that.x - that.width / 2;\n      y = _min(lowY, highY);\n      width = that.width;\n      height = _abs(lowY - highY);\n    }\n\n    return {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    };\n  },\n  _getGraphicBBox: function (location) {\n    var that = this;\n    var rotated = that._options.rotated;\n    var x = that.x;\n    var width = that.width;\n    var lowY = that.lowY;\n    var highY = that.highY;\n\n    if (location) {\n      var valVisibleArea = that.series.getValueAxis().getVisibleArea();\n      highY = that._truncateCoord(highY, valVisibleArea);\n      lowY = that._truncateCoord(lowY, valVisibleArea);\n    }\n\n    var bBox = {\n      x: !rotated ? x - _round(width / 2) : lowY,\n      y: !rotated ? highY : x - _round(width / 2),\n      width: !rotated ? width : highY - lowY,\n      height: !rotated ? lowY - highY : width\n    };\n\n    if (location) {\n      var isTop = \"top\" === location;\n\n      if (!this._options.rotated) {\n        bBox.y = isTop ? bBox.y : bBox.y + bBox.height;\n        bBox.height = 0;\n      } else {\n        bBox.x = isTop ? bBox.x + bBox.width : bBox.x;\n        bBox.width = 0;\n      }\n    }\n\n    return bBox;\n  },\n  getTooltipParams: function (location) {\n    var that = this;\n\n    if (that.graphic) {\n      var minValue = _min(that.lowY, that.highY);\n\n      var maxValue = _max(that.lowY, that.highY);\n\n      var visibleArea = that._getVisibleArea();\n\n      var rotated = that._options.rotated;\n      var minVisible = rotated ? visibleArea.minX : visibleArea.minY;\n      var maxVisible = rotated ? visibleArea.maxX : visibleArea.maxY;\n\n      var min = _max(minVisible, minValue);\n\n      var max = _min(maxVisible, maxValue);\n\n      var centerCoord = that.getCenterCoord();\n\n      if (\"edge\" === location) {\n        centerCoord[rotated ? \"x\" : \"y\"] = rotated ? max : min;\n      }\n\n      centerCoord.offset = 0;\n      return centerCoord;\n    }\n  },\n  getCenterCoord: function () {\n    if (this.graphic) {\n      var that = this;\n      var x;\n      var y;\n\n      var minValue = _min(that.lowY, that.highY);\n\n      var maxValue = _max(that.lowY, that.highY);\n\n      var visibleArea = that._getVisibleArea();\n\n      var rotated = that._options.rotated;\n      var minVisible = rotated ? visibleArea.minX : visibleArea.minY;\n      var maxVisible = rotated ? visibleArea.maxX : visibleArea.maxY;\n\n      var min = _max(minVisible, minValue);\n\n      var max = _min(maxVisible, maxValue);\n\n      var center = min + (max - min) / 2;\n\n      if (rotated) {\n        y = that.x;\n        x = center;\n      } else {\n        x = that.x;\n        y = center;\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    }\n  },\n  hasValue: function () {\n    return null !== this.highValue && null !== this.lowValue;\n  },\n  hasCoords: function () {\n    return null !== this.x && null !== this.lowY && null !== this.highY;\n  },\n  _translate: function () {\n    var that = this;\n    var rotated = that._options.rotated;\n\n    var valTranslator = that._getValTranslator();\n\n    var x = that._getArgTranslator().translate(that.argument);\n\n    that.vx = that.vy = that.x = null === x ? x : x + (that.xCorrection || 0);\n    that.openY = null !== that.openValue ? valTranslator.translate(that.openValue) : null;\n    that.highY = valTranslator.translate(that.highValue);\n    that.lowY = valTranslator.translate(that.lowValue);\n    that.closeY = null !== that.closeValue ? valTranslator.translate(that.closeValue) : null;\n    var centerValue = _min(that.lowY, that.highY) + _abs(that.lowY - that.highY) / 2;\n\n    that._calculateVisibility(!rotated ? that.x : centerValue, !rotated ? centerValue : that.x);\n  },\n  getCrosshairData: function (x, y) {\n    var that = this;\n    var rotated = that._options.rotated;\n    var origY = rotated ? x : y;\n    var yValue;\n    var argument = that.argument;\n    var coords;\n    var coord = \"low\";\n\n    if (_abs(that.lowY - origY) < _abs(that.closeY - origY)) {\n      yValue = that.lowY;\n    } else {\n      yValue = that.closeY;\n      coord = \"close\";\n    }\n\n    if (_abs(yValue - origY) >= _abs(that.openY - origY)) {\n      yValue = that.openY;\n      coord = \"open\";\n    }\n\n    if (_abs(yValue - origY) >= _abs(that.highY - origY)) {\n      yValue = that.highY;\n      coord = \"high\";\n    }\n\n    if (rotated) {\n      coords = {\n        y: that.vy,\n        x: yValue,\n        xValue: that[coord + \"Value\"],\n        yValue: argument\n      };\n    } else {\n      coords = {\n        x: that.vx,\n        y: yValue,\n        xValue: argument,\n        yValue: that[coord + \"Value\"]\n      };\n    }\n\n    coords.axis = that.series.axis;\n    return coords;\n  },\n  _updateData: function (data) {\n    var that = this;\n    var label = that._label;\n    var reductionColor = this._options.reduction.color;\n    that.value = that.initialValue = data.reductionValue;\n    that.originalValue = data.value;\n    that.lowValue = that.originalLowValue = data.lowValue;\n    that.highValue = that.originalHighValue = data.highValue;\n    that.openValue = that.originalOpenValue = data.openValue;\n    that.closeValue = that.originalCloseValue = data.closeValue;\n    that._isPositive = data.openValue < data.closeValue;\n    that._isReduction = data.isReduction;\n\n    if (that._isReduction) {\n      label.setColor(reductionColor);\n    }\n  },\n  _updateMarker: function (animationEnabled, style, group) {\n    var that = this;\n    var graphic = that.graphic;\n    graphic.attr({\n      points: that._getPoints()\n    }).smartAttr(style).sharp();\n    group && graphic.append(that._getMarkerGroup(group));\n  },\n  _getLabelFormatObject: function () {\n    var that = this;\n    return {\n      openValue: that.openValue,\n      highValue: that.highValue,\n      lowValue: that.lowValue,\n      closeValue: that.closeValue,\n      reductionValue: that.initialValue,\n      argument: that.initialArgument,\n      value: that.initialValue,\n      seriesName: that.series.name,\n      originalOpenValue: that.originalOpenValue,\n      originalCloseValue: that.originalCloseValue,\n      originalLowValue: that.originalLowValue,\n      originalHighValue: that.originalHighValue,\n      originalArgument: that.originalArgument,\n      point: that\n    };\n  },\n  _getFormatObject: function (tooltip) {\n    var that = this;\n    var highValue = tooltip.formatValue(that.highValue);\n    var openValue = tooltip.formatValue(that.openValue);\n    var closeValue = tooltip.formatValue(that.closeValue);\n    var lowValue = tooltip.formatValue(that.lowValue);\n    var symbolMethods = symbolPoint;\n\n    var formatObject = symbolMethods._getFormatObject.call(that, tooltip);\n\n    return _extend({}, formatObject, {\n      valueText: \"h: \" + highValue + (\"\" !== openValue ? \" o: \" + openValue : \"\") + (\"\" !== closeValue ? \" c: \" + closeValue : \"\") + \" l: \" + lowValue,\n      highValueText: highValue,\n      openValueText: openValue,\n      closeValueText: closeValue,\n      lowValueText: lowValue\n    });\n  },\n  getMaxValue: function () {\n    return this.highValue;\n  },\n  getMinValue: function () {\n    return this.lowValue;\n  }\n});","map":null,"metadata":{},"sourceType":"script"}