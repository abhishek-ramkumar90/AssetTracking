{"ast":null,"code":"/**\r\n * DevExtreme (viz/series/base_series.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar seriesNS = {};\n\nvar typeUtils = require(\"../../core/utils/type\");\n\nvar _extend = require(\"../../core/utils/extend\").extend;\n\nvar _each = require(\"../../core/utils/iterator\").each;\n\nvar pointModule = require(\"./points/base_point\");\n\nvar _isDefined = typeUtils.isDefined;\n\nvar vizUtils = require(\"../core/utils\");\n\nvar _isEmptyObject = typeUtils.isEmptyObject;\nvar _normalizeEnum = vizUtils.normalizeEnum;\n\nvar _noop = require(\"../../core/utils/common\").noop;\n\nvar states = require(\"../components/consts\").states;\n\nvar rangeCalculator = require(\"./helpers/range_data_calculator\");\n\nvar scatterSeries = require(\"./scatter_series\");\n\nvar lineSeries = require(\"./line_series\");\n\nvar areaSeries = require(\"./area_series\");\n\nvar barSeries = require(\"./bar_series\");\n\nvar rangeSeries = require(\"./range_series\");\n\nvar bubbleSeries = require(\"./bubble_series\");\n\nvar pieSeries = require(\"./pie_series\");\n\nvar financialSeries = require(\"./financial_series\");\n\nvar stackedSeries = require(\"./stacked_series\");\n\nvar DISCRETE = \"discrete\";\nvar SELECTED_STATE = states.selectedMark;\nvar HOVER_STATE = states.hoverMark;\nvar HOVER = states.hover;\nvar NORMAL = states.normal;\nvar SELECTION = states.selection;\nvar APPLY_SELECTED = states.applySelected;\nvar APPLY_HOVER = states.applyHover;\nvar RESET_ITEM = states.resetItem;\nvar NONE_MODE = \"none\";\nvar INCLUDE_POINTS = \"includepoints\";\nvar NEAREST_POINT = \"nearestpoint\";\nvar SERIES_SELECTION_CHANGED = \"seriesSelectionChanged\";\nvar POINT_SELECTION_CHANGED = \"pointSelectionChanged\";\nvar SERIES_HOVER_CHANGED = \"seriesHoverChanged\";\nvar POINT_HOVER_CHANGED = \"pointHoverChanged\";\nvar ALL_SERIES_POINTS = \"allseriespoints\";\nvar ALL_ARGUMENT_POINTS = \"allargumentpoints\";\nvar POINT_HOVER = \"pointHover\";\nvar CLEAR_POINT_HOVER = \"clearPointHover\";\nvar SERIES_SELECT = \"seriesSelect\";\nvar POINT_SELECT = \"pointSelect\";\nvar POINT_DESELECT = \"pointDeselect\";\n\nvar getEmptyBusinessRange = function () {\n  return {\n    arg: {},\n    val: {}\n  };\n};\n\nfunction triggerEvent(element, event, point) {\n  element && element.trigger(event, point);\n}\n\nseriesNS.mixins = {\n  chart: {},\n  pie: {},\n  polar: {}\n};\nseriesNS.mixins.chart.scatter = scatterSeries.chart;\nseriesNS.mixins.polar.scatter = scatterSeries.polar;\n\n_extend(seriesNS.mixins.pie, pieSeries);\n\n_extend(seriesNS.mixins.chart, lineSeries.chart, areaSeries.chart, barSeries.chart, rangeSeries.chart, bubbleSeries.chart, financialSeries, stackedSeries.chart);\n\n_extend(seriesNS.mixins.polar, lineSeries.polar, areaSeries.polar, barSeries.polar, rangeSeries.polar, bubbleSeries.polar, stackedSeries.polar);\n\nfunction includePointsMode(mode) {\n  mode = _normalizeEnum(mode);\n  return mode === INCLUDE_POINTS || mode === ALL_SERIES_POINTS;\n}\n\nfunction getLabelOptions(labelOptions, defaultColor) {\n  var opt = labelOptions || {};\n  var labelFont = _extend({}, opt.font) || {};\n  var labelBorder = opt.border || {};\n  var labelConnector = opt.connector || {};\n  var backgroundAttr = {\n    fill: opt.backgroundColor || defaultColor,\n    \"stroke-width\": labelBorder.visible ? labelBorder.width || 0 : 0,\n    stroke: labelBorder.visible && labelBorder.width ? labelBorder.color : \"none\",\n    dashStyle: labelBorder.dashStyle\n  };\n  var connectorAttr = {\n    stroke: labelConnector.visible && labelConnector.width ? labelConnector.color || defaultColor : \"none\",\n    \"stroke-width\": labelConnector.visible ? labelConnector.width || 0 : 0\n  };\n  labelFont.color = \"none\" === opt.backgroundColor && \"#ffffff\" === _normalizeEnum(labelFont.color) && \"inside\" !== opt.position ? defaultColor : labelFont.color;\n  return {\n    alignment: opt.alignment,\n    format: opt.format,\n    argumentFormat: opt.argumentFormat,\n    customizeText: typeUtils.isFunction(opt.customizeText) ? opt.customizeText : void 0,\n    attributes: {\n      font: labelFont\n    },\n    visible: 0 !== labelFont.size ? opt.visible : false,\n    showForZeroValues: opt.showForZeroValues,\n    horizontalOffset: opt.horizontalOffset,\n    verticalOffset: opt.verticalOffset,\n    radialOffset: opt.radialOffset,\n    background: backgroundAttr,\n    position: opt.position,\n    connector: connectorAttr,\n    rotationAngle: opt.rotationAngle,\n    wordWrap: opt.wordWrap,\n    textOverflow: opt.textOverflow,\n    cssClass: opt.cssClass\n  };\n}\n\nfunction setPointHoverState(point, legendCallback) {\n  point.fullState |= HOVER_STATE;\n  point.applyView(legendCallback);\n}\n\nfunction releasePointHoverState(point, legendCallback) {\n  point.fullState &= ~HOVER_STATE;\n  point.applyView(legendCallback);\n  point.releaseHoverState();\n}\n\nfunction setPointSelectedState(point, legendCallback) {\n  point.fullState |= SELECTED_STATE;\n  point.applyView(legendCallback);\n}\n\nfunction releasePointSelectedState(point, legendCallback) {\n  point.fullState &= ~SELECTED_STATE;\n  point.applyView(legendCallback);\n}\n\nfunction mergePointOptionsCore(base, extra) {\n  var options = _extend({}, base, extra);\n\n  options.border = _extend({}, base && base.border, extra && extra.border);\n  return options;\n}\n\nfunction mergePointOptions(base, extra) {\n  var options = mergePointOptionsCore(base, extra);\n  options.image = _extend(true, {}, base.image, extra.image);\n  options.selectionStyle = mergePointOptionsCore(base.selectionStyle, extra.selectionStyle);\n  options.hoverStyle = mergePointOptionsCore(base.hoverStyle, extra.hoverStyle);\n  return options;\n}\n\nfunction Series(settings, options) {\n  var that = this;\n  that.fullState = 0;\n  that._extGroups = settings;\n  that._renderer = settings.renderer;\n  that._group = settings.renderer.g().attr({\n    \"class\": \"dxc-series\"\n  });\n  that._eventTrigger = settings.eventTrigger;\n  that._eventPipe = settings.eventPipe;\n  that._incidentOccurred = settings.incidentOccurred;\n  that._legendCallback = _noop;\n  that.updateOptions(options, settings);\n}\n\nfunction getData(pointData) {\n  return pointData.data;\n}\n\nexports.Series = Series;\nexports.mixins = seriesNS.mixins;\n\nfunction getValueChecker(axisType, axis) {\n  if (!axis || \"logarithmic\" !== axisType || false !== axis.getOptions().allowNegatives) {\n    return function () {\n      return true;\n    };\n  } else {\n    return function (value) {\n      return value > 0;\n    };\n  }\n}\n\nSeries.prototype = {\n  constructor: Series,\n  _createLegendState: _noop,\n  getLegendStyles: function () {\n    return this._styles.legendStyles;\n  },\n  _createStyles: function (options) {\n    var that = this;\n    var mainSeriesColor = options.mainSeriesColor;\n    that._styles = {\n      normal: that._parseStyle(options, mainSeriesColor, mainSeriesColor),\n      hover: that._parseStyle(options.hoverStyle || {}, mainSeriesColor, mainSeriesColor),\n      selection: that._parseStyle(options.selectionStyle || {}, mainSeriesColor, mainSeriesColor),\n      legendStyles: {\n        normal: that._createLegendState(options, mainSeriesColor),\n        hover: that._createLegendState(options.hoverStyle || {}, mainSeriesColor),\n        selection: that._createLegendState(options.selectionStyle || {}, mainSeriesColor)\n      }\n    };\n  },\n  setClippingParams: function (baseId, wideId, forceClipping) {\n    var clipLabels = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : true;\n    this._paneClipRectID = baseId;\n    this._widePaneClipRectID = wideId;\n    this._forceClipping = forceClipping;\n    this._clipLabels = clipLabels;\n  },\n  applyClip: function () {\n    this._group.attr({\n      \"clip-path\": this._paneClipRectID\n    });\n  },\n  resetClip: function () {\n    this._group.attr({\n      \"clip-path\": null\n    });\n  },\n  getTagField: function () {\n    return this._options.tagField || \"tag\";\n  },\n  getValueFields: _noop,\n  getSizeField: _noop,\n  getArgumentField: _noop,\n  getPoints: function () {\n    return this._points;\n  },\n  getPointsInViewPort: function () {\n    return rangeCalculator.getPointsInViewPort(this);\n  },\n  _createPoint: function (data, index, oldPoint) {\n    data.index = index;\n    var that = this;\n    var pointsByArgument = that.pointsByArgument;\n\n    var options = that._getCreatingPointOptions(data);\n\n    var arg = data.argument.valueOf();\n    var point = oldPoint;\n    var pointByArgument;\n\n    if (point) {\n      point.update(data, options);\n    } else {\n      point = new pointModule.Point(that, data, options);\n\n      if (that.isSelected() && includePointsMode(that.lastSelectionMode)) {\n        point.setView(SELECTION);\n      }\n    }\n\n    pointByArgument = pointsByArgument[arg];\n\n    if (pointByArgument) {\n      pointByArgument.push(point);\n    } else {\n      pointsByArgument[arg] = [point];\n    }\n\n    if (point.hasValue()) {\n      that.customizePoint(point, data);\n    }\n\n    return point;\n  },\n  getRangeData: function () {\n    return this._visible ? this._getRangeData() : getEmptyBusinessRange();\n  },\n  getArgumentRange: function () {\n    return this._visible ? rangeCalculator.getArgumentRange(this) : getEmptyBusinessRange();\n  },\n  getViewport: function () {\n    return rangeCalculator.getViewport(this);\n  },\n  _deleteGroup: function (groupName) {\n    var group = this[groupName];\n\n    if (group) {\n      group.dispose();\n      this[groupName] = null;\n    }\n  },\n  updateOptions: function (newOptions, settings) {\n    var that = this;\n    var widgetType = newOptions.widgetType;\n    var oldType = that.type;\n    var newType = newOptions.type;\n    that.type = newType && _normalizeEnum(newType.toString());\n\n    if (!that._checkType(widgetType) || that._checkPolarBarType(widgetType, newOptions)) {\n      that.dispose();\n      that.isUpdated = false;\n      return;\n    }\n\n    if (oldType !== that.type) {\n      that._firstDrawing = true;\n\n      that._resetType(oldType, widgetType);\n\n      that._setType(that.type, widgetType);\n    } else {\n      that._defineDrawingState();\n    }\n\n    that._options = newOptions;\n    that._pointOptions = null;\n    that.name = newOptions.name;\n    that.pane = newOptions.pane;\n    that.tag = newOptions.tag;\n\n    if (settings) {\n      that._seriesModes = settings.commonSeriesModes || that._seriesModes;\n      that._valueAxis = settings.valueAxis || that._valueAxis;\n      that.axis = that._valueAxis && that._valueAxis.name;\n      that._argumentAxis = settings.argumentAxis || that._argumentAxis;\n    }\n\n    that._createStyles(newOptions);\n\n    that._stackName = null;\n\n    that._updateOptions(newOptions);\n\n    that._visible = newOptions.visible;\n    that.isUpdated = true;\n    that.stack = newOptions.stack;\n    that.barOverlapGroup = newOptions.barOverlapGroup;\n\n    that._createGroups();\n\n    that._processEmptyValue = newOptions.ignoreEmptyPoints ? function (x) {\n      return null === x ? void 0 : x;\n    } : function (x) {\n      return x;\n    };\n  },\n  _defineDrawingState: function () {\n    this._firstDrawing = true;\n  },\n  _disposePoints: function (points) {\n    _each(points || [], function (_, p) {\n      p.dispose();\n    });\n  },\n  updateDataType: function (settings) {\n    var that = this;\n    that.argumentType = settings.argumentType;\n    that.valueType = settings.valueType;\n    that.argumentAxisType = settings.argumentAxisType;\n    that.valueAxisType = settings.valueAxisType;\n    that.showZero = settings.showZero;\n    this._argumentChecker = getValueChecker(settings.argumentAxisType, that.getArgumentAxis());\n    this._valueChecker = getValueChecker(settings.valueAxisType, that.getValueAxis());\n    return that;\n  },\n  _argumentChecker: function () {\n    return true;\n  },\n  _valueChecker: function () {\n    return true;\n  },\n  getOptions: function () {\n    return this._options;\n  },\n  _getOldPoint: function (data, oldPointsByArgument, index) {\n    var arg = data.argument && data.argument.valueOf();\n    var point = (oldPointsByArgument[arg] || [])[0];\n\n    if (point) {\n      oldPointsByArgument[arg].splice(0, 1);\n    }\n\n    return point;\n  },\n  updateData: function (data) {\n    var that = this;\n    var options = that._options;\n    var nameField = options.nameField;\n    data = data || [];\n\n    if (data.length) {\n      that._canRenderCompleteHandle = true;\n    }\n\n    var dataSelector = this._getPointDataSelector();\n\n    var itemsWithoutArgument = 0;\n    that._data = data.reduce(function (data, dataItem, index) {\n      var pointDataItem = dataSelector(dataItem);\n\n      if (_isDefined(pointDataItem.argument)) {\n        if (!nameField || dataItem[nameField] === options.nameFieldValue) {\n          pointDataItem.index = index;\n          data.push(pointDataItem);\n        }\n      } else {\n        itemsWithoutArgument++;\n      }\n\n      return data;\n    }, []);\n\n    if (itemsWithoutArgument && itemsWithoutArgument === data.length) {\n      that._incidentOccurred(\"W2002\", [that.name, that.getArgumentField()]);\n    }\n\n    that._endUpdateData();\n  },\n  _getData: function () {\n    var data = this._data || [];\n\n    if (this.useAggregation()) {\n      data = this._resample(this.getArgumentAxis().getAggregationInfo(this._useAllAggregatedPoints, this.argumentAxisType !== DISCRETE ? this.getArgumentRange() : {}), data);\n    }\n\n    return data;\n  },\n  useAggregation: function () {\n    var aggregation = this.getOptions().aggregation;\n    return aggregation && aggregation.enabled;\n  },\n  autoHidePointMarkersEnabled: _noop,\n  usePointsToDefineAutoHiding: _noop,\n  createPoints: function (useAllAggregatedPoints) {\n    this._normalizeUsingAllAggregatedPoints(useAllAggregatedPoints);\n\n    this._createPoints();\n  },\n  _normalizeUsingAllAggregatedPoints: function (useAllAggregatedPoints) {\n    this._useAllAggregatedPoints = this.useAggregation() && (this.argumentAxisType === DISCRETE || (this._data || []).length > 1 && !!useAllAggregatedPoints);\n  },\n  _createPoints: function () {\n    var that = this;\n    var oldPointsByArgument = that.pointsByArgument || {};\n\n    var data = that._getData();\n\n    var points;\n    that.pointsByArgument = {};\n\n    that._calculateErrorBars(data);\n\n    var skippedFields = {};\n    points = data.reduce(function (points, pointDataItem) {\n      if (that._checkData(pointDataItem, skippedFields)) {\n        var pointIndex = points.length;\n\n        var oldPoint = that._getOldPoint(pointDataItem, oldPointsByArgument, pointIndex);\n\n        var point = that._createPoint(pointDataItem, pointIndex, oldPoint);\n\n        points.push(point);\n      }\n\n      return points;\n    }, []);\n\n    for (var field in skippedFields) {\n      if (skippedFields[field] === data.length) {\n        that._incidentOccurred(\"W2002\", [that.name, field]);\n      }\n    }\n\n    Object.keys(oldPointsByArgument).forEach(function (key) {\n      return that._disposePoints(oldPointsByArgument[key]);\n    });\n    that._points = points;\n  },\n  _removeOldSegments: function () {\n    var that = this;\n    var startIndex = that._segments.length;\n\n    _each(that._graphics.splice(startIndex, that._graphics.length) || [], function (_, elem) {\n      that._removeElement(elem);\n    });\n\n    if (that._trackers) {\n      _each(that._trackers.splice(startIndex, that._trackers.length) || [], function (_, elem) {\n        elem.remove();\n      });\n    }\n  },\n  _drawElements: function (animationEnabled, firstDrawing, translateAllPoints) {\n    var that = this;\n    var points = that._points || [];\n\n    var closeSegment = points[0] && points[0].hasValue() && that._options.closed;\n\n    var groupForPoint = {\n      markers: that._markersGroup,\n      errorBars: that._errorBarGroup\n    };\n    var segments;\n    that._drawnPoints = [];\n    that._graphics = that._graphics || [];\n    that._segments = [];\n    segments = points.reduce(function (segments, p) {\n      var segment = segments[segments.length - 1];\n\n      if (!p.translated || translateAllPoints) {\n        p.translate();\n        !translateAllPoints && p.setDefaultCoords();\n      }\n\n      if (p.hasValue() && p.hasCoords()) {\n        translateAllPoints && that._drawPoint({\n          point: p,\n          groups: groupForPoint,\n          hasAnimation: animationEnabled,\n          firstDrawing: firstDrawing\n        });\n        segment.push(p);\n      } else {\n        if (!p.hasValue()) {\n          segment.length && segments.push([]);\n        } else {\n          p.setInvisibility();\n        }\n      }\n\n      return segments;\n    }, [[]]);\n    segments.forEach(function (segment, index) {\n      if (segment.length) {\n        that._drawSegment(segment, animationEnabled, index, closeSegment && index === this.length - 1);\n      }\n    }, segments);\n    that._firstDrawing = points.length ? false : true;\n\n    that._removeOldSegments();\n\n    animationEnabled && that._animate(firstDrawing);\n  },\n  draw: function (animationEnabled, hideLayoutLabels, legendCallback) {\n    var that = this;\n    var firstDrawing = that._firstDrawing;\n    that._legendCallback = legendCallback || that._legendCallback;\n\n    if (!that._visible) {\n      animationEnabled = false;\n\n      that._group.remove();\n\n      return;\n    }\n\n    that._appendInGroup();\n\n    that._applyVisibleArea();\n\n    that._setGroupsSettings(animationEnabled, firstDrawing);\n\n    !firstDrawing && that._drawElements(false, firstDrawing, false);\n\n    that._drawElements(animationEnabled, firstDrawing, true);\n\n    hideLayoutLabels && that.hideLabels();\n\n    if (that.isSelected()) {\n      that._changeStyle(that.lastSelectionMode, void 0, true);\n    } else {\n      if (that.isHovered()) {\n        that._changeStyle(that.lastHoverMode, void 0, true);\n      } else {\n        that._applyStyle(that._styles.normal);\n      }\n    }\n  },\n  _setLabelGroupSettings: function (animationEnabled) {\n    var settings = {\n      \"class\": \"dxc-labels\",\n      \"pointer-events\": \"none\"\n    };\n    this._clipLabels && this._applyElementsClipRect(settings);\n\n    this._applyClearingSettings(settings);\n\n    animationEnabled && (settings.opacity = .001);\n\n    this._labelsGroup.attr(settings).append(this._extGroups.labelsGroup);\n  },\n  _checkType: function (widgetType) {\n    return !!seriesNS.mixins[widgetType][this.type];\n  },\n  _checkPolarBarType: function (widgetType, options) {\n    return \"polar\" === widgetType && options.spiderWidget && this.type.indexOf(\"bar\") !== -1;\n  },\n  _resetType: function (seriesType, widgetType) {\n    var methodName;\n    var methods;\n\n    if (seriesType) {\n      methods = seriesNS.mixins[widgetType][seriesType];\n\n      for (methodName in methods) {\n        delete this[methodName];\n      }\n    }\n  },\n  _setType: function (seriesType, widgetType) {\n    var methodName;\n    var methods = seriesNS.mixins[widgetType][seriesType];\n\n    for (methodName in methods) {\n      this[methodName] = methods[methodName];\n    }\n  },\n  _setPointsView: function (view, target) {\n    this.getPoints().forEach(function (point) {\n      if (target !== point) {\n        point.setView(view);\n      }\n    });\n  },\n  _resetPointsView: function (view, target) {\n    this.getPoints().forEach(function (point) {\n      if (target !== point) {\n        point.resetView(view);\n      }\n    });\n  },\n  _resetNearestPoint: function () {\n    var that = this;\n    that._nearestPoint && null !== that._nearestPoint.series && that._nearestPoint.resetView(HOVER);\n    that._nearestPoint = null;\n  },\n  _setSelectedState: function (mode) {\n    var that = this;\n    that.lastSelectionMode = _normalizeEnum(mode || that._options.selectionMode);\n    that.fullState = that.fullState | SELECTED_STATE;\n\n    that._resetNearestPoint();\n\n    that._changeStyle(that.lastSelectionMode);\n\n    if (that.lastSelectionMode !== NONE_MODE && that.isHovered() && includePointsMode(that.lastHoverMode)) {\n      that._resetPointsView(HOVER);\n    }\n  },\n  _releaseSelectedState: function () {\n    var that = this;\n    that.fullState = that.fullState & ~SELECTED_STATE;\n\n    that._changeStyle(that.lastSelectionMode, SELECTION);\n\n    if (that.lastSelectionMode !== NONE_MODE && that.isHovered() && includePointsMode(that.lastHoverMode)) {\n      that._setPointsView(HOVER);\n    }\n  },\n  isFullStackedSeries: function () {\n    return 0 === this.type.indexOf(\"fullstacked\");\n  },\n  isStackedSeries: function () {\n    return 0 === this.type.indexOf(\"stacked\");\n  },\n  isFinancialSeries: function () {\n    return \"stock\" === this.type || \"candlestick\" === this.type;\n  },\n  _canChangeView: function () {\n    return !this.isSelected() && _normalizeEnum(this._options.hoverMode) !== NONE_MODE;\n  },\n  _changeStyle: function (mode, resetView, skipPoints) {\n    var that = this;\n    var state = that.fullState;\n    var styles = [NORMAL, HOVER, SELECTION, SELECTION];\n\n    if (\"none\" === that.lastHoverMode) {\n      state &= ~HOVER_STATE;\n    }\n\n    if (\"none\" === that.lastSelectionMode) {\n      state &= ~SELECTED_STATE;\n    }\n\n    if (includePointsMode(mode) && !skipPoints) {\n      if (!resetView) {\n        that._setPointsView(styles[state]);\n      } else {\n        that._resetPointsView(resetView);\n      }\n    }\n\n    that._legendCallback([RESET_ITEM, APPLY_HOVER, APPLY_SELECTED, APPLY_SELECTED][state]);\n\n    that._applyStyle(that._styles[styles[state]]);\n  },\n  updateHover: function (x, y) {\n    var that = this;\n    var currentNearestPoint = that._nearestPoint;\n    var point = that.isHovered() && that.lastHoverMode === NEAREST_POINT && that.getNeighborPoint(x, y);\n\n    if (point !== currentNearestPoint && !(that.isSelected() && that.lastSelectionMode !== NONE_MODE)) {\n      that._resetNearestPoint();\n\n      if (point) {\n        point.setView(HOVER);\n        that._nearestPoint = point;\n      }\n    }\n  },\n  _getMainAxisName: function () {\n    return this._options.rotated ? \"X\" : \"Y\";\n  },\n  areLabelsVisible: function () {\n    return !_isDefined(this._options.maxLabelCount) || this._points.length <= this._options.maxLabelCount;\n  },\n  getLabelVisibility: function () {\n    return this.areLabelsVisible() && this._options.label && this._options.label.visible;\n  },\n  customizePoint: function customizePoint(point, pointData) {\n    var that = this;\n    var options = that._options;\n    var customizePoint = options.customizePoint;\n    var customizeObject;\n    var pointOptions;\n    var customLabelOptions;\n    var customOptions;\n    var customizeLabel = options.customizeLabel;\n    var useLabelCustomOptions;\n    var usePointCustomOptions;\n\n    if (customizeLabel && customizeLabel.call) {\n      customizeObject = _extend({\n        seriesName: that.name\n      }, pointData);\n      customizeObject.series = that;\n      customLabelOptions = customizeLabel.call(customizeObject, customizeObject);\n      useLabelCustomOptions = customLabelOptions && !_isEmptyObject(customLabelOptions);\n      customLabelOptions = useLabelCustomOptions ? _extend(true, {}, options.label, customLabelOptions) : null;\n    }\n\n    if (customizePoint && customizePoint.call) {\n      customizeObject = customizeObject || _extend({\n        seriesName: that.name\n      }, pointData);\n      customizeObject.series = that;\n      customOptions = customizePoint.call(customizeObject, customizeObject);\n      usePointCustomOptions = customOptions && !_isEmptyObject(customOptions);\n    }\n\n    if (useLabelCustomOptions || usePointCustomOptions) {\n      pointOptions = that._parsePointOptions(that._preparePointOptions(customOptions), customLabelOptions || options.label, pointData, point);\n      pointOptions.styles.useLabelCustomOptions = useLabelCustomOptions;\n      pointOptions.styles.usePointCustomOptions = usePointCustomOptions;\n      point.updateOptions(pointOptions);\n    }\n  },\n  show: function () {\n    if (!this._visible) {\n      this._changeVisibility(true);\n    }\n  },\n  hide: function () {\n    if (this._visible) {\n      this._changeVisibility(false);\n    }\n  },\n  _changeVisibility: function (visibility) {\n    var that = this;\n    that._visible = that._options.visible = visibility;\n\n    that._updatePointsVisibility();\n\n    that.hidePointTooltip();\n\n    that._options.visibilityChanged(that);\n  },\n  _updatePointsVisibility: _noop,\n  hideLabels: function () {\n    _each(this._points, function (_, point) {\n      point._label.draw(false);\n    });\n  },\n  _parsePointOptions: function (pointOptions, labelOptions, data, point) {\n    var that = this;\n    var options = that._options;\n\n    var styles = that._createPointStyles(pointOptions, data, point);\n\n    var parsedOptions = _extend({}, pointOptions, {\n      type: options.type,\n      rotated: options.rotated,\n      styles: styles,\n      widgetType: options.widgetType,\n      visibilityChanged: options.visibilityChanged\n    });\n\n    parsedOptions.label = getLabelOptions(labelOptions, styles.normal.fill);\n\n    if (that.areErrorBarsVisible()) {\n      parsedOptions.errorBars = options.valueErrorBar;\n    }\n\n    return parsedOptions;\n  },\n  _preparePointOptions: function (customOptions) {\n    var pointOptions = this._getOptionsForPoint();\n\n    return customOptions ? mergePointOptions(pointOptions, customOptions) : pointOptions;\n  },\n  _getMarkerGroupOptions: function () {\n    return _extend(false, {}, this._getOptionsForPoint(), {\n      hoverStyle: {},\n      selectionStyle: {}\n    });\n  },\n  _getAggregationMethod: function (isDiscrete, aggregateByCategory) {\n    var options = this.getOptions().aggregation;\n\n    var method = _normalizeEnum(options.method);\n\n    var customAggregator = \"custom\" === method && options.calculate;\n    var aggregator;\n\n    if (isDiscrete && !aggregateByCategory) {\n      aggregator = function (_ref) {\n        var data = _ref.data;\n        return data[0];\n      };\n    } else {\n      aggregator = this._aggregators[method] || this._aggregators[this._defaultAggregator];\n    }\n\n    return customAggregator || aggregator;\n  },\n  _resample: function (_ref2, data) {\n    var interval = _ref2.interval,\n        ticks = _ref2.ticks,\n        aggregateByCategory = _ref2.aggregateByCategory;\n    var that = this;\n    var isDiscrete = that.argumentAxisType === DISCRETE || that.valueAxisType === DISCRETE;\n    var dataIndex = 0;\n\n    var dataSelector = this._getPointDataSelector();\n\n    var options = that.getOptions();\n\n    var addAggregatedData = function (target, data, aggregationInfo) {\n      if (!data) {\n        return;\n      }\n\n      var processData = function (d) {\n        var pointData = d && dataSelector(d, options);\n\n        if (pointData && that._checkData(pointData)) {\n          pointData.aggregationInfo = aggregationInfo;\n          target.push(pointData);\n        }\n      };\n\n      if (data.length) {\n        data.forEach(processData);\n      } else {\n        processData(data);\n      }\n    };\n\n    var aggregationMethod = this._getAggregationMethod(isDiscrete, aggregateByCategory);\n\n    if (isDiscrete) {\n      if (aggregateByCategory) {\n        var categories = this.getArgumentAxis().getTranslator().getBusinessRange().categories;\n        var groups = categories.reduce(function (g, category) {\n          g[category.valueOf()] = [];\n          return g;\n        }, {});\n        data.forEach(function (dataItem) {\n          groups[dataItem.argument].push(dataItem);\n        });\n        return categories.reduce(function (result, c) {\n          addAggregatedData(result, aggregationMethod({\n            aggregationInterval: null,\n            intervalStart: c,\n            intervalEnd: c,\n            data: groups[c].map(getData)\n          }, that));\n          return result;\n        }, []);\n      } else {\n        return data.reduce(function (result, dataItem, index, data) {\n          result[1].push(dataItem);\n\n          if (index === data.length - 1 || (index + 1) % interval === 0) {\n            var dataInInterval = result[1];\n            var aggregationInfo = {\n              aggregationInterval: interval,\n              data: dataInInterval.map(getData)\n            };\n            addAggregatedData(result[0], aggregationMethod(aggregationInfo, that));\n            result[1] = [];\n          }\n\n          return result;\n        }, [[], []])[0];\n      }\n    }\n\n    var aggregatedData = [];\n\n    for (var i = 1; i < ticks.length; i++) {\n      var intervalEnd = ticks[i];\n      var intervalStart = ticks[i - 1];\n      var dataInInterval = [];\n\n      while (data[dataIndex] && data[dataIndex].argument < intervalEnd) {\n        if (data[dataIndex].argument >= intervalStart) {\n          dataInInterval.push(data[dataIndex]);\n        }\n\n        dataIndex++;\n      }\n\n      var aggregationInfo = {\n        intervalStart: intervalStart,\n        intervalEnd: intervalEnd,\n        aggregationInterval: interval,\n        data: dataInInterval.map(getData)\n      };\n      addAggregatedData(aggregatedData, aggregationMethod(aggregationInfo, that), aggregationInfo);\n    }\n\n    that._endUpdateData();\n\n    return aggregatedData;\n  },\n  canRenderCompleteHandle: function () {\n    var result = this._canRenderCompleteHandle;\n    delete this._canRenderCompleteHandle;\n    return !!result;\n  },\n  isHovered: function () {\n    return !!(1 & this.fullState);\n  },\n  isSelected: function () {\n    return !!(2 & this.fullState);\n  },\n  isVisible: function () {\n    return this._visible;\n  },\n  getAllPoints: function () {\n    this._createAllAggregatedPoints();\n\n    return (this._points || []).slice();\n  },\n  getPointByPos: function (pos) {\n    this._createAllAggregatedPoints();\n\n    return (this._points || [])[pos];\n  },\n  getVisiblePoints: function () {\n    return (this._drawnPoints || []).slice();\n  },\n  selectPoint: function (point) {\n    if (!point.isSelected()) {\n      setPointSelectedState(point, this._legendCallback);\n\n      this._eventPipe({\n        action: POINT_SELECT,\n        target: point\n      });\n\n      this._eventTrigger(POINT_SELECTION_CHANGED, {\n        target: point\n      });\n    }\n  },\n  deselectPoint: function (point) {\n    if (point.isSelected()) {\n      releasePointSelectedState(point, this._legendCallback);\n\n      this._eventPipe({\n        action: POINT_DESELECT,\n        target: point\n      });\n\n      this._eventTrigger(POINT_SELECTION_CHANGED, {\n        target: point\n      });\n    }\n  },\n  hover: function (mode) {\n    var that = this;\n    var eventTrigger = that._eventTrigger;\n\n    if (that.isHovered()) {\n      return;\n    }\n\n    that.lastHoverMode = _normalizeEnum(mode || that._options.hoverMode);\n    that.fullState = that.fullState | HOVER_STATE;\n\n    that._changeStyle(that.lastHoverMode, void 0, that.isSelected() && that.lastSelectionMode !== NONE_MODE);\n\n    eventTrigger(SERIES_HOVER_CHANGED, {\n      target: that\n    });\n  },\n  clearHover: function () {\n    var that = this;\n    var eventTrigger = that._eventTrigger;\n\n    if (!that.isHovered()) {\n      return;\n    }\n\n    that._resetNearestPoint();\n\n    that.fullState = that.fullState & ~HOVER_STATE;\n\n    that._changeStyle(that.lastHoverMode, HOVER, that.isSelected() && that.lastSelectionMode !== NONE_MODE);\n\n    eventTrigger(SERIES_HOVER_CHANGED, {\n      target: that\n    });\n  },\n  hoverPoint: function (point) {\n    var that = this;\n\n    if (!point.isHovered()) {\n      point.clearHover();\n      setPointHoverState(point, that._legendCallback);\n      that._canChangeView() && that._applyStyle(that._styles.hover);\n\n      that._eventPipe({\n        action: POINT_HOVER,\n        target: point\n      });\n\n      that._eventTrigger(POINT_HOVER_CHANGED, {\n        target: point\n      });\n    }\n  },\n  clearPointHover: function () {\n    var that = this;\n    that.getPoints().some(function (currentPoint) {\n      if (currentPoint.isHovered()) {\n        releasePointHoverState(currentPoint, that._legendCallback);\n        that._canChangeView() && that._applyStyle(that._styles.normal);\n\n        that._eventPipe({\n          action: CLEAR_POINT_HOVER,\n          target: currentPoint\n        });\n\n        that._eventTrigger(POINT_HOVER_CHANGED, {\n          target: currentPoint\n        });\n\n        return true;\n      }\n\n      return false;\n    });\n  },\n  showPointTooltip: function (point) {\n    triggerEvent(this._extGroups.seriesGroup, \"showpointtooltip\", point);\n  },\n  hidePointTooltip: function (point) {\n    triggerEvent(this._extGroups.seriesGroup, \"hidepointtooltip\", point);\n  },\n  select: function () {\n    var that = this;\n\n    if (!that.isSelected()) {\n      that._setSelectedState(that._options.selectionMode);\n\n      that._eventPipe({\n        action: SERIES_SELECT,\n        target: that\n      });\n\n      that._group.toForeground();\n\n      that._eventTrigger(SERIES_SELECTION_CHANGED, {\n        target: that\n      });\n    }\n  },\n  clearSelection: function () {\n    var that = this;\n\n    if (that.isSelected()) {\n      that._releaseSelectedState();\n\n      that._eventTrigger(SERIES_SELECTION_CHANGED, {\n        target: that\n      });\n    }\n  },\n  getPointsByArg: function (arg, skipPointsCreation) {\n    var that = this;\n    var argValue = arg.valueOf();\n    var points = that.pointsByArgument[argValue];\n\n    if (!points && !skipPointsCreation && that._createAllAggregatedPoints()) {\n      points = that.pointsByArgument[argValue];\n    }\n\n    return points || [];\n  },\n  _createAllAggregatedPoints: function () {\n    if (this.useAggregation() && !this._useAllAggregatedPoints) {\n      this.createPoints(true);\n      return true;\n    }\n\n    return false;\n  },\n  getPointsByKeys: function (arg) {\n    return this.getPointsByArg(arg);\n  },\n  notify: function (data) {\n    var that = this;\n    var action = data.action;\n    var seriesModes = that._seriesModes;\n    var target = data.target;\n    var targetOptions = target.getOptions();\n\n    var pointHoverMode = _normalizeEnum(targetOptions.hoverMode);\n\n    var selectionModeOfPoint = _normalizeEnum(targetOptions.selectionMode);\n\n    if (action === POINT_HOVER) {\n      that._hoverPointHandler(target, pointHoverMode, data.notifyLegend);\n    } else {\n      if (action === CLEAR_POINT_HOVER) {\n        that._clearPointHoverHandler(target, pointHoverMode, data.notifyLegend);\n      } else {\n        if (action === SERIES_SELECT) {\n          target !== that && \"single\" === seriesModes.seriesSelectionMode && that.clearSelection();\n        } else {\n          if (action === POINT_SELECT) {\n            if (\"single\" === seriesModes.pointSelectionMode) {\n              that.getPoints().some(function (currentPoint) {\n                if (currentPoint !== target && currentPoint.isSelected()) {\n                  that.deselectPoint(currentPoint);\n                  return true;\n                }\n\n                return false;\n              });\n            }\n\n            that._selectPointHandler(target, selectionModeOfPoint);\n          } else {\n            if (action === POINT_DESELECT) {\n              that._deselectPointHandler(target, selectionModeOfPoint);\n            }\n          }\n        }\n      }\n    }\n  },\n  _selectPointHandler: function (target, mode) {\n    var that = this;\n\n    if (mode === ALL_SERIES_POINTS) {\n      target.series === that && that._setPointsView(SELECTION, target);\n    } else {\n      if (mode === ALL_ARGUMENT_POINTS) {\n        that.getPointsByKeys(target.argument, target.argumentIndex).forEach(function (currentPoint) {\n          currentPoint !== target && currentPoint.setView(SELECTION);\n        });\n      }\n    }\n  },\n  _deselectPointHandler: function (target, mode) {\n    if (mode === ALL_SERIES_POINTS) {\n      target.series === this && this._resetPointsView(SELECTION, target);\n    } else {\n      if (mode === ALL_ARGUMENT_POINTS) {\n        this.getPointsByKeys(target.argument, target.argumentIndex).forEach(function (currentPoint) {\n          currentPoint !== target && currentPoint.resetView(SELECTION);\n        });\n      }\n    }\n  },\n  _hoverPointHandler: function (target, mode, notifyLegend) {\n    var that = this;\n\n    if (target.series !== that && mode === ALL_ARGUMENT_POINTS) {\n      that.getPointsByKeys(target.argument, target.argumentIndex).forEach(function (currentPoint) {\n        currentPoint.setView(HOVER);\n      });\n      notifyLegend && that._legendCallback(target);\n    } else {\n      if (mode === ALL_SERIES_POINTS && target.series === that) {\n        that._setPointsView(HOVER, target);\n      }\n    }\n  },\n  _clearPointHoverHandler: function (target, mode, notifyLegend) {\n    var that = this;\n\n    if (mode === ALL_ARGUMENT_POINTS) {\n      target.series !== that && that.getPointsByKeys(target.argument, target.argumentIndex).forEach(function (currentPoint) {\n        currentPoint.resetView(HOVER);\n      });\n      notifyLegend && that._legendCallback(target);\n    } else {\n      if (mode === ALL_SERIES_POINTS && target.series === that) {\n        that._resetPointsView(HOVER, target);\n      }\n    }\n  },\n  _deletePoints: function () {\n    var that = this;\n\n    that._disposePoints(that._points);\n\n    that._points = that._drawnPoints = null;\n  },\n  _deleteTrackers: function () {\n    var that = this;\n\n    _each(that._trackers || [], function (_, tracker) {\n      tracker.remove();\n    });\n\n    that._trackersGroup && that._trackersGroup.dispose();\n    that._trackers = that._trackersGroup = null;\n  },\n  dispose: function () {\n    var that = this;\n\n    that._deletePoints();\n\n    that._group.dispose();\n\n    that._labelsGroup && that._labelsGroup.dispose();\n    that._errorBarGroup && that._errorBarGroup.dispose();\n\n    that._deleteTrackers();\n\n    that._group = that._extGroups = that._markersGroup = that._elementsGroup = that._bordersGroup = that._labelsGroup = that._errorBarGroup = that._graphics = that._rangeData = that._renderer = that._styles = that._options = that._pointOptions = that._drawnPoints = that.pointsByArgument = that._segments = that._prevSeries = null;\n  },\n  correctPosition: _noop,\n  drawTrackers: _noop,\n  getNeighborPoint: _noop,\n  areErrorBarsVisible: _noop,\n  getMarginOptions: function () {\n    return this._patchMarginOptions({\n      percentStick: this.isFullStackedSeries()\n    });\n  },\n  getColor: function () {\n    return this.getLegendStyles().normal.fill;\n  },\n  getOpacity: function () {\n    return this._options.opacity;\n  },\n  getStackName: function () {\n    return this._stackName;\n  },\n  getBarOverlapGroup: function () {\n    return this._options.barOverlapGroup;\n  },\n  getPointByCoord: function (x, y) {\n    var point = this.getNeighborPoint(x, y);\n    return point && point.coordsIn(x, y) ? point : null;\n  },\n  getValueAxis: function () {\n    return this._valueAxis;\n  },\n  getArgumentAxis: function () {\n    return this._argumentAxis;\n  },\n  getMarkersGroup: function () {\n    return this._markersGroup;\n  },\n  getRenderer: function () {\n    return this._renderer;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}