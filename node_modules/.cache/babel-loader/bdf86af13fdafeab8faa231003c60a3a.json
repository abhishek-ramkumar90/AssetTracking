{"ast":null,"code":"/**\r\n * DevExtreme (viz/series/scatter_series.js)\r\n * Version: 19.2.7\r\n * Build date: Thu Mar 26 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar _extend = require(\"../../core/utils/extend\").extend;\n\nvar inArray = require(\"../../core/utils/array\").inArray;\n\nvar _each = require(\"../../core/utils/iterator\").each;\n\nvar rangeCalculator = require(\"./helpers/range_data_calculator\");\n\nvar typeUtils = require(\"../../core/utils/type\");\n\nvar vizUtils = require(\"../core/utils\");\n\nvar _noop = require(\"../../core/utils/common\").noop;\n\nvar _isDefined = typeUtils.isDefined;\nvar _isString = typeUtils.isString;\nvar _map = vizUtils.map;\nvar _normalizeEnum = vizUtils.normalizeEnum;\nvar math = Math;\nvar _abs = math.abs;\nvar _sqrt = math.sqrt;\nvar _max = math.max;\nvar DEFAULT_TRACKER_WIDTH = 12;\nvar DEFAULT_DURATION = 400;\nvar HIGH_ERROR = \"highError\";\nvar LOW_ERROR = \"lowError\";\nvar VARIANCE = \"variance\";\nvar STANDARD_DEVIATION = \"stddeviation\";\nvar STANDARD_ERROR = \"stderror\";\nvar PERCENT = \"percent\";\nvar FIXED = \"fixed\";\nvar UNDEFINED = \"undefined\";\nvar DISCRETE = \"discrete\";\nvar LOGARITHMIC = \"logarithmic\";\nvar DATETIME = \"datetime\";\nexports.chart = {};\nexports.polar = {};\n\nfunction sum(array) {\n  var result = 0;\n\n  _each(array, function (_, value) {\n    result += value;\n  });\n\n  return result;\n}\n\nfunction isErrorBarTypeCorrect(type) {\n  return inArray(type, [FIXED, PERCENT, VARIANCE, STANDARD_DEVIATION, STANDARD_ERROR]) !== -1;\n}\n\nfunction variance(array, expectedValue) {\n  return sum(_map(array, function (value) {\n    return (value - expectedValue) * (value - expectedValue);\n  })) / array.length;\n}\n\nfunction calculateAvgErrorBars(result, data, series) {\n  var errorBarsOptions = series.getOptions().valueErrorBar;\n  var valueField = series.getValueFields()[0];\n  var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;\n  var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;\n\n  if (series.areErrorBarsVisible() && void 0 === errorBarsOptions.type) {\n    var fusionData = data.reduce(function (result, item) {\n      if (_isDefined(item[lowValueField])) {\n        result[0] += item[valueField] - item[lowValueField];\n        result[1]++;\n      }\n\n      if (_isDefined(item[highValueField])) {\n        result[2] += item[highValueField] - item[valueField];\n        result[3]++;\n      }\n\n      return result;\n    }, [0, 0, 0, 0]);\n\n    if (fusionData[1]) {\n      result[lowValueField] = result[valueField] - fusionData[0] / fusionData[1];\n    }\n\n    if (fusionData[2]) {\n      result[highValueField] = result[valueField] + fusionData[2] / fusionData[3];\n    }\n  }\n\n  return result;\n}\n\nfunction calculateSumErrorBars(result, data, series) {\n  var errorBarsOptions = series.getOptions().valueErrorBar;\n  var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;\n  var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;\n\n  if (series.areErrorBarsVisible() && void 0 === errorBarsOptions.type) {\n    result[lowValueField] = 0;\n    result[highValueField] = 0;\n    result = data.reduce(function (result, item) {\n      result[lowValueField] += item[lowValueField];\n      result[highValueField] += item[highValueField];\n      return result;\n    }, result);\n  }\n\n  return result;\n}\n\nfunction getMinMaxAggregator(compare) {\n  return function (_ref, series) {\n    var intervalStart = _ref.intervalStart,\n        data = _ref.data;\n    var valueField = series.getValueFields()[0];\n    var targetData = data[0];\n    targetData = data.reduce(function (result, item) {\n      var value = item[valueField];\n\n      if (null === result[valueField]) {\n        result = item;\n      }\n\n      if (null !== value && compare(value, result[valueField])) {\n        return item;\n      }\n\n      return result;\n    }, targetData);\n    return _extend({}, targetData, _defineProperty({}, series.getArgumentField(), intervalStart));\n  };\n}\n\nfunction checkFields(data, fieldsToCheck, skippedFields) {\n  var allFieldsIsValid = true;\n\n  for (var field in fieldsToCheck) {\n    var isArgument = \"argument\" === field;\n\n    if (isArgument || \"size\" === field ? !_isDefined(data[field]) : void 0 === data[field]) {\n      var selector = fieldsToCheck[field];\n\n      if (!isArgument) {\n        skippedFields[selector] = (skippedFields[selector] || 0) + 1;\n      }\n\n      allFieldsIsValid = false;\n    }\n  }\n\n  return allFieldsIsValid;\n}\n\nvar baseScatterMethods = {\n  _defaultDuration: DEFAULT_DURATION,\n  _defaultTrackerWidth: DEFAULT_TRACKER_WIDTH,\n  _applyStyle: _noop,\n  _updateOptions: _noop,\n  _parseStyle: _noop,\n  _prepareSegment: _noop,\n  _drawSegment: _noop,\n  _appendInGroup: function () {\n    this._group.append(this._extGroups.seriesGroup);\n  },\n  _createLegendState: function (styleOptions, defaultColor) {\n    return {\n      fill: styleOptions.color || defaultColor,\n      hatching: styleOptions.hatching ? _extend({}, styleOptions.hatching, {\n        direction: \"right\"\n      }) : void 0\n    };\n  },\n  _applyElementsClipRect: function (settings) {\n    settings[\"clip-path\"] = this._paneClipRectID;\n  },\n  _applyMarkerClipRect: function (settings) {\n    settings[\"clip-path\"] = this._forceClipping ? this._paneClipRectID : null;\n  },\n  _createGroup: function (groupName, parent, target, settings) {\n    var group = parent[groupName] = parent[groupName] || this._renderer.g();\n\n    target && group.append(target);\n    settings && group.attr(settings);\n  },\n  _applyClearingSettings: function (settings) {\n    settings.opacity = null;\n    settings.scale = null;\n\n    if (this._options.rotated) {\n      settings.translateX = null;\n    } else {\n      settings.translateY = null;\n    }\n  },\n  _createGroups: function () {\n    var that = this;\n\n    that._createGroup(\"_markersGroup\", that, that._group);\n\n    that._createGroup(\"_labelsGroup\", that);\n  },\n  _setMarkerGroupSettings: function () {\n    var that = this;\n\n    var settings = that._createPointStyles(that._getMarkerGroupOptions()).normal;\n\n    settings.class = \"dxc-markers\";\n    settings.opacity = 1;\n\n    that._applyMarkerClipRect(settings);\n\n    that._markersGroup.attr(settings);\n  },\n  getVisibleArea: function () {\n    return this._visibleArea;\n  },\n  areErrorBarsVisible: function () {\n    var errorBarOptions = this._options.valueErrorBar;\n    return errorBarOptions && this._errorBarsEnabled() && \"none\" !== errorBarOptions.displayMode && (isErrorBarTypeCorrect(_normalizeEnum(errorBarOptions.type)) || _isDefined(errorBarOptions.lowValueField) || _isDefined(errorBarOptions.highValueField));\n  },\n  groupPointsByCoords: function (rotated) {\n    var cat = [];\n\n    _each(this.getVisiblePoints(), function (_, p) {\n      var pointCoord = parseInt(rotated ? p.vy : p.vx);\n\n      if (!cat[pointCoord]) {\n        cat[pointCoord] = p;\n      } else {\n        Array.isArray(cat[pointCoord]) ? cat[pointCoord].push(p) : cat[pointCoord] = [cat[pointCoord], p];\n      }\n    });\n\n    return cat;\n  },\n  _createErrorBarGroup: function (animationEnabled) {\n    var that = this;\n    var errorBarOptions = that._options.valueErrorBar;\n    var settings;\n\n    if (that.areErrorBarsVisible()) {\n      settings = {\n        \"class\": \"dxc-error-bars\",\n        stroke: errorBarOptions.color,\n        \"stroke-width\": errorBarOptions.lineWidth,\n        opacity: animationEnabled ? .001 : errorBarOptions.opacity || 1,\n        \"stroke-linecap\": \"square\",\n        sharp: true,\n        \"clip-path\": that._forceClipping ? that._paneClipRectID : that._widePaneClipRectID\n      };\n\n      that._createGroup(\"_errorBarGroup\", that, that._group, settings);\n    }\n  },\n  _setGroupsSettings: function (animationEnabled) {\n    var that = this;\n\n    that._setMarkerGroupSettings();\n\n    that._setLabelGroupSettings(animationEnabled);\n\n    that._createErrorBarGroup(animationEnabled);\n  },\n  _getCreatingPointOptions: function () {\n    var that = this;\n    var defaultPointOptions;\n    var creatingPointOptions = that._predefinedPointOptions;\n    var normalStyle;\n\n    if (!creatingPointOptions) {\n      defaultPointOptions = that._getPointOptions();\n      that._predefinedPointOptions = creatingPointOptions = _extend(true, {\n        styles: {}\n      }, defaultPointOptions);\n      normalStyle = defaultPointOptions.styles && defaultPointOptions.styles.normal || {};\n      creatingPointOptions.styles = creatingPointOptions.styles || {};\n      creatingPointOptions.styles.normal = {\n        \"stroke-width\": normalStyle[\"stroke-width\"],\n        r: normalStyle.r,\n        opacity: normalStyle.opacity\n      };\n    }\n\n    return creatingPointOptions;\n  },\n  _getPointOptions: function () {\n    return this._parsePointOptions(this._preparePointOptions(), this._options.label);\n  },\n  _getOptionsForPoint: function () {\n    return this._options.point;\n  },\n  _parsePointStyle: function (style, defaultColor, defaultBorderColor, defaultSize) {\n    var border = style.border || {};\n    var sizeValue = void 0 !== style.size ? style.size : defaultSize;\n    return {\n      fill: style.color || defaultColor,\n      stroke: border.color || defaultBorderColor,\n      \"stroke-width\": border.visible ? border.width : 0,\n      r: sizeValue / 2 + (border.visible && 0 !== sizeValue ? ~~(border.width / 2) || 0 : 0)\n    };\n  },\n  _createPointStyles: function (pointOptions) {\n    var that = this;\n    var mainPointColor = pointOptions.color || that._options.mainSeriesColor;\n    var containerColor = that._options.containerBackgroundColor;\n\n    var normalStyle = that._parsePointStyle(pointOptions, mainPointColor, mainPointColor);\n\n    normalStyle.visibility = pointOptions.visible ? \"visible\" : \"hidden\";\n    return {\n      normal: normalStyle,\n      hover: that._parsePointStyle(pointOptions.hoverStyle, containerColor, mainPointColor, pointOptions.size),\n      selection: that._parsePointStyle(pointOptions.selectionStyle, containerColor, mainPointColor, pointOptions.size)\n    };\n  },\n  _checkData: function (data, skippedFields, fieldsToCheck) {\n    fieldsToCheck = fieldsToCheck || {\n      value: this.getValueFields()[0]\n    };\n    fieldsToCheck.argument = this.getArgumentField();\n    return checkFields(data, fieldsToCheck, skippedFields || {}) && data.value === data.value;\n  },\n  getValueRangeInitialValue: function () {\n    return;\n  },\n  _getRangeData: function () {\n    return rangeCalculator.getRangeData(this);\n  },\n  _getPointDataSelector: function () {\n    var _this = this;\n\n    var valueField = this.getValueFields()[0];\n    var argumentField = this.getArgumentField();\n    var tagField = this.getTagField();\n    var areErrorBarsVisible = this.areErrorBarsVisible();\n    var lowValueField;\n    var highValueField;\n\n    if (areErrorBarsVisible) {\n      var errorBarOptions = this._options.valueErrorBar;\n      lowValueField = errorBarOptions.lowValueField || LOW_ERROR;\n      highValueField = errorBarOptions.highValueField || HIGH_ERROR;\n    }\n\n    return function (data) {\n      var pointData = {\n        value: _this._processEmptyValue(data[valueField]),\n        argument: data[argumentField],\n        tag: data[tagField],\n        data: data\n      };\n\n      if (areErrorBarsVisible) {\n        pointData.lowError = data[lowValueField];\n        pointData.highError = data[highValueField];\n      }\n\n      return pointData;\n    };\n  },\n  _errorBarsEnabled: function () {\n    return this.valueAxisType !== DISCRETE && this.valueAxisType !== LOGARITHMIC && this.valueType !== DATETIME;\n  },\n  _drawPoint: function (options) {\n    var point = options.point;\n\n    if (point.isInVisibleArea()) {\n      point.clearVisibility();\n      point.draw(this._renderer, options.groups, options.hasAnimation, options.firstDrawing);\n\n      this._drawnPoints.push(point);\n    } else {\n      point.setInvisibility();\n    }\n  },\n  _animateComplete: function () {\n    var that = this;\n    var animationSettings = {\n      duration: that._defaultDuration\n    };\n    that._labelsGroup && that._labelsGroup.animate({\n      opacity: 1\n    }, animationSettings);\n    that._errorBarGroup && that._errorBarGroup.animate({\n      opacity: that._options.valueErrorBar.opacity || 1\n    }, animationSettings);\n  },\n  _animate: function () {\n    var that = this;\n    var lastPointIndex = that._drawnPoints.length - 1;\n\n    _each(that._drawnPoints || [], function (i, p) {\n      p.animate(i === lastPointIndex ? function () {\n        that._animateComplete();\n      } : void 0, {\n        translateX: p.x,\n        translateY: p.y\n      });\n    });\n  },\n  _defaultAggregator: \"avg\",\n  _aggregators: {\n    avg: function (_ref2, series) {\n      var _calculateAvgErrorBar;\n\n      var data = _ref2.data,\n          intervalStart = _ref2.intervalStart;\n\n      if (!data.length) {\n        return;\n      }\n\n      var valueField = series.getValueFields()[0];\n      var aggregationResult = data.reduce(function (result, item) {\n        var value = item[valueField];\n\n        if (_isDefined(value)) {\n          result[0] += value;\n          result[1]++;\n        } else {\n          if (null === value) {\n            result[2]++;\n          }\n        }\n\n        return result;\n      }, [0, 0, 0]);\n      return calculateAvgErrorBars((_calculateAvgErrorBar = {}, _defineProperty(_calculateAvgErrorBar, valueField, aggregationResult[2] === data.length ? null : aggregationResult[0] / aggregationResult[1]), _defineProperty(_calculateAvgErrorBar, series.getArgumentField(), intervalStart), _calculateAvgErrorBar), data, series);\n    },\n    sum: function (_ref3, series) {\n      var _calculateSumErrorBar;\n\n      var intervalStart = _ref3.intervalStart,\n          data = _ref3.data;\n\n      if (!data.length) {\n        return;\n      }\n\n      var valueField = series.getValueFields()[0];\n      var aggregationResult = data.reduce(function (result, item) {\n        var value = item[valueField];\n\n        if (void 0 !== value) {\n          result[0] += value;\n        }\n\n        if (null === value) {\n          result[1]++;\n        } else {\n          if (void 0 === value) {\n            result[2]++;\n          }\n        }\n\n        return result;\n      }, [0, 0, 0]);\n      var value = aggregationResult[0];\n\n      if (aggregationResult[1] === data.length) {\n        value = null;\n      }\n\n      if (aggregationResult[2] === data.length) {\n        return;\n      }\n\n      return calculateSumErrorBars((_calculateSumErrorBar = {}, _defineProperty(_calculateSumErrorBar, valueField, value), _defineProperty(_calculateSumErrorBar, series.getArgumentField(), intervalStart), _calculateSumErrorBar), data, series);\n    },\n    count: function (_ref4, series) {\n      var _ref5;\n\n      var data = _ref4.data,\n          intervalStart = _ref4.intervalStart;\n      var valueField = series.getValueFields()[0];\n      return _ref5 = {}, _defineProperty(_ref5, series.getArgumentField(), intervalStart), _defineProperty(_ref5, valueField, data.filter(function (i) {\n        return void 0 !== i[valueField];\n      }).length), _ref5;\n    },\n    min: getMinMaxAggregator(function (a, b) {\n      return a < b;\n    }),\n    max: getMinMaxAggregator(function (a, b) {\n      return a > b;\n    })\n  },\n  _endUpdateData: function () {\n    delete this._predefinedPointOptions;\n  },\n  getArgumentField: function () {\n    return this._options.argumentField || \"arg\";\n  },\n  getValueFields: function () {\n    var options = this._options;\n    var errorBarsOptions = options.valueErrorBar;\n    var valueFields = [options.valueField || \"val\"];\n    var lowValueField;\n    var highValueField;\n\n    if (errorBarsOptions) {\n      lowValueField = errorBarsOptions.lowValueField;\n      highValueField = errorBarsOptions.highValueField;\n      _isString(lowValueField) && valueFields.push(lowValueField);\n      _isString(highValueField) && valueFields.push(highValueField);\n    }\n\n    return valueFields;\n  },\n  _calculateErrorBars: function (data) {\n    if (!this.areErrorBarsVisible()) {\n      return;\n    }\n\n    var that = this;\n    var options = that._options;\n    var errorBarsOptions = options.valueErrorBar;\n\n    var errorBarType = _normalizeEnum(errorBarsOptions.type);\n\n    var floatErrorValue = parseFloat(errorBarsOptions.value);\n    var valueField = that.getValueFields()[0];\n    var value;\n    var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;\n    var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;\n    var valueArray;\n    var valueArrayLength;\n    var meanValue;\n    var processDataItem;\n\n    var addSubError = function (_i, item) {\n      value = item.value;\n      item.lowError = value - floatErrorValue;\n      item.highError = value + floatErrorValue;\n    };\n\n    switch (errorBarType) {\n      case FIXED:\n        processDataItem = addSubError;\n        break;\n\n      case PERCENT:\n        processDataItem = function (_, item) {\n          value = item.value;\n          var error = value * floatErrorValue / 100;\n          item.lowError = value - error;\n          item.highError = value + error;\n        };\n\n        break;\n\n      case UNDEFINED:\n        processDataItem = function (_, item) {\n          item.lowError = item.data[lowValueField];\n          item.highError = item.data[highValueField];\n        };\n\n        break;\n\n      default:\n        valueArray = _map(data, function (item) {\n          return _isDefined(item.data[valueField]) ? item.data[valueField] : null;\n        });\n        valueArrayLength = valueArray.length;\n        floatErrorValue = floatErrorValue || 1;\n\n        switch (errorBarType) {\n          case VARIANCE:\n            floatErrorValue = variance(valueArray, sum(valueArray) / valueArrayLength) * floatErrorValue;\n            processDataItem = addSubError;\n            break;\n\n          case STANDARD_DEVIATION:\n            meanValue = sum(valueArray) / valueArrayLength;\n            floatErrorValue = _sqrt(variance(valueArray, meanValue)) * floatErrorValue;\n\n            processDataItem = function (_, item) {\n              item.lowError = meanValue - floatErrorValue;\n              item.highError = meanValue + floatErrorValue;\n            };\n\n            break;\n\n          case STANDARD_ERROR:\n            floatErrorValue = _sqrt(variance(valueArray, sum(valueArray) / valueArrayLength) / valueArrayLength) * floatErrorValue;\n            processDataItem = addSubError;\n        }\n\n    }\n\n    processDataItem && _each(data, processDataItem);\n  },\n  _patchMarginOptions: function (options) {\n    var pointOptions = this._getCreatingPointOptions();\n\n    var styles = pointOptions.styles;\n    var maxSize = [styles.normal, styles.hover, styles.selection].reduce(function (max, style) {\n      return _max(max, 2 * style.r + style[\"stroke-width\"]);\n    }, 0);\n    options.size = pointOptions.visible ? maxSize : 0;\n    options.sizePointNormalState = pointOptions.visible ? 2 * styles.normal.r + styles.normal[\"stroke-width\"] : 2;\n    return options;\n  },\n  usePointsToDefineAutoHiding: function () {\n    return true;\n  }\n};\nexports.chart = _extend({}, baseScatterMethods, {\n  drawTrackers: function () {\n    var that = this;\n    var trackers;\n    var trackersGroup;\n    var segments = that._segments || [];\n    var rotated = that._options.rotated;\n\n    if (!that.isVisible()) {\n      return;\n    }\n\n    if (segments.length) {\n      trackers = that._trackers = that._trackers || [];\n      trackersGroup = that._trackersGroup = (that._trackersGroup || that._renderer.g().attr({\n        fill: \"gray\",\n        opacity: .001,\n        stroke: \"gray\",\n        \"class\": \"dxc-trackers\"\n      })).attr({\n        \"clip-path\": this._paneClipRectID || null\n      }).append(that._group);\n\n      _each(segments, function (i, segment) {\n        if (!trackers[i]) {\n          trackers[i] = that._drawTrackerElement(segment).data({\n            \"chart-data-series\": that\n          }).append(trackersGroup);\n        } else {\n          that._updateTrackerElement(segment, trackers[i]);\n        }\n      });\n    }\n\n    that._trackersTranslator = that.groupPointsByCoords(rotated);\n  },\n  checkAxisVisibleAreaCoord: function (isArgument, coord) {\n    var axis = isArgument ? this.getArgumentAxis() : this.getValueAxis();\n    var visibleArea = axis.getVisibleArea();\n    return _isDefined(coord) && visibleArea[0] <= coord && visibleArea[1] >= coord;\n  },\n  checkSeriesViewportCoord: function (axis, coord) {\n    return true;\n  },\n  getSeriesPairCoord: function (coord, isArgument) {\n    var oppositeCoord = null;\n    var isOpposite = !isArgument && !this._options.rotated || isArgument && this._options.rotated;\n    var coordName = !isOpposite ? \"vx\" : \"vy\";\n    var oppositeCoordName = !isOpposite ? \"vy\" : \"vx\";\n    var points = this.getVisiblePoints();\n\n    for (var i = 0; i < points.length; i++) {\n      var p = points[i];\n      var tmpCoord = p[coordName] === coord ? p[oppositeCoordName] : void 0;\n\n      if (this.checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\n        oppositeCoord = tmpCoord;\n        break;\n      }\n    }\n\n    return oppositeCoord;\n  },\n  getNearestPointsByCoord: function (coord, isArgument) {\n    var that = this;\n    var rotated = that.getOptions().rotated;\n    var isOpposite = !isArgument && !rotated || isArgument && rotated;\n    var coordName = isOpposite ? \"vy\" : \"vx\";\n    var points = that.getVisiblePoints();\n    var allPoints = that.getPoints();\n    var nearestPoints = [];\n\n    if (that.isVisible() && allPoints.length > 0) {\n      if (allPoints.length > 1) {\n        that.findNeighborPointsByCoord(coord, coordName, points.slice(0), allPoints, function (point, nextPoint) {\n          nearestPoints.push([point, nextPoint]);\n        });\n      } else {\n        if (allPoints[0][coordName] === coord) {\n          nearestPoints.push([allPoints[0], allPoints[0]]);\n        }\n      }\n    }\n\n    return nearestPoints;\n  },\n  findNeighborPointsByCoord: function (coord, coordName, points, allPoints, pushNeighborPoints) {\n    var searchPoints = allPoints;\n\n    if (points.length > 0) {\n      points.splice(0, 0, allPoints[allPoints.indexOf(points[0]) - 1]);\n      points.splice(points.length, 0, allPoints[allPoints.indexOf(points[points.length - 1]) + 1]);\n      searchPoints = points;\n    }\n\n    searchPoints.forEach(function (p, i) {\n      var np = searchPoints[i + 1];\n\n      if (p && np && (p[coordName] <= coord && np[coordName] >= coord || p[coordName] >= coord && np[coordName] <= coord)) {\n        pushNeighborPoints(p, np);\n      }\n    });\n  },\n  getNeighborPoint: function (x, y) {\n    var pCoord = this._options.rotated ? y : x;\n    var nCoord = pCoord;\n    var cat = this._trackersTranslator;\n    var point = null;\n    var minDistance;\n    var oppositeCoord = this._options.rotated ? x : y;\n    var oppositeCoordName = this._options.rotated ? \"vx\" : \"vy\";\n\n    if (this.isVisible() && cat) {\n      point = cat[pCoord];\n\n      do {\n        point = cat[nCoord] || cat[pCoord];\n        pCoord--;\n        nCoord++;\n      } while ((pCoord >= 0 || nCoord < cat.length) && !point);\n\n      if (Array.isArray(point)) {\n        minDistance = _abs(point[0][oppositeCoordName] - oppositeCoord);\n\n        _each(point, function (i, p) {\n          var distance = _abs(p[oppositeCoordName] - oppositeCoord);\n\n          if (minDistance >= distance) {\n            minDistance = distance;\n            point = p;\n          }\n        });\n      }\n    }\n\n    return point;\n  },\n  _applyVisibleArea: function () {\n    var that = this;\n    var rotated = that._options.rotated;\n    var visibleX = (rotated ? that.getValueAxis() : that.getArgumentAxis()).getVisibleArea();\n    var visibleY = (rotated ? that.getArgumentAxis() : that.getValueAxis()).getVisibleArea();\n    that._visibleArea = {\n      minX: visibleX[0],\n      maxX: visibleX[1],\n      minY: visibleY[0],\n      maxY: visibleY[1]\n    };\n  },\n  getPointCenterByArg: function (arg) {\n    var point = this.getPointsByArg(arg)[0];\n    return point ? point.getCenterCoord() : void 0;\n  }\n});\nexports.polar = _extend({}, baseScatterMethods, {\n  drawTrackers: function () {\n    exports.chart.drawTrackers.call(this);\n    var cat = this._trackersTranslator;\n    var index;\n\n    if (!this.isVisible()) {\n      return;\n    }\n\n    _each(cat, function (i, category) {\n      if (category) {\n        index = i;\n        return false;\n      }\n    });\n\n    cat[index + 360] = cat[index];\n  },\n  getNeighborPoint: function (x, y) {\n    var pos = vizUtils.convertXYToPolar(this.getValueAxis().getCenter(), x, y);\n    return exports.chart.getNeighborPoint.call(this, pos.phi, pos.r);\n  },\n  _applyVisibleArea: function () {\n    var that = this;\n    var canvas = that.getValueAxis().getCanvas();\n    that._visibleArea = {\n      minX: canvas.left,\n      maxX: canvas.width - canvas.right,\n      minY: canvas.top,\n      maxY: canvas.height - canvas.bottom\n    };\n  }\n});","map":null,"metadata":{},"sourceType":"script"}